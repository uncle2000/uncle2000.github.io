<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="王水泥">


    <meta name="subtitle" content="技术，etc">


    <meta name="description" content="不要传播">



<title>Flutter | 王水泥个人博客</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    




<meta name="generator" content="Hexo 5.4.2"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">王水泥的博客</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">王水泥的博客</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Flutter</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">王水泥</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">十一月 1, 2022&nbsp;&nbsp;16:23:33</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Android-%E5%91%A8%E8%BE%B9/">Android 周边</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h1><p>[toc]</p>
<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/AndroidAlvin/article/details/103364063">引入</a></p>
<h2 id="Dart"><a href="#Dart" class="headerlink" title="Dart"></a>Dart</h2><p>Dart作为高级语言，支持面向对象的很多特性，并且支持基于mixin的继承方式，基于mixin的继承方式是指：一个类可以继承自多个父类，相当于其他语言里的多继承。所有的类都有同一个基类Object，这和特性类似于Java语言，Java所有的类也都是继承自Object，也就是说一切皆对象。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>dart作为面向对象的语言，所以也有面向对象的三大特性，封装、继承、多态。封装就是之前的_前缀，而dart以库作为单位的，而库则是dart中的文件。接下来我们先看继承。</p>
<p>继承。使用extends关键字。格式和Java的是一样的。继承是复用的一种手段，子类继承父类，会继承父类的所有公开属性和公开方法（包括计算属性），私有的属性和方法则不会被继承。子类可以覆写父类的公开方法。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">int</span> age;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//私有属性，不能被访问</span></span><br><span class="line">  <span class="built_in">String</span> _birthday;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//是否成年，计算属性</span></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> isAdult =&gt; age &gt; <span class="number">18</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">void</span> run() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;run -&gt; name=<span class="subst">$name</span>, age=<span class="subst">$age</span>&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> study() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;study...&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//复写计算属性，加上@override注解</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> isAdult =&gt; age &gt; <span class="number">15</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//复写方法</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> run() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;student run...&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> student = <span class="keyword">new</span> Student();</span><br><span class="line">  student.study();</span><br><span class="line">  <span class="comment">//继承Person的可见属性</span></span><br><span class="line">  student.name = <span class="string">&#x27;wally&#x27;</span>;</span><br><span class="line">  student.age = <span class="number">17</span>;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;是否成年:<span class="subst">$&#123;student.isAdult&#125;</span>&#x27;</span>);</span><br><span class="line">  student.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多态。子类通过覆写覆写中的方法，在构造时，使用父类类型接收，调用父类方法则调用到了子类覆写的方法，则出现了多态。多态后，只能调用父类中公开的方法和属性，不能访问到子类的公开属性和方法了，如果要访问，则需要强转后调用。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多态</span></span><br><span class="line">Person person = <span class="keyword">new</span> Student();</span><br><span class="line">person.name = <span class="string">&#x27;barry&#x27;</span>;</span><br><span class="line">person.age = <span class="number">19</span>;</span><br><span class="line"><span class="comment">//多态后，只能访问父类中的属性和方法</span></span><br><span class="line">person.run();</span><br><span class="line"><span class="comment">//不能访问子类的方法</span></span><br><span class="line"><span class="comment">//person.study();</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//如果需要访问子类的方法，就需要强转</span></span><br><span class="line"><span class="keyword">if</span> (person <span class="keyword">is</span> Student) &#123;</span><br><span class="line">    person.study();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承中的构造方法<br>通过继承我们复用了父类的属性和方法，而构造方法，也会被复用，但和Java的有些许不同。</p>
<p>子类默认继承父类中的无参构造方法。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//重写无参构造方法</span></span><br><span class="line">  Person() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;person...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果父类没有无参构造方法，只有有参构造或命名构造放方法，则子类需要显示调用父类的有参构造方法或者命名构造方法，还可以结合初始化列表进行使用。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果父类没有无参构造方法，只有有参构造或命名构造放方法，则子类需要显示调用父类的有参构造方法或者命名构造方法</span></span><br><span class="line">  Person(<span class="keyword">this</span>.name);</span><br><span class="line"> </span><br><span class="line">  Person.withName(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">String</span> gender;</span><br><span class="line">    <span class="comment">//有参构造方法，调用父类的有参构造方法</span></span><br><span class="line">    Student(<span class="built_in">String</span> name, <span class="built_in">String</span> gender)</span><br><span class="line">      : gender = gender,</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//子类中的命名构造方法也是一样</span></span><br><span class="line">    Student.withName(<span class="keyword">this</span>.name, <span class="keyword">this</span>.gender)</span><br><span class="line">        <span class="keyword">super</span>.withName(name);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//如果gender在初始化列表中初始化也是可以的</span></span><br><span class="line">Student.withName(<span class="built_in">String</span> name) : <span class="keyword">super</span>.withName(name);</span><br><span class="line">  Student.withName(<span class="built_in">String</span> name, <span class="built_in">String</span> g)</span><br><span class="line">      <span class="comment">//初始化列表</span></span><br><span class="line">      : gender = g,</span><br><span class="line">        <span class="keyword">super</span>.withName(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象abstract是面向对象中的一个非常重要的概念，通常用于描述父类拥有一种行为但无法给出细节实现，而需要通过子类来实现抽象的细节。这种情况下父类被定义为抽象类，子类继承父类后实现其中的抽象方法。<br>同Java语言类似，Dart中的抽象类也使用abstract来实现，不过抽象函数无需使用abstract，直接给出定义不给出方法体实现即可<br>抽象类中可以有数据，可以有常规函数，可以有抽象函数，但抽象类不能实例化。子类继承抽象类后必须实现其中的抽象函数。<br>演示示例：Dog类继承Animal抽象类</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="keyword">new</span> Dog();</span><br><span class="line">  d.name = <span class="string">&quot;dog&quot;</span>;</span><br><span class="line">  d.eat();</span><br><span class="line">  d.display();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;  <span class="comment">//数据</span></span><br><span class="line">  <span class="keyword">void</span> display()&#123;  <span class="comment">//普通函数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;名字是:<span class="subst">$&#123;name&#125;</span>&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> eat(); <span class="comment">//抽象函数</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> eat() &#123; <span class="comment">//实现抽象函数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607058518396.png" alt="Alt text"></p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>和Java一样，dart也有接口，但是和Java还是有区别的。</p>
<p>首先，dart的接口没有interface关键字定义接口，而是普通类或抽象类都可以作为接口被实现。<br>同样使用implements关键字进行实现。<br>但是dart的接口有点奇怪，如果实现的类是普通类，<code>会将普通类和抽象中的属性的方法全部需要覆写一遍</code>。而因为抽象类可以定义抽象方法，普通类不可以，所以一般如果要实现像Java接口那样的方式，一般会使用抽象类。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//计算属性</span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> age =&gt; <span class="number">18</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">void</span> run() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Person run...&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//dart的接口，类也可以作为接口，使用implements关键字进行实现，需要将所有属性和方法都实现...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> age =&gt; <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> run() &#123;</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般会使用抽象类进行实现。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dart的接口有点奇怪，所以一般会将抽象类作为接口来使用</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> run();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> run() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;student...run...&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> student = <span class="keyword">new</span> Student();</span><br><span class="line">student.run();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="基于Mixins的多继承"><a href="#基于Mixins的多继承" class="headerlink" title="基于Mixins的多继承"></a>基于Mixins的多继承</h3><p>除了上面和其他语言类似的单继承外，在Dart中还提供了另一继承的机制就是基于Mixins的多继承，但是它不是真正意义上类的多继承，它始终还是只能有一个超类(基类)。</p>
<h4 id="为什么需要Mixins"><a href="#为什么需要Mixins" class="headerlink" title="为什么需要Mixins?"></a>为什么需要Mixins?</h4><p>为什么需要Mixins多继承？它实际上为了解决单继承所带来的问题，我们很多语言中都是采用了单继承+接口多实现的方式。但是这种方式并不能很好适用于所有场景。<br>假设一下下面场景，我们把车进行分类，然后下面的颜色条表示各种车辆具有的能力。<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607058774104.png" alt="Alt text"><br>我们通过上图就可以看到，这些车辆都有一个共同的父类 Vehicle,然后它又由两个抽象的子类: MotorVehicle 和 NonMotorVehicle 。有些类是具有相同的行为和能力，但是有的类又有自己独有的行为和能力。比如公交车 Bus 和摩托车 Motor 都能使用汽油驱动，但是摩托车 Motor 还能载货公交车 Bus 却不可以。<br>如果仅仅是单继承模型下，无法把部分子类具有相同行为和能力抽象放到基类，因为对于不具有该行为和能力的子类来说是不妥的，所以只能在各自子类另外实现。那么就问题来了，部分具有相同能力和行为的子类中都要保留一份相同的代码实现。这就是产生冗余，突然觉得单继承模型有点鸡肋，食之无味弃之可惜。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单继承模型的普通实现</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MotorVehicle</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NonMotorVehicle</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Motor</span> <span class="keyword">extends</span> <span class="title">MotorVehicle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> petrolDriven() =&gt; <span class="built_in">print</span>(<span class="string">&quot;汽油驱动&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">void</span> passengerService() =&gt; <span class="built_in">print</span>(<span class="string">&#x27;载人&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">void</span> carryCargo() =&gt; <span class="built_in">print</span>(<span class="string">&#x27;载货&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">MotorVehicle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> petrolDriven() =&gt; <span class="built_in">print</span>(<span class="string">&quot;汽油驱动&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">void</span> electricalDriven() =&gt; <span class="built_in">print</span>(<span class="string">&quot;电能驱动&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">void</span> passengerService() =&gt; <span class="built_in">print</span>(<span class="string">&#x27;载人&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Truck</span> <span class="keyword">extends</span> <span class="title">MotorVehicle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> petrolDriven() =&gt; <span class="built_in">print</span>(<span class="string">&quot;汽油驱动&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">void</span> carryCargo() =&gt; <span class="built_in">print</span>(<span class="string">&#x27;载货&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bicycle</span> <span class="keyword">extends</span> <span class="title">NonMotorVehicle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> electricalDriven() =&gt; <span class="built_in">print</span>(<span class="string">&quot;电能驱动&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">void</span> passengerService() =&gt; <span class="built_in">print</span>(<span class="string">&#x27;载人&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bike</span> <span class="keyword">extends</span> <span class="title">NonMotorVehicle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> passengerService() =&gt; <span class="built_in">print</span>(<span class="string">&#x27;载人&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以从上述实现代码来看发现，有很多相同冗余代码实现，请注意这里所说的相同代码是连具体实现都相同的。很多人估计想到一个办法那就是将各个能力提升成接口，然后各自的选择去实现相应能力。但是我们知道即使抽成了接口，各个实现类中还是需要写对应的实现代码，冗余还是无法摆脱。不妨我们来试试用接口:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单继承+接口多实现</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MotorVehicle</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NonMotorVehicle</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//将各自的能力抽成独立的接口，这样的好处就是可以从抽象角度对不同的实现类赋予不同接口能力，</span></span><br><span class="line"><span class="comment">// 职责更加清晰,但是这个只是一方面的问题，它还是无法解决相同能力实现代码冗余的问题</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PetrolDriven</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> petrolDriven();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PassengerService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> passengerService();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CargoService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> carryCargo();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ElectricalDriven</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> electricalDriven();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//对于Motor赋予了PetrolDriven、PassengerService、CargoService能力</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Motor</span> <span class="keyword">extends</span> <span class="title">MotorVehicle</span> <span class="keyword">implements</span> <span class="title">PetrolDriven</span>, <span class="title">PassengerService</span>, <span class="title">CargoService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> carryCargo() =&gt; <span class="built_in">print</span>(<span class="string">&#x27;载货&#x27;</span>);<span class="comment">//仍然需要重写carryCargo</span></span><br><span class="line"> </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> passengerService() =&gt; <span class="built_in">print</span>(<span class="string">&#x27;载人&#x27;</span>);<span class="comment">//仍然需要重写passengerService</span></span><br><span class="line"> </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> petrolDriven() =&gt; <span class="built_in">print</span>(<span class="string">&quot;汽油驱动&quot;</span>);<span class="comment">//仍然需要重写petrolDriven</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//对于Bus赋予了PetrolDriven、ElectricalDriven、PassengerService能力</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">MotorVehicle</span> <span class="keyword">implements</span> <span class="title">PetrolDriven</span>, <span class="title">ElectricalDriven</span>, <span class="title">PassengerService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> electricalDriven() =&gt; <span class="built_in">print</span>(<span class="string">&quot;电能驱动&quot;</span>);<span class="comment">//仍然需要重写electricalDriven</span></span><br><span class="line"> </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> passengerService() =&gt; <span class="built_in">print</span>(<span class="string">&#x27;载人&#x27;</span>);<span class="comment">//仍然需要重写passengerService</span></span><br><span class="line"> </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> petrolDriven() =&gt; <span class="built_in">print</span>(<span class="string">&quot;汽油驱动&quot;</span>);<span class="comment">//仍然需要重写petrolDriven</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//对于Truck赋予了PetrolDriven、CargoService能力</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Truck</span> <span class="keyword">extends</span> <span class="title">MotorVehicle</span> <span class="keyword">implements</span> <span class="title">PetrolDriven</span>, <span class="title">CargoService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> carryCargo() =&gt; <span class="built_in">print</span>(<span class="string">&#x27;载货&#x27;</span>);<span class="comment">//仍然需要重写carryCargo</span></span><br><span class="line"> </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> petrolDriven() =&gt; <span class="built_in">print</span>(<span class="string">&quot;汽油驱动&quot;</span>);<span class="comment">//仍然需要重写petrolDriven</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//对于Bicycle赋予了ElectricalDriven、PassengerService能力</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bicycle</span> <span class="keyword">extends</span> <span class="title">NonMotorVehicle</span> <span class="keyword">implements</span> <span class="title">ElectricalDriven</span>, <span class="title">PassengerService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> electricalDriven() =&gt; <span class="built_in">print</span>(<span class="string">&quot;电能驱动&quot;</span>);<span class="comment">//仍然需要重写electricalDriven</span></span><br><span class="line"> </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> passengerService() =&gt; <span class="built_in">print</span>(<span class="string">&#x27;载人&#x27;</span>);<span class="comment">//仍然需要重写passengerService</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//对于Bike赋予了PassengerService能力</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bike</span> <span class="keyword">extends</span> <span class="title">NonMotorVehicle</span> <span class="keyword">implements</span> <span class="title">PassengerService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> passengerService() =&gt; <span class="built_in">print</span>(<span class="string">&#x27;载人&#x27;</span>);<span class="comment">//仍然需要重写passengerService</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对相同实现代码冗余的问题，使用Mixins就能很好的解决。它能复用类中某个行为的具体实现，而不是像接口仅仅从抽象角度规定了实现类具有哪些能力，至于具体实现接口方法都必须重写，也就意味着即使是相同的实现还得重新写一遍。一起看下Mixins改写后代码:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mixins多继承模型实现</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MotorVehicle</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NonMotorVehicle</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//将各自的能力抽成独立的Mixin类</span></span><br><span class="line"><span class="keyword">mixin</span> PetrolDriven &#123;<span class="comment">//使用mixin关键字代替class声明一个Mixin类</span></span><br><span class="line">  <span class="keyword">void</span> petrolDriven() =&gt; <span class="built_in">print</span>(<span class="string">&quot;汽油驱动&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">mixin</span> PassengerService &#123;<span class="comment">//使用mixin关键字代替class声明一个Mixin类</span></span><br><span class="line">  <span class="keyword">void</span> passengerService() =&gt; <span class="built_in">print</span>(<span class="string">&#x27;载人&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">mixin</span> CargoService &#123;<span class="comment">//使用mixin关键字代替class声明一个Mixin类</span></span><br><span class="line">  <span class="keyword">void</span> carryCargo() =&gt; <span class="built_in">print</span>(<span class="string">&#x27;载货&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">mixin</span> ElectricalDriven &#123;<span class="comment">//使用mixin关键字代替class声明一个Mixin类</span></span><br><span class="line">  <span class="keyword">void</span> electricalDriven() =&gt; <span class="built_in">print</span>(<span class="string">&quot;电能驱动&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Motor</span> <span class="keyword">extends</span> <span class="title">MotorVehicle</span> <span class="title">with</span> <span class="title">PetrolDriven</span>, <span class="title">PassengerService</span>, <span class="title">CargoService</span> </span>&#123;&#125;<span class="comment">//利用with关键字使用mixin类</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">MotorVehicle</span> <span class="title">with</span> <span class="title">PetrolDriven</span>, <span class="title">ElectricalDriven</span>, <span class="title">PassengerService</span> </span>&#123;&#125;<span class="comment">//利用with关键字使用mixin类</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Truck</span> <span class="keyword">extends</span> <span class="title">MotorVehicle</span> <span class="title">with</span> <span class="title">PetrolDriven</span>, <span class="title">CargoService</span> </span>&#123;&#125;<span class="comment">//利用with关键字使用mixin类</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bicycle</span> <span class="keyword">extends</span> <span class="title">NonMotorVehicle</span> <span class="title">with</span> <span class="title">ElectricalDriven</span>, <span class="title">PassengerService</span> </span>&#123;&#125;<span class="comment">//利用with关键字使用mixin类</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bike</span> <span class="keyword">extends</span> <span class="title">NonMotorVehicle</span> <span class="title">with</span> <span class="title">PassengerService</span> </span>&#123;&#125;<span class="comment">//利用with关键字使用mixin类</span></span><br></pre></td></tr></table></figure>
<p>可以对比发现Mixins类能真正地解决相同代码冗余的问题，并能实现很好的复用；所以使用Mixins多继承模型可以很好地解决单继承模型所带来冗余问题。</p>
<h4 id="Mixins是什么"><a href="#Mixins是什么" class="headerlink" title="Mixins是什么?"></a>Mixins是什么?</h4><p>用dart官网一句话来概括: Mixins是一种可以在多个类层次结构中复用类代码的方式。</p>
<p>基本语法</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">方式一: Mixins类使用关键字 <span class="keyword">mixin</span> 声明定义</span><br><span class="line"> </span><br><span class="line"><span class="keyword">mixin</span> PetrolDriven &#123;<span class="comment">//使用mixin关键字代替class声明一个Mixin类</span></span><br><span class="line">  <span class="keyword">void</span> petrolDriven() =&gt; <span class="built_in">print</span>(<span class="string">&quot;汽油驱动&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Motor</span> <span class="keyword">extends</span> <span class="title">MotorVehicle</span> <span class="title">with</span> <span class="title">PetrolDriven</span> </span>&#123;<span class="comment">//使用with关键字来使用mixin类</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Petrol</span> <span class="keyword">extends</span> <span class="title">PetrolDriven</span></span>&#123;<span class="comment">//编译异常，注意:mixin类不能被继承</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">main() &#123;</span><br><span class="line">    <span class="keyword">var</span> petrolDriven = PetrolDriven()<span class="comment">//编译异常，注意:mixin类不能实例化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方式二: Dart中的普通类当作Mixins类使用</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PetrolDriven</span> </span>&#123;</span><br><span class="line">    <span class="keyword">factory</span> PetrolDriven._() =&gt; <span class="keyword">null</span>;<span class="comment">//主要是禁止PetrolDriven被继承以及实例化</span></span><br><span class="line">    <span class="keyword">void</span> petrolDriven() =&gt; <span class="built_in">print</span>(<span class="string">&quot;汽油驱动&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Motor</span> <span class="keyword">extends</span> <span class="title">MotorVehicle</span> <span class="title">with</span> <span class="title">PetrolDriven</span> </span>&#123;<span class="comment">//普通类也可以作为Mixins类使用</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用Mixins多继承的场景"><a href="#使用Mixins多继承的场景" class="headerlink" title="使用Mixins多继承的场景"></a>使用Mixins多继承的场景</h4><p>那么问题来了，什么时候去使用Mixins呢？<br>当想要在不同的类层次结构中多个类之间共享相同的行为时或者无法合适抽象出部分子类共同的行为到基类中时.<br>比如说上述例子中在 MotorVehicle (机动车)和 Non-MotorVehicle (非机动车)两个不同类层次结构中，其中 Bus (公交车)和 Bicycle (电动自行车)都有相同行为 ElectricalDriven 和 PassengerService. 但是很明显你无法把这个两个共同的行为抽象到基类 Vehicle 中，因为这样的话 Bike (自行车)继承 Vehicle 会自动带有一个 ElectricalDriven 行为就比较诡异。所以这种场景下mixins就是一个不错的选择，可以跨类层次之间复用相同行为的实现。</p>
<h4 id="Mixins的线性化分析"><a href="#Mixins的线性化分析" class="headerlink" title="Mixins的线性化分析"></a>Mixins的线性化分析</h4><p>在说Mixins线性化分析之前，一起先来看个例子</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">   <span class="keyword">void</span> printMsg() =&gt; <span class="built_in">print</span>(<span class="string">&#x27;A&#x27;</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">mixin</span> B &#123;</span><br><span class="line">    <span class="keyword">void</span> printMsg() =&gt; <span class="built_in">print</span>(<span class="string">&#x27;B&#x27;</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">mixin</span> C &#123;</span><br><span class="line">    <span class="keyword">void</span> printMsg() =&gt; <span class="built_in">print</span>(<span class="string">&#x27;C&#x27;</span>); </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BC</span> <span class="keyword">extends</span> <span class="title">A</span> <span class="title">with</span> <span class="title">B</span>, <span class="title">C</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CB</span> <span class="keyword">extends</span> <span class="title">A</span> <span class="title">with</span> <span class="title">C</span>, <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">main() &#123;</span><br><span class="line">    <span class="keyword">var</span> bc = BC();</span><br><span class="line">    bc.printMsg();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> cb = CB();</span><br><span class="line">    cb.printMsg();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不妨考虑下上述例子中应该输出啥呢?</p>
<p>输出结果:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">B</span><br><span class="line"> </span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>为什么会是这样的结果？实际上可以通过线性分析得到输出结果。理解Mixin线性化分析有一点很重要就是:<br>在Dart中Mixins多继承并不是真正意义上的多继承，实际上还是单继承；而每次Mixin都是会创建一个新的中间类。并且这个中间类总是在基类的上层。<br>关于上述结论可能有点难以理解，下面通过一张mixins继承结构图就能清晰明白了:<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607059166947.png" alt="Alt text"><br>通过上图，我们可以很清楚发现Mixins并不是经典意义上获得多重继承的方法。 Mixins是一种抽象和复用一系列操作和状态的方式，而是生成多个中间的mixin类(比如生成ABC类，AB类，ACB类，AC类)。它类似于从扩展类获得的复用，但由于它是线性的，因此与单继承兼容。<br>上述mixins代码在语义理解上可以转化成下面形式:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A with B 会产生AB类混合体，B类中printMsg方法会覆盖A类中的printMsg方法,那么AB中间类保留是B类中的printMsg方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AB</span> = <span class="title">A</span> <span class="title">with</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class">//<span class="title">AB</span> <span class="title">with</span> <span class="title">C</span> 会产生<span class="title">ABC</span>类混合体,<span class="title">C</span>类中<span class="title">printMsg</span>方法会覆盖<span class="title">AB</span>混合类中的<span class="title">printMsg</span>方法，那么<span class="title">ABC</span>中间类保留<span class="title">C</span>类中<span class="title">printMsg</span>方法</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">ABC</span> = <span class="title">AB</span> <span class="title">with</span> <span class="title">C</span>;</span></span><br><span class="line"><span class="class">//最终<span class="title">BC</span>类相当于继承的是<span class="title">ABC</span>类混合体，最后调用的方法是<span class="title">ABC</span>中间类保留<span class="title">C</span>类中<span class="title">printMsg</span>方法，最后输出<span class="title">C</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">BC</span> <span class="keyword">extends</span> <span class="title">ABC</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//A with C 会产生AC类混合体，C类中printMsg方法会覆盖A类中的printMsg方法,那么AC中间类保留是C类中的printMsg方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AC</span> = <span class="title">A</span> <span class="title">with</span> <span class="title">C</span>;</span></span><br><span class="line"><span class="class">//<span class="title">AC</span> <span class="title">with</span> <span class="title">B</span> 会产生<span class="title">ACB</span>类混合体,<span class="title">B</span>类中<span class="title">printMsg</span>方法会覆盖<span class="title">AC</span>混合类中的<span class="title">printMsg</span>方法，那么<span class="title">ACB</span>中间类保留<span class="title">B</span>类中<span class="title">printMsg</span>方法</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">ACB</span> = <span class="title">AC</span> <span class="title">with</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class">//最终<span class="title">CB</span>类相当于继承的是<span class="title">ACB</span>类混合体，最后调用的方法是<span class="title">ACB</span>中间类保留<span class="title">B</span>类中<span class="title">printMsg</span>方法，最后输出<span class="title">B</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">CB</span> <span class="keyword">extends</span> <span class="title">ACB</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Mixins中的类型"><a href="#Mixins中的类型" class="headerlink" title="Mixins中的类型"></a>Mixins中的类型</h4><p>有了上面的探索，不妨再来考虑一个问题，mixin的实例对象是什么类型呢? 我们都知道它肯定是它基类的子类型。 一起来看个例子：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">   <span class="keyword">void</span> printMsg() =&gt; <span class="built_in">print</span>(<span class="string">&#x27;A&#x27;</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">mixin</span> B &#123;</span><br><span class="line">    <span class="keyword">void</span> printMsg() =&gt; <span class="built_in">print</span>(<span class="string">&#x27;B&#x27;</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">mixin</span> C &#123;</span><br><span class="line">    <span class="keyword">void</span> printMsg() =&gt; <span class="built_in">print</span>(<span class="string">&#x27;C&#x27;</span>); </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BC</span> <span class="keyword">extends</span> <span class="title">A</span> <span class="title">with</span> <span class="title">B</span>, <span class="title">C</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CB</span> <span class="keyword">extends</span> <span class="title">A</span> <span class="title">with</span> <span class="title">C</span>, <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">main() &#123;</span><br><span class="line">    <span class="keyword">var</span> bc = BC();</span><br><span class="line">    <span class="built_in">print</span>(bc <span class="keyword">is</span> A);</span><br><span class="line">    <span class="built_in">print</span>(bc <span class="keyword">is</span> B);</span><br><span class="line">    <span class="built_in">print</span>(bc <span class="keyword">is</span> C);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> cb = CB();</span><br><span class="line">    <span class="built_in">print</span>(cb <span class="keyword">is</span> A);</span><br><span class="line">    <span class="built_in">print</span>(cb <span class="keyword">is</span> B);</span><br><span class="line">    <span class="built_in">print</span>(cb <span class="keyword">is</span> C);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"> </span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>可以看到输出结果全都是true, 这是为什么呢？<br>其实通过上面那张图就能找到答案，我们知道mixin with后就会生成新的中间类，比如中间类AB、ABC. 同时也会生成<br>一个新的接口AB、ABC(因为所有Dart类都定义了对应的接口, Dart类是可以直接当做接口实现的)。新的中间类AB继承基类A以及A类和B类混合的成员(方法和属性)副本，但它也实现了A接口和B接口。那么就很容易理解，ABC混合类最后会实现了A、B、C三个接口，最后BC类继承ABC类实际上也相当于间接实现了A、B、C三个接口，所以BC类肯定是A、B、C的子类型，故所有输出都是true。<br>其实一般情况mixin中间类和接口都是不能直接引用的，比如这种情况:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BC</span> <span class="keyword">extends</span> <span class="title">A</span> <span class="title">with</span> <span class="title">B</span>, <span class="title">C</span> </span>&#123;&#125;<span class="comment">//这种情况我们无法直接引用中间AB混合类和接口、ABC混合类和接口</span></span><br></pre></td></tr></table></figure>
<p>但是如果这么写，就能直接引用中间混合类和接口了:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> printMsg() =&gt; <span class="built_in">print</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">mixin</span> B &#123;</span><br><span class="line">  <span class="keyword">void</span> printMsg() =&gt; <span class="built_in">print</span>(<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">mixin</span> C &#123;</span><br><span class="line">  <span class="keyword">void</span> printMsg() =&gt; <span class="built_in">print</span>(<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AB</span> = <span class="title">A</span> <span class="title">with</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"> </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">ABC</span> = <span class="title">AB</span> <span class="title">with</span> <span class="title">C</span>;</span></span><br><span class="line"><span class="class"> </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">AB</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span> <span class="keyword">implements</span> <span class="title">AB</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> printMsg() &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement printMsg</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span> <span class="keyword">extends</span> <span class="title">ABC</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">G</span> <span class="keyword">implements</span> <span class="title">ABC</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> printMsg() &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement printMsg</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> ab = AB();</span><br><span class="line">  <span class="built_in">print</span>(ab <span class="keyword">is</span> A);</span><br><span class="line">  <span class="built_in">print</span>(ab <span class="keyword">is</span> B);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">var</span> e = E();</span><br><span class="line">  <span class="built_in">print</span>(e <span class="keyword">is</span> A);</span><br><span class="line">  <span class="built_in">print</span>(e <span class="keyword">is</span> B);</span><br><span class="line">  <span class="built_in">print</span>(e <span class="keyword">is</span> AB);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">var</span> abc = ABC();</span><br><span class="line">  <span class="built_in">print</span>(abc <span class="keyword">is</span> A);</span><br><span class="line">  <span class="built_in">print</span>(abc <span class="keyword">is</span> B);</span><br><span class="line">  <span class="built_in">print</span>(abc <span class="keyword">is</span> C);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">var</span> f = F();</span><br><span class="line">  <span class="built_in">print</span>(f <span class="keyword">is</span> A);</span><br><span class="line">  <span class="built_in">print</span>(f <span class="keyword">is</span> B);</span><br><span class="line">  <span class="built_in">print</span>(f <span class="keyword">is</span> C);</span><br><span class="line">  <span class="built_in">print</span>(f <span class="keyword">is</span> AB);</span><br><span class="line">  <span class="built_in">print</span>(f <span class="keyword">is</span> ABC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"> </span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>在Dart函数参数是一个比较重要的概念，此外它涉及到概念的种类比较多，比如位置参数、命名参数、可选位置参数、可选命名参数等等。函数总是有一个所谓形参列表，虽然这个参数列表可能为空，比如getter函数就是没有参数列表的. 此外在Dart中函数参数大致可分为两种: 位置参数和命名参数，来一张图理清它们的概念关系<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607059616445.png" alt="Alt text"></p>
<h4 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h4><p>位置参数可以必需的也可以是可选。</p>
<ul>
<li>无参数<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参数类型-这是不带函数参数或者说参数列表为空</span></span><br><span class="line"><span class="built_in">String</span> getDefaultErrorMsg() =&gt; <span class="string">&#x27;Unknown Error!&#x27;</span>;</span><br><span class="line"><span class="comment">//无参数类型-等价于上面函数形式，同样是参数列表为空</span></span><br><span class="line"><span class="keyword">get</span> getDefaultErrorMsg =&gt; <span class="string">&#x27;Unknown Error!&#x27;</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li>
<li>必需位置参数<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//必需位置参数类型-这里的exception是必需的位置参数</span></span><br><span class="line"><span class="built_in">String</span> getErrorMsg(Exception exception) =&gt; exception.toString();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li>
<li>可选位置参数<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意: 可选位置参数是中括号括起来表示，例如[String error]</span></span><br><span class="line"><span class="built_in">String</span> getErrorMsg([<span class="built_in">String</span> error]) =&gt; error ?? <span class="string">&#x27;Unknown Error!&#x27;</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li>
<li>必需位置参数和可选位置参数混合<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意: 可选位置参数必须在必需位置参数的后面</span></span><br><span class="line"><span class="built_in">String</span> getErrorMsg(Exception exception, [<span class="built_in">String</span> extraInfo]) =&gt; <span class="string">&#x27;<span class="subst">$&#123;exception.toString()&#125;</span>---<span class="subst">$extraInfo</span>&#x27;</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h4><p>命名参数始终是可选参数。为什么是命名参数，这是因为在调用函数时可以任意指定参数名来传参。</p>
<ul>
<li>可选命名参数<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意: 可选命名参数是大括号括起来表示，例如&#123;num a, num b, num c, num d&#125;</span></span><br><span class="line"><span class="built_in">num</span> add(&#123;<span class="built_in">num</span> a, <span class="built_in">num</span> b, <span class="built_in">num</span> c, <span class="built_in">num</span> d&#125;) &#123;</span><br><span class="line">   <span class="keyword">return</span> a + b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">main() &#123;</span><br><span class="line">   <span class="built_in">print</span>(add(d: <span class="number">4</span>, b: <span class="number">3</span>, a: <span class="number">2</span>, c: <span class="number">1</span>));<span class="comment">//这里的命名参数就是可以任意顺序指定参数名传值,例如d: 4, b: 3, a: 2, c: 1</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li>
<li>必需位置参数和可选命名参数混合<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意: 可选命名参数必须在必需位置参数的后面</span></span><br><span class="line"><span class="built_in">num</span> add(<span class="built_in">num</span> a, <span class="built_in">num</span> b, &#123;<span class="built_in">num</span> c, <span class="built_in">num</span> d&#125;) &#123;</span><br><span class="line">   <span class="keyword">return</span> a + b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">main() &#123;</span><br><span class="line">   <span class="built_in">print</span>(add(<span class="number">4</span>, <span class="number">5</span>, d: <span class="number">3</span>, c: <span class="number">1</span>));<span class="comment">//这里的命名参数就是可以任意顺序指定参数名传值,例如d: 3, c: 1,但是必需参数必须按照顺序传参。</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li>
<li>注意: 可选位置参数和可选命名参数不能混合在一起使用，因为可选参数列表只能位于整个函数形参列表的最后。<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> add7([<span class="built_in">num</span> a, <span class="built_in">num</span> b], &#123;<span class="built_in">num</span> c, <span class="built_in">num</span> d&#125;) &#123;<span class="comment">//非法声明，想想也没有必要两者一起混合使用场景。所以</span></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="关于可选位置参数-num-a-num-b-和可选命名参数-num-a-num-b-使用场景"><a href="#关于可选位置参数-num-a-num-b-和可选命名参数-num-a-num-b-使用场景" class="headerlink" title="关于可选位置参数[num a, num b]和可选命名参数{num a, num b}使用场景"></a>关于可选位置参数[num a, num b]和可选命名参数{num a, num b}使用场景</h3><p>可能问题来了，啥时候使用可选位置参数，啥时候使用可选命名参数呢?</p>
<p>这里给个建议: 首先，参数是非必需的也就是可选的，如果可选参数个数只有一个建议直接使用可选位置参数[num a, num b]；如果可选参数个数是多个的话建议用可选命名参数{num a, num b}. 因为多个参数可选，指定参数名传参对整体代码可读性有一定的增强。</p>
<h3 id="参数默认值-针对可选参数"><a href="#参数默认值-针对可选参数" class="headerlink" title="参数默认值(针对可选参数)"></a>参数默认值(针对可选参数)</h3><p>首先，需要明确一点，参数默认值只针对可选参数才能添加的。可以使用 &#x3D; 来定义命名和位置参数的默认值。默认值必须是编译时常量。如果没有提供默认值，则默认值为null。</p>
<ul>
<li>可选位置参数默认值<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">num</span> add(<span class="built_in">num</span> a, <span class="built_in">num</span> b, <span class="built_in">num</span> c, [<span class="built_in">num</span> d = <span class="number">5</span>]&#125;) &#123;<span class="comment">//使用=来赋值默认值</span></span><br><span class="line">    <span class="keyword">return</span> a + b + c + d;</span><br><span class="line">&#125;</span><br><span class="line">main() &#123;</span><br><span class="line">    <span class="built_in">print</span>(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));<span class="comment">//有默认值参数可以省略不传 实际上求和结果是: 1 + 2 + 3 + 5(默认值)</span></span><br><span class="line">    <span class="built_in">print</span>(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));<span class="comment">//有默认值参数指定传入4，会覆盖默认值，所以求和结果是: 1 + 2 + 3 + 4</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li>
<li>可选命名参数默认值<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">num</span> add(&#123;<span class="built_in">num</span> a, <span class="built_in">num</span> b, <span class="built_in">num</span> c = <span class="number">3</span>, <span class="built_in">num</span> d = <span class="number">4</span>&#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c + d;</span><br><span class="line">&#125;</span><br><span class="line">main() &#123;</span><br><span class="line">    <span class="built_in">print</span>(add(<span class="number">100</span>, <span class="number">100</span>, d: <span class="number">100</span>, c: <span class="number">100</span>));    </span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="匿名函数-闭包，lambda"><a href="#匿名函数-闭包，lambda" class="headerlink" title="匿名函数(闭包，lambda)"></a>匿名函数(闭包，lambda)</h3><p>在Dart中可以创建一个没有函数名称的函数，这种函数称为匿名函数，或者lambda函数或者闭包函数。但是和其他函数一样，它也有形参列表，可以有可选参数。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">num</span> x) =&gt; x;<span class="comment">//没有函数名，有必需的位置参数x</span></span><br><span class="line">(<span class="built_in">num</span> x) &#123;<span class="keyword">return</span> x;&#125;<span class="comment">//等价于上面形式</span></span><br><span class="line">(<span class="built_in">int</span> x, [<span class="built_in">int</span> step]) =&gt; x + step;<span class="comment">//没有函数名，有可选的位置参数step</span></span><br><span class="line">(<span class="built_in">int</span> x, &#123;<span class="built_in">int</span> step1, <span class="built_in">int</span> step2&#125;) =&gt; x + step1 + step2;没有函数名，有可选的命名参数step1、step2</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>闭包在dart中的应用<br>闭包函数在dart用的特别多，单从集合中操作符来说就有很多。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; numbers = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">4</span>];</span><br><span class="line">  <span class="comment">//reduce函数实现累加，reduce函数中接收的(prev, curr) =&gt; prev + curr就是一个闭包</span></span><br><span class="line">  <span class="built_in">print</span>(numbers.reduce((prev, curr) =&gt; prev + curr));</span><br><span class="line">  <span class="comment">//还可以不用闭包形式来写，但是这并不是一个好的方案,不建议下面这样使用。</span></span><br><span class="line">  plus(prev, curr) =&gt; prev + curr;</span><br><span class="line">  <span class="built_in">print</span>(numbers.reduce(plus));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//reduce函数定义</span></span><br><span class="line"> E reduce(E combine(E value, E element)) &#123;<span class="comment">//combine闭包函数</span></span><br><span class="line">    <span class="built_in">Iterator</span>&lt;E&gt; iterator = <span class="keyword">this</span>.iterator;</span><br><span class="line">    <span class="keyword">if</span> (!iterator.moveNext()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> IterableElementError.noElement();</span><br><span class="line">    &#125;</span><br><span class="line">    E value = iterator.current;</span><br><span class="line">    <span class="keyword">while</span> (iterator.moveNext()) &#123;</span><br><span class="line">      value = combine(value, iterator.current);<span class="comment">//执行combine函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>在Dart中还有一种函数的简写形式，那就是箭头函数。箭头函数是只能包含一行表达式的函数，会注意到它没有花括号，而是带有箭头的。箭头函数更有助于代码的可读性，类似于Kotlin或Java中的lambda表达式-&gt;的写法。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; numbers = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">4</span>];</span><br><span class="line">  <span class="built_in">print</span>(numbers.reduce((prev, curr) &#123;<span class="comment">//闭包简写形式</span></span><br><span class="line">        <span class="keyword">return</span> prev + curr;</span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="built_in">print</span>(numbers.reduce((prev, curr) =&gt; prev + curr)); <span class="comment">//等价于上述形式，箭头函数简写形式</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="局部函数"><a href="#局部函数" class="headerlink" title="局部函数"></a>局部函数</h3><p>在Dart中还有一种可以直接定义在函数体内部的函数，可以把称为局部函数或者内嵌函数。我们知道函数声明可以出现顶层，比如常见的main函数等等。局部函数的好处就是从作用域角度来看，它可以访问外部函数变量，并且还能避免引入一个额外的外部函数，使得整个函数功能职责统一。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义外部函数fibonacci</span></span><br><span class="line"><span class="built_in">int</span> fibonacci(<span class="built_in">int</span> n) &#123;</span><br><span class="line">    <span class="comment">//定义局部函数lastTwo</span></span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; lastTwo(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> &lt;<span class="built_in">int</span>&gt;[<span class="number">0</span>, <span class="number">1</span>];  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">var</span> p = lastTwo(n - <span class="number">1</span>);</span><br><span class="line">           <span class="keyword">return</span> &lt;<span class="built_in">int</span>&gt;[p[<span class="number">1</span>], p[<span class="number">0</span>] + p[<span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lastTwo(n)[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="顶层函数和静态函数"><a href="#顶层函数和静态函数" class="headerlink" title="顶层函数和静态函数"></a>顶层函数和静态函数</h3><p>在Dart中有一种特别的函数，我们知道在面向对象语言中比如Java，并不能直接定义一个函数的，而是需要定义一个类，然后在类中定义函数。但是在Dart中可以不用在类中定义函数，而是直接基于dart文件顶层定义函数，这种函数我们一般称为顶层函数。最常见就是main函数了。而静态函数就和Java中类似，依然使用static关键字来声明，然后必须是定义在类的内部的。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顶层函数，不定义在类的内部</span></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;hello dart&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">int</span> getValue() =&gt; <span class="number">100</span>;<span class="comment">//static修饰定义在类的内部。</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><p>每个应用程序都有一个顶级的main()函数，它作为应用程序的入口点。main()函数返回void，所以在dart可以直接省略void，并有一个可选的列表参数作为参数。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//你一般看到的main是这样的</span></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;hello dart&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实际上它和Java类似可以带个参数列表</span></span><br><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;hello dart: <span class="subst">$&#123;args[<span class="number">0</span>]&#125;</span>, <span class="subst">$&#123;args[<span class="number">1</span>]&#125;</span>&#x27;</span>);<span class="comment">//用dart command执行的时候: dart test.dart arg0 arg1 =&gt;输出:hello dart: arg0, arg1    </span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="Function函数对象"><a href="#Function函数对象" class="headerlink" title="Function函数对象"></a>Function函数对象</h3><p>在Dart中一切都是对象，函数也不例外，函数可以作为一个参数传递。其中Function类是代表所有函数的公共顶层接口抽象类。Function类中并没有声明任何实例方法。但是它有一个非常重要的静态类函数apply. 该函数接收一个Function对象function，一个List的参数positionalArguments以及一个可选参数Map&lt;Symbol, dynamic&gt;类型的namedArguments。大家似乎明白了什么？知道为啥dart中函数支持位置参数和命名参数吗? 没错就是它们两个参数功劳。实际上，apply()函数提供一种使用动态确定的参数列表来调用函数的机制，通过它我们就能处理在编译时参数列表不确定的情况。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="keyword">external</span> <span class="keyword">static</span> apply(<span class="built_in">Function</span> function, <span class="built_in">List</span> positionalArguments,</span><br><span class="line">      [<span class="built_in">Map</span>&lt;<span class="built_in">Symbol</span>, <span class="built_in">dynamic</span>&gt; namedArguments]);<span class="comment">//可以看到这是external声明，我们需要找到对应的function_patch.dart实现</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> hashCode;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">operator</span> ==(<span class="built_in">Object</span> other);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>在sdk源码中找到sdk&#x2F;lib&#x2F;_internal&#x2F;vm&#x2F;lib&#x2F;function_patch.dart对应的function_patch的实现</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@(其他语言/平台)patch</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO(regis): Pass type arguments to generic functions. Wait for API spec.</span></span><br><span class="line">  <span class="comment">//可以看到内部私有的_apply函数，最终接收两个List原生类型的参数arguments,names分别代表着我们使用函数时</span></span><br><span class="line">  <span class="comment">//定义的所有参数List集合arguments(包括位置参数和命名参数)以及命名参数名List集合names，不过它是委托到native层的Function_apply C++函数实现的。</span></span><br><span class="line">  <span class="keyword">static</span> _apply(<span class="built_in">List</span> arguments, <span class="built_in">List</span> names) native <span class="string">&quot;Function_apply&quot;</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@patch</span></span><br><span class="line">  <span class="keyword">static</span> apply(<span class="built_in">Function</span> function, <span class="built_in">List</span> positionalArguments,</span><br><span class="line">      [<span class="built_in">Map</span>&lt;<span class="built_in">Symbol</span>, <span class="built_in">dynamic</span>&gt; namedArguments]) &#123;</span><br><span class="line">    <span class="comment">//计算外部函数位置参数的个数  </span></span><br><span class="line">    <span class="built_in">int</span> numPositionalArguments = <span class="number">1</span> + <span class="comment">// 默认同时会传入function参数，所以默认+1</span></span><br><span class="line">        (positionalArguments != <span class="keyword">null</span> ? positionalArguments.length : <span class="number">0</span>);<span class="comment">//位置参数的集合不为空就返回集合长度否则返回0</span></span><br><span class="line">    <span class="comment">//计算外部函数命名参数的个数    </span></span><br><span class="line">    <span class="built_in">int</span> numNamedArguments = namedArguments != <span class="keyword">null</span> ? namedArguments.length : <span class="number">0</span>;;<span class="comment">//命名参数的集合不为空就返回集合长度否则返回0</span></span><br><span class="line">    <span class="comment">//计算所有参数个数总和: 位置参数个数 + 命名参数个数</span></span><br><span class="line">    <span class="built_in">int</span> numArguments = numPositionalArguments + numNamedArguments;</span><br><span class="line">    <span class="comment">//创建一个定长为所有参数个数大小的List集合arguments</span></span><br><span class="line">    <span class="built_in">List</span> arguments = <span class="keyword">new</span> <span class="built_in">List</span>(numArguments);</span><br><span class="line">    <span class="comment">//集合第一个元素默认是传入的function对象</span></span><br><span class="line">    arguments[<span class="number">0</span>] = function;</span><br><span class="line">    <span class="comment">//然后从1的位置开始插入所有的位置参数到arguments参数列表中</span></span><br><span class="line">    arguments.setRange(<span class="number">1</span>, numPositionalArguments, positionalArguments);</span><br><span class="line">    <span class="comment">//然后再创建一个定长为命名参数长度的List集合</span></span><br><span class="line">    <span class="built_in">List</span> names = <span class="keyword">new</span> <span class="built_in">List</span>(numNamedArguments);</span><br><span class="line">    <span class="built_in">int</span> argumentIndex = numPositionalArguments;</span><br><span class="line">    <span class="built_in">int</span> nameIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历命名参数Map集合</span></span><br><span class="line">    <span class="keyword">if</span> (numNamedArguments &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      namedArguments.forEach((name, value) &#123;</span><br><span class="line">        arguments[argumentIndex++] = value;<span class="comment">//把命名参数对象继续插入到arguments集合中</span></span><br><span class="line">        names[nameIndex++] = internal.<span class="built_in">Symbol</span>.getName(name);<span class="comment">//并把对应的参数名标识存入names集合中</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _apply(arguments, names);<span class="comment">//最后调用_apply函数传入所有参数对象集合以及命名参数名称集合</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>不妨再来瞅瞅C++层中的Function_apply的实现</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_NATIVE_ENTRY(Function_apply, <span class="number">0</span>, <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">int</span> kTypeArgsLen = <span class="number">0</span>;  <span class="comment">// TODO(regis): Add support for generic function.</span></span><br><span class="line">  <span class="keyword">const</span> Array&amp; fun_arguments =</span><br><span class="line">      Array::CheckedHandle(zone, arguments-&gt;NativeArgAt(<span class="number">0</span>));<span class="comment">//获取函数的所有参数对象数组 fun_arguments</span></span><br><span class="line">  <span class="keyword">const</span> Array&amp; fun_arg_names =</span><br><span class="line">      Array::CheckedHandle(zone, arguments-&gt;NativeArgAt(<span class="number">1</span>));<span class="comment">//获取函数的命名参数参数名数组 fun_arg_names</span></span><br><span class="line">  <span class="keyword">const</span> Array&amp; fun_args_desc = Array::Handle(</span><br><span class="line">      zone, ArgumentsDescriptor::New(kTypeArgsLen, fun_arguments.Length(),</span><br><span class="line">                                     fun_arg_names));<span class="comment">//利用 fun_arg_names生成对应命名参数描述符集合</span></span><br><span class="line"> <span class="comment">//注意: 这里会调用DartEntry中的InvokeClosure函数，传入了所有参数对象数组 fun_arguments和fun_arg_names生成对应命名参数描述符集合</span></span><br><span class="line"><span class="comment">//最后返回result</span></span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">Object</span>&amp; result = <span class="built_in">Object</span>::Handle(</span><br><span class="line">      zone, DartEntry::InvokeClosure(fun_arguments, fun_args_desc));</span><br><span class="line">  <span class="keyword">if</span> (result.IsError()) &#123;</span><br><span class="line">    Exceptions::PropagateError(Error::Cast(result));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.raw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="widget"><a href="#widget" class="headerlink" title="widget"></a>widget</h2><p>在Flutter中，几乎所有的对象都是一个 Widget，与原生开发中的控件不同的是，Flutter中的 widget的概念更广泛，它不仅可以表示UI元素，也可以表示一些功能性的组件如：用于手势检测的 GestureDetector widget、用于应用主题数据传递的 Theme等等。由于Flutter主要就是用于构建用户界面的，所以，在大多数时候，可以认为widget就是一个控件，不必纠结于概念。</p>
<p>Widget的功能是“描述一个UI元素的配置数据”，Widget其实并不是表示最终绘制在设备屏幕上的显示元素，而只是显示元素的一个配置数据。实际上，Flutter中真正代表屏幕上显示元素的类是 Element，也就是说Widget只是描述 Element的一个配置。一个Widget可以对应多个 Element，这是因为同一个Widget对象可以被添加到UI树的不同部分，而真正渲染时，UI树的每一个节点都会对应一个 Element对象。<br>StatelessWidget和 StatefulWidget是 flutter的基础组件，日常开发中自定义 Widget都是选择继承这两者之一。也是在往后的开放中，我们最多接触的Widget：<br>StatelessWidget：无状态的，展示信息，面向那些始终不变的UI控件；<br>StatefulWidget：有状态的，可以通过改变状态使得 UI 发生变化，可以包含用户交互(比如弹出一个 dialog)。</p>
<p>在实际使用中，Stateless与Stateful的选择需要取决于这个 Widget 是有状态还是无状态，简单来说看界面是否需要更新。</p>
<h3 id="StatelessWidget"><a href="#StatelessWidget" class="headerlink" title="StatelessWidget"></a>StatelessWidget</h3><p>StatelessWidget用于不需要维护状态的场景，它通常在 build方法中通过嵌套其它Widget来构建UI，在构建过程中会递归的构建其嵌套的Widget。<br>BuildContext表示构建widget的上下文，它是操作widget在树中位置的一个句柄，它包含了一些查找、遍历当前Widget树的一些方法。每一个widget都有一个自己的context对象。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span><span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> main()=&gt; runApp(StatelessApp());</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatelessApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span></span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="comment">///<span class="language-markdown">在build方法中通过嵌套其它Widget来构建UI，在构建过程中会递归的构建其嵌套的Widget</span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">  </span><br><span class="line">Widget build(BuildContext context)&#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//嵌套 MaterialApp：封装了应用程序实现Material Design所需要的一些widget</span></span><br><span class="line">    </span><br><span class="line">returnMaterialApp(title:<span class="string">&quot;Widget演示&quot;</span>,<span class="comment">//标题,显示在recent时候的标题</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//主页面</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//Scaffold : Material Design布局结构的基本实现。</span></span><br><span class="line">     home:Scaffold(</span><br><span class="line">          <span class="comment">//ToolBar/ActionBar</span></span><br><span class="line">          appBar:AppBar(title:Text(<span class="string">&quot;Widget&quot;</span>)),</span><br><span class="line">          body:Text(<span class="string">&quot;Hello,Flutter!&quot;</span>),</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Material Design:</p>
<p>一种设计语言，Material Design 于2014年的 Google I&#x2F;O 首次亮相，是谷歌推出的全新的设计语言。说白了，就是一种设计风格。</p>
<h3 id="StatefulWidget"><a href="#StatefulWidget" class="headerlink" title="StatefulWidget"></a>StatefulWidget</h3><p>StatefulWidget是动态的，添加了一个新的接口 createState()用于创建和Stateful widget相关的状态 State，它在Stateful widget的生命周期中可能会被多次调用。</p>
<p>当State被改变时，可以手动调用其 setState()方法通知Flutter framework状态发生改变，Flutter framework在收到消息后，会重新调用其 build方法重新构建widget树，从而达到更新UI的目的。<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607062474138.png" alt="Alt text"></p>
<h4 id="State生命周期"><a href="#State生命周期" class="headerlink" title="State生命周期"></a>State生命周期</h4><p>State的生命周期为:<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607062490701.png" alt="Alt text"><br>State类除了 build之外还提供了很多方法能够让我们重写，这些方法会在不同的状态下由Flutter调起执行，所以这些方法我们就称之为生命周期方法。在这里我们用statefulwidget点击按钮后移除子statefulwidget。<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607062534058.png" alt="Alt text"><br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607062617019.png" alt="Alt text"><br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607062622020.png" alt="Alt text"><br>执行的输出结果显示为:</p>
<p>运行到显示<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607062637921.png" alt="Alt text"><br>点击按钮会移除Child<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607062653239.png" alt="Alt text"><br>####文本显示<br>Text</p>
<p>Text是展示单一格式的文本Widget(Android TextView)。<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607062705581.png" alt="Alt text"><br>在使用 Text显示文字时候，可能需要对文字设置各种不同的样式，类似Android的 android:textColor&#x2F;Size等</p>
<p>在Flutter中也拥有类似的属性<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607062769502.png" alt="Alt text"><br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607062776762.png" alt="Alt text"><br>RichText<br>如果需要显示更为丰富样式的文本(比如一段文本中文字不同颜色),可以使用 RichText或者 Text.rich<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607062807761.png" alt="Alt text"><br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607062811254.png" alt="Alt text"><br>DefaultTextStyle<br>在widget树中，文本的样式默认是可以被继承的，因此，如果在widget树的某一个节点处设置一个默认的文本样式，那么该节点的子树中所有文本都会默认使用这个样式。相当于在Android中定义 Theme<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607062846372.png" alt="Alt text"><br>FlutterLogo<br>这个Widget用于显示Flutter的logo……</p>
<p><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607062874347.png" alt="Alt text"><br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607062900073.png" alt="Alt text"><br>显示图片的 Widget。图片常用的格式主要有bmp,jpg,png,gif,webp等，Android中并不是天生支持gif和webp动图，但是这一特性在flutter中被很好的支持了。<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607062926409.png" alt="Alt text"><br>Iamge.asset<br>在工程目录下创建目录，如：assets，将图片放入此目录。打开项目根目录：pubspec.yaml<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607062961275.png" alt="Alt text"><br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607062966496.png" alt="Alt text"><br>Image.file<br>在sd卡中放入一张图片。然后利用path_provider库获取sd卡根目录(Dart库版本可以在：<a target="_blank" rel="noopener" href="https://pub.dartlang.org/packages%E6%9F%A5%E8%AF%A2)%E3%80%82">https://pub.dartlang.org/packages查询)。</a></p>
<p><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607062984579.png" alt="Alt text"><br>注意权限<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607062998086.png" alt="Alt text"><br>Image.network<br>直接给网络地址即可。</p>
<p>Flutter 1.0，加载https时候经常出现证书错误。必须断开AS打开app<br>Image.memory<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607063022460.png" alt="Alt text"><br>CircleAvatar<br>主要用来显示用户的头像，任何图片都会被剪切为圆形。<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607063054861.png" alt="Alt text"><br>FadeInImage<br>当使用默认 Image widget显示图片时，您可能会注意到它们在加载完成后会直接显示到屏幕上。这可能会让用户产生视觉突兀。如果最初显示一个占位符，然后在图像加载完显示时淡入，我们可以使用 FadeInImage来达到这个目的！<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607063085973.png" alt="Alt text"></p>
<h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><p>Material widget库中提供了多种按钮Widget如RaisedButton、FlatButton、OutlineButton等，它们都是直接或间接对RawMaterialButton的包装定制，所以他们大多数属性都和 RawMaterialButton一样。所有Material 库中的按钮都有如下相同点：</p>
<p>按下时都会有“水波动画”。<br>有一个 onPressed属性来设置点击回调，当按钮按下时会执行该回调，如果不提供该回调则按钮会处于禁用状态，禁用状态不响应用户点击。<br>RaisedButton</p>
<p>“漂浮”按钮，它默认带有阴影和灰色背景<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607063143161.png" alt="Alt text"><br>FlatButton<br>扁平按钮，默认背景透明并不带阴影</p>
<p><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607063163010.png" alt="Alt text"></p>
<p>OutlineButton<br>默认有一个边框，不带阴影且背景透明。</p>
<p><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607063167937.png" alt="Alt text"></p>
<p>IconButton<br>可点击的Icon</p>
<p><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607063174111.png" alt="Alt text"></p>
<p>按钮外观可以通过其属性来定义，不同按钮属性大同小异<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607063186127.png" alt="Alt text"></p>
<p>而 RaisedButton，默认配置有阴影，因此在配置 RaisedButton 时，拥有一系列 elevation 属性的配置<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607063211583.png" alt="Alt text"></p>
<h3 id="输入框"><a href="#输入框" class="headerlink" title="输入框"></a>输入框</h3><p><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607063227273.png" alt="Alt text"><br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607063233115.png" alt="Alt text"><br>这个效果非常的“系统”，我们可能大多数情况下需要将下划线更换为矩形边框，这时候可能就需要组合widget来完成:<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607063248973.png" alt="Alt text"><br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607063253027.png" alt="Alt text"></p>
<h3 id="焦点控制"><a href="#焦点控制" class="headerlink" title="焦点控制"></a>焦点控制</h3><p>FocusNode: 与Widget绑定，代表了这个Widget的焦点</p>
<p>FocusScope: 焦点控制范围</p>
<p>FocusScopeNode：控制焦点<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607063288860.png" alt="Alt text"><br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607063293312.png" alt="Alt text"></p>
<h3 id="获取输入内容"><a href="#获取输入内容" class="headerlink" title="获取输入内容"></a>获取输入内容</h3><p>获取输入内容有两种方式：</p>
<p>定义两个变量，用于保存用户名和密码，然后在onChange触发时，各自保存一下输入内容。<br>通过controller直接获取。<br>onChange获得输入内容:<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607063321362.png" alt="Alt text"></p>
<p>controller获取:</p>
<p>定义一个controller：</p>
<p><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607063347457.png" alt="Alt text"></p>
<p>然后设置输入框controller：</p>
<p><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607063352970.png" alt="Alt text"></p>
<h4 id="通过controller获取输入框内容"><a href="#通过controller获取输入框内容" class="headerlink" title="通过controller获取输入框内容"></a>通过controller获取输入框内容</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debugPrint(_unameController.text)</span><br></pre></td></tr></table></figure>
<h3 id="TextFormField"><a href="#TextFormField" class="headerlink" title="TextFormField"></a>TextFormField</h3><p>TextFormField比 TextField多了一些属性，其中 validator用于设置验证回调。在单独使用时与 TextField没有太大的区别。当结合 From，利用 From可以对输入框进行分组，然后进行一些统一操作(验证)<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607063388194.png" alt="Alt text"></p>
<p><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607063394452.png" alt="Alt text"></p>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><ul>
<li>线性布局Row和Column</li>
<li>弹性布局Flex</li>
<li>流式布局Wrap、Flow</li>
<li>层叠布局Stack、Positioned</li>
</ul>
<p>线性布局Row和Column<br>线性布局其实是指沿水平或垂直方向排布子Widget，Flutter中通过Row来实现水平方向的子Widegt布局，通过Column来实现垂直方向的子Widget布局。他们都继承Flex，所以它们有很多相似的属性。<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607089530581.png" alt="Alt text"><br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607089534833.png" alt="Alt text"><br>在前端的Flex布局中，默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。与Flutter中MainAxisAlignment和CrossAxisAlignment类似，分别代表主轴对齐和纵轴对齐。<br>源码属性解读</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Row(&#123;</span><br><span class="line">  .....</span><br><span class="line">  MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,</span><br><span class="line">  MainAxisSize mainAxisSize = MainAxisSize.max,</span><br><span class="line">  CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,</span><br><span class="line">  TextDirection textDirection,</span><br><span class="line">  VerticalDirection verticalDirection = VerticalDirection.down,</span><br><span class="line">  TextBaseline textBaseline,</span><br><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">Column(&#123;</span><br><span class="line">  .....</span><br><span class="line">  MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,</span><br><span class="line">  MainAxisSize mainAxisSize = MainAxisSize.max,</span><br><span class="line">  CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,</span><br><span class="line">  TextDirection textDirection,</span><br><span class="line">  VerticalDirection verticalDirection = VerticalDirection.down,</span><br><span class="line">  TextBaseline textBaseline,</span><br><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>
<p>textDirection：表示水平方向子widget的布局顺序(是从左往右还是从右往左)，默认为系统当前Locale环境的文本方向(如中文、英语都是从左往右，而阿拉伯语是从右往左)。<br>主轴方向: Row即为水平方向，Column为垂直方向<br>mainAxisAlignment 主轴方向，对child起作用</p>
<p>center：将children放置在主轴的中心<br>start：将children放置在主轴的起点<br>end：将children放置在主轴的末尾<br>spaceAround：将主轴方向上的空白区域均分，使children之间的空白区域相等，但是首尾child的靠边间距为空白区域为1&#x2F;2<br>spaceBetween：将主轴方向上的空白区域均分，使children之间的空白区域相等，首尾child靠边没有间隙<br>spaceEvenly：将主轴方向上的空白区域均分，使得children之间的空白区域相等，包括首尾child</p>
<p>mainAxisSize max表示尽可能占多的控件，min会导致控件聚拢在一起<br>crossAxisAlignment 交叉轴方向，对child起作用</p>
<p>baseline：使children baseline对齐<br>center：children在交叉轴上居中展示<br>end：children在交叉轴上末尾展示<br>start：children在交叉轴上起点处展示<br>stretch：让children填满交叉轴方向</p>
<p>verticalDirection ，child的放置顺序</p>
<p>VerticalDirection.down，在Row中就是从左边到右边，Column代表从顶部到底部<br>VerticalDirection.up，相反<br>Row<br>示例代码</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ListView(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Row(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.start,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Text(<span class="string">&quot;我是Row的子控件  &quot;</span>),</span><br><span class="line">            Text(<span class="string">&quot;MainAxisAlignment.start&quot;</span>)</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">        Row(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Text(<span class="string">&quot;我是Row的子控件  &quot;</span>),</span><br><span class="line">            Text(<span class="string">&quot;MainAxisAlignment.center&quot;</span>)</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">        Row(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.end,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Text(<span class="string">&quot;我是Row的子控件  &quot;</span>),</span><br><span class="line">            Text(<span class="string">&quot;MainAxisAlignment.end&quot;</span>)</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">        Row(</span><br><span class="line">          crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">          verticalDirection: VerticalDirection.up,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Text(<span class="string">&quot; Hello World &quot;</span>, style: TextStyle(fontSize: <span class="number">30.0</span>),),</span><br><span class="line">            Text(<span class="string">&quot; I am Jack &quot;</span>),</span><br><span class="line">          ],</span><br><span class="line">      ],</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607089597948.png" alt="Alt text"><br>前3个Row很简单，只是设置了主轴方向的对齐方式；第四个Row测试的是纵轴的对齐方式，由于两个子Text字体不一样，所以其高度也不同，我们指定了verticalDirection值为VerticalDirection.up，即从低向顶排列，而此时crossAxisAlignment值为CrossAxisAlignment.start表示底对齐。大家可以参考上面Row和Column的主侧轴的示意图，看看布局是不是正确的，还有很多种情况就不一一列举了。</p>
<h3 id="Column"><a href="#Column" class="headerlink" title="Column"></a>Column</h3><p>Column组件即垂直布局控件，能够将子组件垂直排列。其实Column组件里边的大部分属性都与Row组件一样。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="language-markdown">/<span class="strong">**</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* 垂直布局</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span>/</span></span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColumnWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Column(</span><br><span class="line">      mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">      crossAxisAlignment: CrossAxisAlignment.center,</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        RaisedButton(onPressed: () &#123;&#125;, color: Colors.red, child: Text(<span class="string">&#x27;红色按钮&#x27;</span>)),</span><br><span class="line">        RaisedButton(</span><br><span class="line">          onPressed: () &#123;&#125;,</span><br><span class="line">          color: Colors.orange,</span><br><span class="line">          child: Text(<span class="string">&#x27;黄色大按钮&#x27;</span>),</span><br><span class="line">        ),</span><br><span class="line">        RaisedButton(onPressed: () &#123;&#125;, color: Colors.pink, child: Text(<span class="string">&#x27;粉色按钮&#x27;</span>))</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607089619767.png" alt="Alt text"></p>
<h3 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h3><p>由于篇幅有限，常见现象和解决办法：</p>
<p>1.如果Row里面嵌套Row，或者Column里面再嵌套Column，那么只有对最外面的Row或Column会占用尽可能大的空间，里面Row或Column所占用的空间为实际大小，如果要让里面的Colum或Row占满外部Colum或Row，可以使用Expanded widget<br>2.如果使用Column发现超范围，可用SingleChildScrollView包裹，scrollDirection属性设置滑动方向<br>3.使用Column嵌套ListView&#x2F;GridView的时候，会报异常信息【Viewports expand in the scrolling direction to fill their container…】，这种情况flutter已给出解决办法，将ListView&#x2F;GridView的 shrinkWrap属性设为true<br>4.有的时候修改Row&#x2F;Column的verticalDirection会得到很好的效果，比如需要页面在底部需要几个按键，也可以用Stack来布局，但是相对麻烦，而且有时还需要知道控件的大小，没有verticalDirection方便。</p>
<h4 id="弹性布局"><a href="#弹性布局" class="headerlink" title="弹性布局"></a>弹性布局</h4><p>弹性布局允许子widget按照一定比例来分配父容器空间，弹性布局的概念在其UI系统中也都存在，如H5中的弹性盒子布局，Android中的FlexboxLayout。Flutter中的弹性布局主要通过Flex和Expanded来配合实现。</p>
<h4 id="Flex"><a href="#Flex" class="headerlink" title="Flex"></a>Flex</h4><p>Flex可以沿着水平或垂直方向排列子widget，如果你知道主轴方向，使用Row或Column会方便一些，因为Row和Column都继承自Flex，参数基本相同，所以能使用Flex的地方一定可以使用Row或Column。Flex本身功能是很强大的，它也可以和Expanded配合实现弹性布局，接下来我们只讨论Flex和弹性布局相关的属性(其它属性已经在介绍Row和Column时介绍过了)。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Flex(&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.direction, <span class="comment">//弹性布局的方向, Row默认为水平方向，Column默认为垂直方向</span></span><br><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>Flex继承自MultiChildRenderObjectWidget，对应的RenderObject为RenderFlex，RenderFlex中实现了其布局算法。</p>
<h4 id="Expanded"><a href="#Expanded" class="headerlink" title="Expanded"></a>Expanded</h4><p>可以按比例“扩伸”Row、Column和Flex子widget所占用的空间。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Expanded(&#123;</span><br><span class="line">  <span class="built_in">int</span> flex = <span class="number">1</span>, </span><br><span class="line">  <span class="meta">@required</span> Widget child,</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>flex为弹性系数，如果为0或null，则child是没有弹性的，即不会被扩伸占用的空间。如果大于0，所有的Expanded按照其flex的比例来分割主轴的全部空闲空间。下面我们看一个例子：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_home</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;StatefulWidget&gt; createState() &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement createState</span></span><br><span class="line">    <span class="keyword">return</span> _homeState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_homeState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">_home</span>&gt;</span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Scaffold(</span><br><span class="line">      appBar: <span class="keyword">new</span> AppBar(</span><br><span class="line">        title: <span class="keyword">new</span> Text(<span class="string">&quot;title&quot;</span>),</span><br><span class="line">        centerTitle: <span class="keyword">true</span>,</span><br><span class="line">      ),</span><br><span class="line">      body: _body(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Widget _body()&#123;</span><br><span class="line">  <span class="keyword">return</span> Column(</span><br><span class="line">    children: &lt;Widget&gt;[</span><br><span class="line">      <span class="comment">//Flex的两个子widget按1：2来占据水平空间</span></span><br><span class="line">      Flex(</span><br><span class="line">        direction: Axis.horizontal,</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Expanded(</span><br><span class="line">            flex: <span class="number">1</span>,</span><br><span class="line">            child: Container(</span><br><span class="line">              height: <span class="number">80.0</span>,</span><br><span class="line">              color: Colors.red,</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">          Expanded(</span><br><span class="line">            flex: <span class="number">2</span>,</span><br><span class="line">            child: Container(</span><br><span class="line">              height: <span class="number">80.0</span>,</span><br><span class="line">              color: Colors.green,</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">      Padding(</span><br><span class="line">        padding: <span class="keyword">const</span> EdgeInsets.only(top: <span class="number">20.0</span>),</span><br><span class="line">        child: SizedBox(</span><br><span class="line">          height: <span class="number">100.0</span>,</span><br><span class="line">          <span class="comment">//Flex的三个子widget，在垂直方向按2：1：1来占用100像素的空间</span></span><br><span class="line">          child: Flex(</span><br><span class="line">            direction: Axis.vertical,</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              Expanded(</span><br><span class="line">                flex: <span class="number">2</span>,</span><br><span class="line">                child: Container(</span><br><span class="line">                  color: Colors.red,</span><br><span class="line">                ),</span><br><span class="line">              ),</span><br><span class="line">              Spacer(<span class="comment">//Spacer的功能是占用指定比例的空间，实际上它只是Expanded的一个包装</span></span><br><span class="line">                flex: <span class="number">1</span>,</span><br><span class="line">              ),</span><br><span class="line">              Expanded(</span><br><span class="line">                flex: <span class="number">1</span>,</span><br><span class="line">                child: Container(</span><br><span class="line">                  color: Colors.green,</span><br><span class="line">                ),</span><br><span class="line">              ),</span><br><span class="line">            ],</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    ],</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607089700690.png" alt="Alt text"></p>
<h3 id="流式布局"><a href="#流式布局" class="headerlink" title="流式布局"></a>流式布局</h3><p>流式布局（Liquid）的特点（也叫”Fluid”) 是页面元素的宽度按照屏幕分辨率进行适配调整，但整体布局不变。栅栏系统（网格系统），用户标签等。在Flutter中主要有Wrap和Flow两种Widget实现。</p>
<h4 id="Wrap"><a href="#Wrap" class="headerlink" title="Wrap"></a>Wrap</h4><p>在介绍Row和Colum时，如果子widget超出屏幕范围，则会报溢出错误，在Flutter中通过Wrap和Flow来支持流式布局，溢出部分则会自动折行。</p>
<p>源码属性解读</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Wrap(&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">this</span>.direction = Axis.horizontal,</span><br><span class="line">  <span class="keyword">this</span>.alignment = WrapAlignment.start,</span><br><span class="line">  <span class="keyword">this</span>.spacing = <span class="number">0.0</span>,</span><br><span class="line">  <span class="keyword">this</span>.runAlignment = WrapAlignment.start,</span><br><span class="line">  <span class="keyword">this</span>.runSpacing = <span class="number">0.0</span>,</span><br><span class="line">  <span class="keyword">this</span>.crossAxisAlignment = WrapCrossAlignment.start,</span><br><span class="line">  <span class="keyword">this</span>.textDirection,</span><br><span class="line">  <span class="keyword">this</span>.verticalDirection = VerticalDirection.down,</span><br><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上述有很多属性和Row的相同，其意义其实也是相同的，这里我就不一一介绍了，主要介绍下不同的属性：</p>
<ul>
<li>spacing：主轴方向子widget的间距</li>
<li>runSpacing：纵轴方向的间距</li>
<li>runAlignment：纵轴方向的对齐方式<br>示例代码<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Wrap(</span><br><span class="line">   spacing: <span class="number">10.0</span>,</span><br><span class="line">   direction: Axis.horizontal,</span><br><span class="line">   alignment: WrapAlignment.start,</span><br><span class="line">   children: &lt;Widget&gt;[</span><br><span class="line">     _card(<span class="string">&#x27;关注&#x27;</span>),</span><br><span class="line">     _card(<span class="string">&#x27;推荐&#x27;</span>),</span><br><span class="line">     _card(<span class="string">&#x27;新时代&#x27;</span>),</span><br><span class="line">     _card(<span class="string">&#x27;小视频&#x27;</span>),</span><br><span class="line">     _card(<span class="string">&#x27;党媒推荐&#x27;</span>),</span><br><span class="line">     _card(<span class="string">&#x27;中国新唱将&#x27;</span>),</span><br><span class="line">     _card(<span class="string">&#x27;历史&#x27;</span>),</span><br><span class="line">     _card(<span class="string">&#x27;视频&#x27;</span>),</span><br><span class="line">     _card(<span class="string">&#x27;游戏&#x27;</span>),</span><br><span class="line">     _card(<span class="string">&#x27;头条号&#x27;</span>),</span><br><span class="line">     _card(<span class="string">&#x27;数码&#x27;</span>),</span><br><span class="line">   ],</span><br><span class="line"> )</span><br><span class="line"> </span><br><span class="line">  Widget _card(<span class="built_in">String</span> title) &#123;</span><br><span class="line">    <span class="keyword">return</span> Card(child: Text(title),);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607089776798.png" alt="Alt text"><br>小结</li>
<li>使用Wrap可以很轻松的实现流式布局效果</li>
<li>Wrap支持设置流式布局是纵向显示或者是横向显示</li>
<li>可以使用alignment属性来控制widgets的布局方式</li>
</ul>
<h4 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h4><p>我们一般很少会使用Flow，因为其过于复杂，需要自己实现子widget的位置转换，在很多场景下首先要考虑的是Wrap是否满足需求。Flow主要用于一些需要自定义布局策略或性能要求较高(如动画中)的场景。Flow有如下优点：</p>
<ul>
<li>性能好；Flow是一个对child尺寸以及位置调整非常高效的控件，Flow用转换矩阵（transformation matrices）在对child进行位置调整的时候进行了优化：在Flow定位过后，如果child的尺寸或者位置发生了变化，在FlowDelegate中的paintChildren()方法中调用context.paintChild 进行重绘，而context.paintChild在重绘时使用了转换矩阵（transformation matrices），并没有实际调整Widget位置。</li>
<li>灵活；由于我们需要自己实现FlowDelegate的paintChildren()方法，所以我们需要自己计算每一个widget的位置，因此，可以自定义布局策略。 缺点：<br>使用复杂.</li>
<li>不能自适应子widget大小，必须通过指定父容器大小或实现TestFlowDelegate的getSize返回固定大小。</li>
</ul>
<p>示例代码<br>我们对六个色块进行自定义流式布局：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Flow(</span><br><span class="line">  delegate: TestFlowDelegate(margin: EdgeInsets.all(<span class="number">10.0</span>)),</span><br><span class="line">  children: &lt;Widget&gt;[</span><br><span class="line">    <span class="keyword">new</span> Container(width: <span class="number">80.0</span>, height:<span class="number">80.0</span>, color: Colors.red,),</span><br><span class="line">    <span class="keyword">new</span> Container(width: <span class="number">80.0</span>, height:<span class="number">80.0</span>, color: Colors.green,),</span><br><span class="line">    <span class="keyword">new</span> Container(width: <span class="number">80.0</span>, height:<span class="number">80.0</span>, color: Colors.blue,),</span><br><span class="line">    <span class="keyword">new</span> Container(width: <span class="number">80.0</span>, height:<span class="number">80.0</span>,  color: Colors.yellow,),</span><br><span class="line">    <span class="keyword">new</span> Container(width: <span class="number">80.0</span>, height:<span class="number">80.0</span>, color: Colors.brown,),</span><br><span class="line">    <span class="keyword">new</span> Container(width: <span class="number">80.0</span>, height:<span class="number">80.0</span>,  color: Colors.purple,),</span><br><span class="line">  ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>实现TestFlowDelegate:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestFlowDelegate</span> <span class="keyword">extends</span> <span class="title">FlowDelegate</span> </span>&#123;</span><br><span class="line">  EdgeInsets margin = EdgeInsets.zero;</span><br><span class="line">  TestFlowDelegate(&#123;<span class="keyword">this</span>.margin&#125;);</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> paintChildren(FlowPaintingContext context) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = margin.left;</span><br><span class="line">    <span class="keyword">var</span> y = margin.top;</span><br><span class="line">    <span class="comment">//计算每一个子widget的位置  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; context.childCount; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> w = context.getChildSize(i).width + x + margin.right;</span><br><span class="line">      <span class="keyword">if</span> (w &lt; context.size.width) &#123;</span><br><span class="line">        context.paintChild(i,</span><br><span class="line">            transform: <span class="keyword">new</span> Matrix4.translationValues(</span><br><span class="line">                x, y, <span class="number">0.0</span>));</span><br><span class="line">        x = w + margin.left;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x = margin.left;</span><br><span class="line">        y += context.getChildSize(i).height + margin.top + margin.bottom;</span><br><span class="line">        <span class="comment">//绘制子widget(有优化)  </span></span><br><span class="line">        context.paintChild(i,</span><br><span class="line">            transform: <span class="keyword">new</span> Matrix4.translationValues(</span><br><span class="line">                x, y, <span class="number">0.0</span>));</span><br><span class="line">        x += context.getChildSize(i).width + margin.left + margin.right;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  getSize(BoxConstraints constraints)&#123;</span><br><span class="line">    <span class="comment">//指定Flow的大小  </span></span><br><span class="line">    <span class="keyword">return</span> Size(<span class="built_in">double</span>.infinity,<span class="number">200.0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> shouldRepaint(FlowDelegate oldDelegate) &#123;</span><br><span class="line">    <span class="keyword">return</span> oldDelegate != <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607089834028.png" alt="Alt text"><br>可以看到我们主要的任务就是实现paintChildren，它的主要任务是确定每个子widget位置。由于Flow不能自适应子widget的大小，我们通过在getSize返回一个固定大小来指定Flow的大小，实现起来还是比较麻烦的。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>参数简单，不过需要自己定义delegate</li>
<li>delegate一般是为了实现child的绘制，就是位置的摆放，不同情况需要定义不同的delegate</li>
<li>不同的delegate一般会提供实现的几个方法:<blockquote>
<p>getConstraintsForChild: 设置每个child的布局约束条件，会覆盖已有的方式<br>getSize：设置控件的尺寸<br>shouldRelayout：表示是否需要重新布局</p>
</blockquote>
</li>
<li>尽可能的用Wrap，毕竟简单</li>
</ul>
<p>###层叠布局<br>层叠布局和Web中的绝对定位、Android中的Frame布局是相似的，子widget可以根据到父容器四个角的位置来确定本身的位置。绝对定位允许子widget堆叠（按照代码中声明的顺序）。Flutter中使用Stack和Positioned来实现绝对定位，Stack允许子widget堆叠，而Positioned可以给子widget定位（根据Stack的四个角）。</p>
<h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stack(&#123;</span><br><span class="line">  <span class="keyword">this</span>.alignment = AlignmentDirectional.topStart,</span><br><span class="line">  <span class="keyword">this</span>.textDirection,</span><br><span class="line">  <span class="keyword">this</span>.fit = StackFit.loose,</span><br><span class="line">  <span class="keyword">this</span>.overflow = Overflow.clip,</span><br><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>alignment：此参数决定如何去对齐没有定位（没有使用Positioned）或部分定位的子widget。所谓部分定位，在这里特指没有在某一个轴上定位：left、right为横轴，top、bottom为纵轴，只要包含某个轴上的一个定位属性就算在该轴上有定位。</li>
<li>textDirection：和Row、Wrap的textDirection功能一样，都用于决定alignment对齐的参考系即：textDirection的值为TextDirection.ltr，则alignment的start代表左，end代表右；textDirection的值为TextDirection.rtl，则alignment的start代表右，end代表左。</li>
<li>fit：此参数用于决定没有定位的子widget如何去适应Stack的大小。StackFit.loose表示使用子widget的大小，StackFit.expand表示扩伸到Stack的大小。</li>
<li>overflow：此属性决定如何显示超出Stack显示空间的子widget，值为Overflow.clip时，超出部分会被剪裁（隐藏），值为Overflow.visible 时则不会。</li>
</ul>
<p>下面是我用Stack实现的一个简易的loading</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Loading</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">ProgressIndicator的padding，决定loading的大小</span></span></span><br><span class="line">  <span class="keyword">final</span> EdgeInsets padding = EdgeInsets.all(<span class="number">30.0</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/// <span class="language-markdown">文字顶部距菊花的底部的距离</span></span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> margin = <span class="number">10.0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/// <span class="language-markdown">圆角</span></span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> cornerRadius = <span class="number">10.0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">final</span> Widget _child;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> _isLoading;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> opacity;</span><br><span class="line">  <span class="keyword">final</span> Color color;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> text;</span><br><span class="line"> </span><br><span class="line">  Loading(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> child,</span><br><span class="line">    <span class="meta">@required</span> isLoading,</span><br><span class="line">    <span class="keyword">this</span>.text,</span><br><span class="line">    <span class="keyword">this</span>.opacity = <span class="number">0.3</span>,</span><br><span class="line">    <span class="keyword">this</span>.color = Colors.grey,</span><br><span class="line">  &#125;)  : <span class="keyword">assert</span>(child != <span class="keyword">null</span>),</span><br><span class="line">        <span class="keyword">assert</span>(isLoading != <span class="keyword">null</span>),</span><br><span class="line">        _child = child,</span><br><span class="line">        _isLoading = isLoading,</span><br><span class="line">        <span class="keyword">super</span>(key: key);</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="built_in">List</span>&lt;Widget&gt; widgetList = <span class="built_in">List</span>&lt;Widget&gt;();</span><br><span class="line">    widgetList.add(_child);</span><br><span class="line">    <span class="keyword">if</span> (_isLoading) &#123;</span><br><span class="line">      <span class="keyword">final</span> loading = [</span><br><span class="line">        Opacity(</span><br><span class="line">          opacity: opacity,</span><br><span class="line">          child: ModalBarrier(dismissible: <span class="keyword">false</span>, color: color),</span><br><span class="line">        ),</span><br><span class="line">        _buildProgressIndicator()</span><br><span class="line">      ];</span><br><span class="line">      widgetList.addAll(loading);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Stack(</span><br><span class="line">      children: widgetList,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  Widget _buildProgressIndicator() &#123;</span><br><span class="line">    <span class="keyword">return</span> Center(</span><br><span class="line">      child: Container(</span><br><span class="line">        padding: padding,</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisSize: MainAxisSize.min,</span><br><span class="line">          crossAxisAlignment: CrossAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            CupertinoActivityIndicator(),</span><br><span class="line">            Padding(</span><br><span class="line">                padding: EdgeInsets.only(top: margin),</span><br><span class="line">                child: Text(text ?? <span class="string">&#x27;加载中...&#x27;</span>)),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">        decoration: BoxDecoration(</span><br><span class="line">            borderRadius: BorderRadius.all(Radius.circular(cornerRadius)),</span><br><span class="line">            color: Colors.white),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607089910760.png" alt="Alt text"><br>本控件使用Stack封装，你传入的主视图在最下面一层，背景层在中间，最上面一层为菊花和文字loading，用isLoading控制显示</p>
<h4 id="Positioned"><a href="#Positioned" class="headerlink" title="Positioned"></a>Positioned</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Positioned(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  <span class="keyword">this</span>.left, </span><br><span class="line">  <span class="keyword">this</span>.top,</span><br><span class="line">  <span class="keyword">this</span>.right,</span><br><span class="line">  <span class="keyword">this</span>.bottom,</span><br><span class="line">  <span class="keyword">this</span>.width,</span><br><span class="line">  <span class="keyword">this</span>.height,</span><br><span class="line">  <span class="meta">@required</span> Widget child,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>left、top 、right、 bottom分别代表离Stack左、上、右、底四边的距离。width和height用于指定定位元素的宽度和高度，注意，此处的width、height 和其它地方的意义稍微有点区别，此处用于配合left、top 、right、 bottom来定位widget，举个例子，在水平方向时，你只能指定left、right、width三个属性中的两个，如指定left和width后，right会自动算出(left+width)，如果同时指定三个属性则会报错，垂直方向同理。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过ConstrainedBox来确保Stack占满屏幕</span></span><br><span class="line">ConstrainedBox(</span><br><span class="line">  constraints: BoxConstraints.expand(),</span><br><span class="line">  child: Stack(</span><br><span class="line">    alignment:Alignment.center , <span class="comment">//指定未定位或部分定位widget的对齐方式</span></span><br><span class="line">    children: &lt;Widget&gt;[</span><br><span class="line">      Container(child: Text(<span class="string">&quot;Hello world&quot;</span>,style: TextStyle(color: Colors.white)),</span><br><span class="line">        color: Colors.red,</span><br><span class="line">      ),</span><br><span class="line">      Positioned(</span><br><span class="line">        left: <span class="number">18.0</span>,</span><br><span class="line">        child: Text(<span class="string">&quot;I am Jack&quot;</span>),</span><br><span class="line">      ),</span><br><span class="line">      Positioned(</span><br><span class="line">        top: <span class="number">18.0</span>,</span><br><span class="line">        child: Text(<span class="string">&quot;Your friend&quot;</span>),</span><br><span class="line">      )        </span><br><span class="line">    ],</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607089941021.png" alt="Alt text"><br>由于第一个子widget Text(“Hello world”)没有指定定位，并且alignment值为Alignment.center，所以，它会居中显示。第二个子widget Text(“I am Jack”)只指定了水平方向的定位(left)，所以属于部分定位，即垂直方向上没有定位，那么它在垂直方向对齐方式则会按照alignment指定的对齐方式对齐，即垂直方向居中。对于第三个子widget Text(“Your friend”)，和第二个Text原理一样，只不过是水平方向没有定位，则水平方向居中。</p>
<h2 id="自定义绘制"><a href="#自定义绘制" class="headerlink" title="自定义绘制"></a>自定义绘制</h2><p>有两个类做这件事情:</p>
<ul>
<li><p>CustomPaint :会在绘制阶段提供一个 Canvas 画布</p>
</li>
<li><p>CustomPainter : 具体的画笔, 可配置画笔的颜色,路径等</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CustomPaint(</span><br><span class="line">  painter: Sky(),</span><br><span class="line">  child: Center(</span><br><span class="line">    child: Text(</span><br><span class="line">      <span class="string">&#x27;Once upon a time...&#x27;</span>,</span><br><span class="line">      style: <span class="keyword">const</span> TextStyle(</span><br><span class="line">        fontSize: <span class="number">40.0</span>,</span><br><span class="line">        fontWeight: FontWeight.w900,</span><br><span class="line">        color: Color(<span class="number">0xFFFFFFFF</span>),</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">)</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>当在绘制阶段时, CustomPaint 首先会调用 painter 在画布上进行绘制, 然后再绘制它的 child 控件, child 绘制完成之后会调用 foregroundPainter 进行绘制. 画布的坐标系和 CustomPaint 的坐标系匹配. CustomPaint 有个 Size 属性标识将绘制多大的区域, 绘制时这个 Size 属性将会传递到 CustomPainter 的 paint 方法中, 具体的绘制就在paint 方法中进行, void paint(Canvas canvas, Size size); 的方法签名中的两个参数:</p>
</li>
<li><p>canvas: 用于绘制的画布, 注意: 该画布是应用所有控件都在使用的, 所以通过这个画布其实是可以绘制充满屏幕的内容的</p>
</li>
<li><p>size: 表示应该绘制的区域大小, 每次绘制都应该限制在这个区域内, 否则可能会覆盖了其他控件的绘制结果</p>
</li>
</ul>
<h3 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h3><p>绘制一个矩形和圆角:<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607090024896.png" alt="Alt text"></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> CustomPaint(</span><br><span class="line">    painter: ColorPainter(),</span><br><span class="line">    size: Size(<span class="number">300</span>, <span class="number">200</span>),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">ColorPainter</span> <span class="keyword">extends</span> <span class="title">CustomPainter</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">final</span> red = Color.fromRGBO(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">final</span> blue = Color.fromRGBO(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> paint(Canvas canvas, Size size) &#123;  </span><br><span class="line">    <span class="keyword">final</span> paint = Paint();</span><br><span class="line">    <span class="keyword">final</span> rect = Rect.fromLTRB(<span class="number">0.0</span>, <span class="number">0.0</span>, size.width, size.height);</span><br><span class="line">    <span class="comment">// 注意这一句</span></span><br><span class="line">    canvas.clipRect(rect);</span><br><span class="line">    paint.color = blue;</span><br><span class="line">    canvas.drawRect(rect, paint);</span><br><span class="line">    paint.color = red;</span><br><span class="line">    canvas.drawCircle(Offset.zero, size.height, paint);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> shouldRepaint(CustomPainter oldDelegate) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>定义了绘制区域大小, 为 CustomPaint 中的 size 属性</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> rect = Rect.fromLTRB(<span class="number">0.0</span>, <span class="number">0.0</span>, size.width, size.height);</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>绘制矩形区域</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canvas.drawRect(rect, paint);</span><br></pre></td></tr></table></figure>
<p>绘制圆形</p>
<ul>
<li>圆心偏移量为: 0, 也就是 CustomPaint 的原点</li>
<li>半径为区域的高度</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">canvas.drawCircle(Offset.zero, size.height, paint);</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>最需要注意的地方我觉得是 canvas.clipRect(rect); 这句. 这句表示只绘制给定的区域中的内容. 如果不写这句, 效果就是这样:<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607090081561.png" alt="Alt text"><br>其实这就是 Size 这个参数的重要性, 因为 Canvas 是被所有控件公有的, 如果我们绘制时不指定区域大小, 那在进行一些形状的绘制时就会出现超出区域的问题.</p>
<h2 id="使用-Flutter、Material-Theming-和官方-Material-Components（MDC）构建美观，灵活的用户界面"><a href="#使用-Flutter、Material-Theming-和官方-Material-Components（MDC）构建美观，灵活的用户界面" class="headerlink" title="使用 Flutter、Material Theming 和官方 Material Components（MDC）构建美观，灵活的用户界面"></a>使用 Flutter、Material Theming 和官方 Material Components（MDC）构建美观，灵活的用户界面</h2><p>在 Google I&#x2F;O 2018 上，Material 团队宣布对 Material Design 进行重要更新，其重点是通过系统地应用品牌特定设计，从而使移动应用程序从其他应用中脱颖而出。这就是 Material Theming 工具。以下研究显示了通过组合不同定制的 Material Components，来为“Shrine” —— 一个销售服装和家居用品的电子商务应用程序，创建一个品牌特定的设计。Flutter 简直是实现这种设计的完美框架！</p>
<p>我非常高兴能够欢迎 Flutter 加入官方的 Material Design 组件集合中，成为我们 Android、iOS 和 Web 产品完全成熟的伙伴。Flutter 灵活和适应性的 widget 非常适合 Material Theming，而 Flutter 实时 UI 迭代的能力改变了我们改进设计的方式。”</p>
<ul>
<li><p>Matías Duarte，Material Design 副总裁<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607090199183.png" alt="Alt text"><br>采用 Material Theming 和 Material Components 设计的 “Shrine 品牌特定” UI 元素<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607090209397.png" alt="Alt text"></p>
<h3 id="Material-Components-对-Flutter-的官方支持"><a href="#Material-Components-对-Flutter-的官方支持" class="headerlink" title="Material Components 对 Flutter 的官方支持"></a>Material Components 对 Flutter 的官方支持</h3><p>Flutter 的核心原则之一即是为创建富有表现力的灵活的移动 UI 提供一流的支持。为了这个目标，我们很高兴的宣布 Flutter 被采用为 Material 的最佳平台！Flutter 将包含到设计和工程讨论、文档、官方支持、Google Design 内容，以及 Android、iOS 和 Web 的教学中。Material 甚至创建了一个专门的 Flutter 工程团队来与 Flutter 的 Material 库工程师们携手合作。这种伙伴关系将使 Flutter 在 Material Design 持续发展并增加像 Material Theming 等功能时保证自身的更新。你可以在 material.io&#x2F;develop&#x2F;flu… 找到更多的相关信息。</p>
<h3 id="在-Flutter-中使用-Material-Theming-和-Material-Components"><a href="#在-Flutter-中使用-Material-Theming-和-Material-Components" class="headerlink" title="在 Flutter 中使用 Material Theming 和 Material Components"></a>在 Flutter 中使用 Material Theming 和 Material Components</h3><p>就在 I&#x2F;O 大会的时候，Flutter 的 Material Components 库便已经更新以支持 Material 新系统中的许多新功能、样式和组件。这些都在 Flutter beta 3 中提供并内置到 Flutter 框架中，从而无需额外的库！我们还在 Flutter Gallery 中添加了更多关于如何使用这些 widget 的示例。<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607090240278.png" alt="Alt text"><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/AndroidAlvin/article/details/103443033">了解更多</a></p>
<h2 id="交互、手势和动画"><a href="#交互、手势和动画" class="headerlink" title="交互、手势和动画"></a>交互、手势和动画</h2><p>为了获取按钮的点击事件，只需要设置 onPressed 参数就可以了：</p>
</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;  </span><br><span class="line"><span class="meta">@override</span>  </span><br><span class="line">Widget build(BuildContext context) &#123;    </span><br><span class="line"><span class="keyword">return</span> RaisedButton(      </span><br><span class="line">child: Text(<span class="string">&#x27;click&#x27;</span>),      </span><br><span class="line">onPressed: () =&gt; debugPrint(<span class="string">&#x27;clicked&#x27;</span>),    </span><br><span class="line">);  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟 button 不同，大多数的控件没有手势事件监听函数可以设置，为了监听这些控件上的手势事件，我们需要使用另一个控件——GestureDetector（没错，它也是一个控件）：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;  </span><br><span class="line"><span class="meta">@override</span>  </span><br><span class="line">Widget build(BuildContext context) &#123;    </span><br><span class="line"><span class="keyword">return</span> GestureDetector(      </span><br><span class="line">child: Text(<span class="string">&#x27;text&#x27;</span>),      </span><br><span class="line">onTap: () =&gt; debugPrint(<span class="string">&#x27;clicked&#x27;</span>),    </span><br><span class="line">);  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了上面代码使用到的 onTap，GestureDetector 还支持许多其他事件：</p>
<ul>
<li>onTapDown：按下</li>
<li>onTap：点击动作</li>
<li>onTapUp：抬起</li>
<li>onTapCancel：前面触发了 onTapDown，但并没有完成一个 onTap 动作</li>
<li>onDoubleTap：双击</li>
<li>onLongPress：长按</li>
<li>onScaleStart, onScaleUpdate, onScaleEnd：缩放</li>
<li>onVerticalDragDown, onVerticalDragStart, onVerticalDragUpdate, onVerticalDragEnd, onVerticalDragCancel, onVerticalDragUpdate：在竖直方向上移动</li>
<li>onHorizontalDragDown, onHorizontalDragStart, onHorizontalDragUpdate, onHorizontalDragEnd, onHorizontalDragCancel, onHorizontalDragUpdate：在水平方向上移动</li>
<li>onPanDown, onPanStart, onPanUpdate, onPanEnd, onPanCancel：拖曳（水平、竖直方向上移动）</li>
</ul>
<p>如果同时设置了 onVerticalXXX 和 onHorizontalXXX，在一个手势里，只有一个会触发（如果用户首先在水平方向移动，则整个过程只触发 onHorizontalUpdate；竖直方向的类似）</p>
<p>这里要说明的是，onVerticalXXX&#x2F;onHorizontalXXX 和 onPanXXX 不能同时设置。如果同时需要水平、竖直方向的移动，使用 onPanXXX。</p>
<p>如果读者希望在用户点击的时候能够有个水波纹效果，可以使用 InkWell，它的用法跟 GestureDetector 类似，只是少了拖动相关的手势（毕竟，这个水波纹效果只有在点击的时候才有意义）。</p>
<h3 id="原始手势事件监听"><a href="#原始手势事件监听" class="headerlink" title="原始手势事件监听"></a>原始手势事件监听</h3><p>GestureDetector 在绝大部分时候都能够满足我们的需求，如果真的满足不了，我们还可以使用最原始的 Listener 控件。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;  </span><br><span class="line"><span class="meta">@override</span>  </span><br><span class="line">Widget build(BuildContext context) &#123;    </span><br><span class="line"><span class="keyword">return</span> Listener(      </span><br><span class="line">child: Text(<span class="string">&#x27;text&#x27;</span>),      </span><br><span class="line">onPointerDown: (event) =&gt; <span class="built_in">print</span>(<span class="string">&#x27;onPointerDown&#x27;</span>),      </span><br><span class="line">onPointerUp: (event) =&gt; <span class="built_in">print</span>(<span class="string">&#x27;onPointerUp&#x27;</span>),      </span><br><span class="line">onPointerMove: (event) =&gt; <span class="built_in">print</span>(<span class="string">&#x27;onPointerMove&#x27;</span>),      </span><br><span class="line">onPointerCancel: (event) =&gt; <span class="built_in">print</span>(<span class="string">&#x27;onPointerCancel&#x27;</span>),    </span><br><span class="line">);  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在页面间跳转"><a href="#在页面间跳转" class="headerlink" title="在页面间跳转"></a>在页面间跳转</h3><p>Flutter 里所有的东西都是 widget，所以，一个页面，也是 widget。为了调整到新的页面，我们可以 push 一个 route 到 Navigator 管理的栈中。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Navigator.push(  </span><br><span class="line">context,  </span><br><span class="line">MaterialPageRoute(builder: (_) =&gt; SecondScreen())</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要返回的话，pop 掉就可以了：</span></span><br><span class="line">Navigator.pop(context);</span><br></pre></td></tr></table></figure>
<p><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607090397169.png" alt="Alt text"></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Navigator.pop(context, <span class="string">&#x27;message from second screen&#x27;</span>);</span><br><span class="line"><span class="comment">//由于打开页面是异步的，页面的结果通过一个 Future 来返回：</span></span><br><span class="line"></span><br><span class="line">onPressed: () <span class="keyword">async</span> &#123;  </span><br><span class="line"><span class="comment">// Navigator.push 会返回一个 Future&lt;T&gt;，如果你对这里使用的 await不太熟悉，可以参考  </span></span><br><span class="line"><span class="comment">// https://www.dartlang.org/guides/language/language-tour#asynchrony-support  </span></span><br><span class="line"><span class="keyword">var</span> msg = <span class="keyword">await</span> Navigator.push(    </span><br><span class="line">context,    </span><br><span class="line">MaterialPageRoute(builder: (_) =&gt; SecondScreen())  </span><br><span class="line">);  </span><br><span class="line">debugPrint(<span class="string">&#x27;msg = <span class="subst">$msg</span>&#x27;</span>);&#125;</span><br></pre></td></tr></table></figure>
<p>我们还可以在 MaterialApp 里设置好每个 route 对应的页面，然后使用 Navigator.pushNamed(context, routeName) 来打开它们：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MaterialApp(  </span><br><span class="line"><span class="comment">// 从名字叫做 &#x27;/&#x27; 的 route 开始（也就是 home）  </span></span><br><span class="line">initialRoute: <span class="string">&#x27;/&#x27;</span>,  </span><br><span class="line">routes: &#123;    </span><br><span class="line"><span class="string">&#x27;/&#x27;</span>: (context) =&gt; HomeScreen(),    </span><br><span class="line"><span class="string">&#x27;/about&#x27;</span>: (context) =&gt; AboutScreen(),  </span><br><span class="line">&#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>接下来，我们通过实现一个 echo 客户端的前端页面来综合运用前面所学的知识（逻辑部分我们留到下一篇文章再补充）。</p>
<h3 id="echo-客户端"><a href="#echo-客户端" class="headerlink" title="echo 客户端"></a>echo 客户端</h3><p>消息输入页<br>这一节我们来实现一个用户输入的页面。UI 很简单，就是一个文本框和一个按钮。<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607090444798.png" alt="Alt text"><br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607090449383.png" alt="Alt text"><br>这里的按钮本应该使用 RaisedButton 或 FlatButton。为了演示如何监听手势事件，我们这里故意自己用 Container 做了一个按钮，然后通过 InkWell 监听手势事件。InkWell 除了上面展示的几个事件外，还带有一个水波纹效果。如果不需要这个水波纹效果，读者也可以使用 GestureDetector。</p>
<h3 id="消息列表页面"><a href="#消息列表页面" class="headerlink" title="消息列表页面"></a>消息列表页面</h3><p>我们的 echo 客户端共有两个页面，一个用于展示所有的消息，另一个页面用户输入消息，后者在上一小节我们已经写好了。下面，我们来实现用于展示消息的页面。</p>
<h3 id="页面间跳转"><a href="#页面间跳转" class="headerlink" title="页面间跳转"></a>页面间跳转</h3><p>我们的页面包含一个列表和一个按钮，列表用于展示信息，按钮则用来打开上一节我们所实现的 AddMessageScreen。这里我们先添加一个按钮并实现页面间的跳转。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是我们的消息展示页面class MessageListScreen extends StatelessWidget &#123;  </span></span><br><span class="line"><span class="meta">@override</span>  </span><br><span class="line">Widget build(BuildContext context) &#123;    </span><br><span class="line"><span class="keyword">return</span> Scaffold(      </span><br><span class="line">appBar: AppBar(        </span><br><span class="line">title: Text(<span class="string">&#x27;Echo client&#x27;</span>),      </span><br><span class="line">),      </span><br><span class="line">floatingActionButton: FloatingActionButton(        </span><br><span class="line">onPressed: () &#123;          </span><br><span class="line"><span class="comment">// push 一个新的 route 到 Navigator 管理的栈中，以此来打开一个页面          </span></span><br><span class="line">Navigator.push(              </span><br><span class="line">context,              </span><br><span class="line">MaterialPageRoute(builder: (_) =&gt; AddMessageScreen())          </span><br><span class="line">);        </span><br><span class="line">&#125;,        </span><br><span class="line">tooltip: <span class="string">&#x27;Add message&#x27;</span>,        </span><br><span class="line">child: Icon(Icons.add),      </span><br><span class="line">)    </span><br><span class="line">);  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在消息的输入页面，我们点击 Send 按钮后就返回：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">onTap: () &#123;  </span><br><span class="line">debugPrint(<span class="string">&#x27;send: <span class="subst">$&#123;editController.text&#125;</span>&#x27;</span>);  </span><br><span class="line">Navigator.pop(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们加入一些骨架代码，实现一个完整的应用：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;  </span><br><span class="line">runApp(MyApp());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;  </span><br><span class="line"> </span><br><span class="line"><span class="meta">@override</span>  </span><br><span class="line">Widget build(BuildContext context) &#123;    </span><br><span class="line"><span class="keyword">return</span> MaterialApp(      </span><br><span class="line">title: <span class="string">&#x27;Flutter UX demo&#x27;</span>,      </span><br><span class="line">home: MessageListScreen(),    </span><br><span class="line">);  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，上面代码所提供的功能还不够，我们需要从 AddMessageScreen 中返回一个消息。</p>
<p>首先我们对数据建模：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;  </span><br><span class="line"><span class="keyword">final</span> <span class="built_in">String</span> msg;  </span><br><span class="line"><span class="keyword">final</span> <span class="built_in">int</span> timestamp;  </span><br><span class="line"> </span><br><span class="line">Message(<span class="keyword">this</span>.msg, <span class="keyword">this</span>.timestamp);  </span><br><span class="line"><span class="meta">@override</span>  </span><br><span class="line"><span class="built_in">String</span> toString() &#123;    </span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;Message&#123;msg: <span class="subst">$msg</span>, timestamp: <span class="subst">$timestamp</span>&#125;&#x27;</span>;  </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是返回数据和接收数据的代码：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">onTap: () &#123;  </span><br><span class="line">debugPrint(<span class="string">&#x27;send: <span class="subst">$&#123;editController.text&#125;</span>&#x27;</span>);  </span><br><span class="line"><span class="keyword">final</span> msg = Message(    </span><br><span class="line">editController.text,    </span><br><span class="line"><span class="built_in">DateTime</span>.now().millisecondsSinceEpoch  </span><br><span class="line">);  </span><br><span class="line">Navigator.pop(context, msg);</span><br><span class="line">&#125;,</span><br><span class="line"> </span><br><span class="line">floatingActionButton: FloatingActionButton(  </span><br><span class="line">onPressed: () <span class="keyword">async</span> &#123;    </span><br><span class="line"><span class="keyword">final</span> result = <span class="keyword">await</span> Navigator.push(        </span><br><span class="line">context,        </span><br><span class="line">MaterialPageRoute(builder: (_) =&gt; AddMessageScreen())    </span><br><span class="line">);    </span><br><span class="line">debugPrint(<span class="string">&#x27;result = <span class="subst">$result</span>&#x27;</span>);  &#125;,  <span class="comment">// ...)</span></span><br></pre></td></tr></table></figure>
<p>把数据展示到 ListView<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607090518989.png" alt="Alt text"><br>这段代码里唯一的新知识就是给 MessageList 的 key 参数，我们下面先看看如何使用他，然后再说明它的作用：<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607090533012.png" alt="Alt text"><br>引入一个 GlobalKey 的原因在于，MessageListScreen 需要把从 AddMessageScreen 返回的数据放到 _MessageListState 中，而我们无法从 MessageList 拿到这个 state。</p>
<p>GlobalKey 的是应用全局唯一的 key，把这个 key 设置给 MessageList 后，我们就能够通过这个 key 拿到对应的 statefulWidget 的 state。</p>
<p>现在，整体的效果是这个样子的：<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607090542053.png" alt="Alt text"></p>
<p>message-list<br>如果你遇到了麻烦，在 Github 上找到所有的代码：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/Jekton/flutter_demo.git </span></span><br><span class="line">cd flutter_demo </span><br><span class="line">git checkout ux-basic</span><br></pre></td></tr></table></figure>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>Flutter 动画的核心是 Animation，Animation 接受一个时钟信号（vsync），转换为 T 值输出。它控制着动画的进度和状态，但不参与图像的绘制。最基本的 Animation 是 AnimationController，它输出 [0, 1] 之间的值。</p>
<h4 id="使用内置的-Widget-完成动画"><a href="#使用内置的-Widget-完成动画" class="headerlink" title="使用内置的 Widget 完成动画"></a>使用内置的 Widget 完成动画</h4><p>为了使用动画，我们可以用 Flutter 提供的 AnimatedContainer、FadeTransition、ScaleTransition 和 RotationTransition 等 Widget 来完成。</p>
<p>下面我们就来演示如何使用 ScaleTransition：<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607090573192.png" alt="Alt text"><br>AnimationController 的输出是线性的。非线性的效果可以使用 CurveAnimation 来实现：<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607090581739.png" alt="Alt text"><br>当然，我们还可以组合不同的动画：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnimWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AnimWidget</span>&gt;    </span></span><br><span class="line"><span class="class"> <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;  <span class="comment">// ...  </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">@override</span>  </span><br><span class="line">Widget build(BuildContext context) &#123;    </span><br><span class="line"><span class="keyword">var</span> scaled = ScaleTransition(      </span><br><span class="line">child: FlutterLogo(size: <span class="number">200.0</span>),      </span><br><span class="line">scale: curve,    </span><br><span class="line">);    </span><br><span class="line"><span class="keyword">return</span> FadeTransition(      </span><br><span class="line">child: scaled,      </span><br><span class="line">opacity: curve,    </span><br><span class="line">);  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多的动画控件，读者可以参考 <a target="_blank" rel="noopener" href="https://flutter.io/widgets/animation/%E3%80%82">https://flutter.io/widgets/animation/。</a></p>
<h4 id="自定义动画效果"><a href="#自定义动画效果" class="headerlink" title="自定义动画效果"></a>自定义动画效果</h4><p>上一节我们使用 Flutter 内置的 Widget 来实现动画。他们虽然能够完成日常开发的大部分需求，但总有一些时候不太适用。这时我们就得自己实现动画效果了。</p>
<p>前面我们说，AnimationController 的输出在 [0, 1] 之间，这往往对我们需要实现的动画效果不太方便。为了将数值从 [0, 1] 映射到目标空间，可以使用 Tween：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">animationValue = Tween(begin: <span class="number">0.0</span>, end: <span class="number">200.0</span>).animate(controller)    <span class="comment">// 每一帧都会触发 listener 回调   </span></span><br><span class="line">..addListener(() &#123;     </span><br><span class="line"><span class="comment">// animationValue.value 随着动画的进行不断地变化。我们利用这个值来实现      </span></span><br><span class="line"><span class="comment">// 动画效果      </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;value = <span class="subst">$&#123;animationValue.value&#125;</span>&#x27;</span>);    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>下面我们来画一个小圆点，让它往复不断地在正弦曲线上运动。<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607090626978.png" alt="Alt text"><br>先来实现小圆点沿着曲线运动的效果：<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607090638458.png" alt="Alt text"><br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607090642442.png" alt="Alt text"><br>上面的动画中，我们只是对位置做出了改变，下面我们将在位置变化的同时，也让小圆点从红到蓝进行颜色的变化。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnimationState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AnimationDemoView</span>&gt;    </span></span><br><span class="line"><span class="class"><span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;  </span><br><span class="line"><span class="comment">// ...  </span></span><br><span class="line">Animation&lt;Color&gt; color;  </span><br><span class="line"><span class="keyword">void</span> _initState() &#123;    </span><br><span class="line"><span class="comment">// ...    </span></span><br><span class="line">color = ColorTween(begin: Colors.red, end: Colors.blue).animate(controller);    </span><br><span class="line">controller.forward();  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">@override</span>  </span><br><span class="line">Widget build(BuildContext context) &#123;    </span><br><span class="line"><span class="comment">// ...    </span></span><br><span class="line"><span class="keyword">final</span> color = <span class="keyword">this</span>.color == <span class="keyword">null</span> ? Colors.red : <span class="keyword">this</span>.color.value;    </span><br><span class="line"><span class="keyword">return</span> Container(      </span><br><span class="line"><span class="comment">// 我们根据动画的进度设置圆点的位置      </span></span><br><span class="line">margin: EdgeInsets.only(left: marginLeft, top: marginTop),      </span><br><span class="line"><span class="comment">// 画一个小圆点      </span></span><br><span class="line">child: Container(        </span><br><span class="line">decoration: BoxDecoration(            </span><br><span class="line">color: color, borderRadius: BorderRadius.circular(<span class="number">7.5</span>)),        </span><br><span class="line">width: <span class="number">15.0</span>,        </span><br><span class="line">height: <span class="number">15.0</span>,      </span><br><span class="line">),    </span><br><span class="line">);  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 GitHub 上，可以找到所有的代码：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/Jekton/flutter_demo.git</span></span><br><span class="line">cd flutter_demo</span><br><span class="line">git checkout sin-curve</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们还可以加多一些效果，比方说让小圆点在运动的过程中大小也不断变化、使用 CurveAnimation 改变它运动的速度，这些就留给读者作为练习吧。</p>
<h2 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h2><p>本篇介绍Flutter中网络请求相关api的使用，Flutter在Flutter engine中提供了一个sky_engine开发工具包，其包含了一个_http的库，该库中有封装的http请求相关的各种操作类。本文我们将介绍_http相关操作类的使用和基于_http封装的三方dio网络库的使用</p>
<h3 id="自带网络库-http"><a href="#自带网络库-http" class="headerlink" title="自带网络库_http"></a>自带网络库_http</h3><p>_http库中的http.dart文件中封装的HttpClient类是我们常用的网络请求操作类，该类是一个抽象类，其具体操作由http_impl.dart文件中_HttpClient类实现，该类中封装了各种http请求的方法，包括get、post、put、delete、patch和head等请求。</p>
<p>get和post请求方法是我们常用的两种方法，通过下面的例子看下其使用方法。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">_getHttpData() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line">    <span class="comment">//为charles抓包设置代理，为什么在代码中设置？请参考上篇文章。</span></span><br><span class="line">    httpClient.findProxy = (url) &#123;</span><br><span class="line">      <span class="keyword">return</span> HttpClient.findProxyFromEnvironment(url, environment: &#123;<span class="string">&quot;http_proxy&quot;</span>: <span class="string">&#x27;http://192.168.124.94:8888&#x27;</span>,&#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//请求参数设置</span></span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; queryParameters = &#123;<span class="string">&#x27;format&#x27;</span>: <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;key&#x27;</span>: <span class="string">&#x27;939e592487c33b12c509f757500888b5&#x27;</span>, <span class="string">&#x27;lon&#x27;</span>: <span class="string">&#x27;116.39277&#x27;</span>, <span class="string">&#x27;lat&#x27;</span>: <span class="string">&#x27;39.933748&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">var</span> uri = <span class="built_in">Uri</span>.http(<span class="string">&#x27;v.juhe.cn&#x27;</span>, <span class="string">&#x27;/weather/geo&#x27;</span>, queryParameters);</span><br><span class="line">    <span class="keyword">var</span> request = <span class="keyword">await</span> httpClient.getUrl(uri);</span><br><span class="line">    <span class="comment">//下面一行是post请求</span></span><br><span class="line">    <span class="comment">//var request = await httpClient.postUrl(uri);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> response = <span class="keyword">await</span> request.close();</span><br><span class="line">    <span class="keyword">if</span> (response.statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;请求成功&#x27;</span>);</span><br><span class="line">      <span class="keyword">var</span> responseBody = <span class="keyword">await</span> response.transform(utf8.decoder).join();</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;responseBody = <span class="subst">$responseBody</span>&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;请求失败&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码中httpClient.getUrl(uri)方法即是根据uri发起get请求，post请求用法和get请求只是调用方法不同，包括参数设置等其他用法都一样。请求抓包结果如下：</p>
<p>get请求<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607090756372.png" alt="Alt text"><br>post请求<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607090766499.png" alt="Alt text"><br>请求成功之后以上代码输出结果如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I/flutter (<span class="number">19183</span>): 请求成功</span><br><span class="line">I/flutter (<span class="number">19183</span>): responseBody=&#123;<span class="string">&quot;resultcode&quot;</span>:<span class="string">&quot;200&quot;</span>,<span class="string">&quot;reason&quot;</span>:<span class="string">&quot;查询成功&quot;</span>,<span class="string">&quot;result&quot;</span>:&#123;<span class="string">&quot;sk&quot;</span>:&#123;<span class="string">&quot;temp&quot;</span>:<span class="string">&quot;8&quot;</span>,<span class="string">&quot;wind_direction&quot;</span>:<span class="string">&quot;西南风&quot;</span>,<span class="string">&quot;wind_strength&quot;</span>:<span class="string">&quot;2级&quot;</span>,<span class="string">&quot;humidity&quot;</span>:<span class="string">&quot;51%&quot;</span>,<span class="string">&quot;time&quot;</span>:<span class="string">&quot;21:54&quot;</span>&#125;,<span class="string">&quot;today&quot;</span>:&#123;<span class="string">&quot;temperature&quot;</span>:<span class="string">&quot;1℃~15℃&quot;</span>,<span class="string">&quot;weather&quot;</span>:<span class="string">&quot;晴&quot;</span>,<span class="string">&quot;weather_id&quot;</span>:&#123;<span class="string">&quot;fa&quot;</span>:<span class="string">&quot;00&quot;</span>,<span class="string">&quot;fb&quot;</span>:<span class="string">&quot;00&quot;</span>&#125;,<span class="string">&quot;wind&quot;</span>:<span class="string">&quot;南风微风&quot;</span>,<span class="string">&quot;week&quot;</span>:<span class="string">&quot;星期五&quot;</span>,<span class="string">&quot;city&quot;</span>:<span class="string">&quot;北京&quot;</span>,<span class="string">&quot;date_y&quot;</span>:<span class="string">&quot;2019年03月01日&quot;</span>,<span class="string">&quot;dressing_index&quot;</span>:<span class="string">&quot;较冷&quot;</span>,<span class="string">&quot;dressing_advice&quot;</span>:<span class="string">&quot;建议着厚外套加毛衣等服装。年老体弱者宜着大衣、呢外套加羊毛衫。&quot;</span>,<span class="string">&quot;uv_index&quot;</span>:<span class="string">&quot;中等&quot;</span>,<span class="string">&quot;comfort_index&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="string">&quot;wash_index&quot;</span>:<span class="string">&quot;较适宜&quot;</span>,<span class="string">&quot;travel_index&quot;</span>:<span class="string">&quot;较不宜&quot;</span>,<span class="string">&quot;exercise_index&quot;</span>:<span class="string">&quot;较不宜&quot;</span>,<span class="string">&quot;drying_index&quot;</span>:<span class="string">&quot;&quot;</span>&#125;,<span class="string">&quot;future&quot;</span>:[&#123;<span class="string">&quot;temperature&quot;</span>:<span class="string">&quot;1℃~15℃&quot;</span>,<span class="string">&quot;weather&quot;</span>:<span class="string">&quot;晴&quot;</span>,<span class="string">&quot;weather_id&quot;</span>:&#123;<span class="string">&quot;fa&quot;</span>:<span class="string">&quot;00&quot;</span>,<span class="string">&quot;fb&quot;</span>:<span class="string">&quot;00&quot;</span>&#125;,<span class="string">&quot;wind&quot;</span>:<span class="string">&quot;南风微风&quot;</span>,<span class="string">&quot;week&quot;</span>:<span class="string">&quot;星期五&quot;</span>,<span class="string">&quot;date&quot;</span>:<span class="string">&quot;20190301&quot;</span>&#125;,&#123;<span class="string">&quot;temperature&quot;</span>:<span class="string">&quot;3℃~15℃&quot;</span>,<span class="string">&quot;weather&quot;</span>:<span class="string">&quot;霾&quot;</span>,<span class="string">&quot;weather_id&quot;</span>:&#123;<span class="string">&quot;fa&quot;</span>:<span class="string">&quot;53&quot;</span>,<span class="string">&quot;fb&quot;</span>:<span class="string">&quot;53&quot;</span>&#125;,<span class="string">&quot;wind&quot;</span>:<span class="string">&quot;西南风微风&quot;</span>,<span class="string">&quot;week&quot;</span>:<span class="string">&quot;星期六&quot;</span>,<span class="string">&quot;date&quot;</span>:<span class="string">&quot;20190302&quot;</span>&#125;,&#123;<span class="string">&quot;temperature&quot;</span>:<span class="string">&quot;3℃~15℃&quot;</span>,<span class="string">&quot;weather&quot;</span>:<span class="string">&quot;霾转晴&quot;</span>,<span class="string">&quot;weather_id&quot;</span>:&#123;<span class="string">&quot;fa&quot;</span>:<span class="string">&quot;53&quot;</span>,<span class="string">&quot;fb&quot;</span>:<span class="string">&quot;00&quot;</span>&#125;,<span class="string">&quot;wind&quot;</span>:<span class="string">&quot;西南风微风&quot;</span>,<span class="string">&quot;</span></span><br></pre></td></tr></table></figure>
<p>由此可以看出结果输出不完整，部分字符串被丢弃了，前段时间有个同学留言问过这个问题，在这里说明一下。Flutter官方文档有这个问题的说明：</p>
<p>The Dart print() function outputs to the system console, which you can view using flutter logs (which is basically a wrapper around adb logcat).</p>
<p>If you output too much at once, then Android sometimes discards some log lines. To avoid this, you can use debugPrint(), from Flutter’s foundation library. This is a wrapper around print which throttles the output to a level that avoids being dropped by Android’s kernel.</p>
<p>具体地址在：</p>
<p><a target="_blank" rel="noopener" href="https://flutter.dev/docs/testing/debugging#print-and-debugprint-with-flutter-logs">https://flutter.dev/docs/testing/debugging#print-and-debugprint-with-flutter-logs</a></p>
<p>官方建议我们输出日志过多的时候使用debugPrint()函数，作者使用debugPrint()函数之后发现依然是输出不完整，查看debugPrint()函数的具体代码实现后发现以上输出的内容是一行的内容，一行内容过多的情况下debugPrint()函数依然无法完整进行输出，最后我采用了一个技巧，对以上返回的responseBody结果进行了简单处理，根据特殊字符串进行字符串替换，加入换行符，代码如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> responseBody = <span class="keyword">await</span> response.transform(utf8.decoder).join();</span><br><span class="line"><span class="comment">//‘&#123;’符号前加个换行符</span></span><br><span class="line">responseBody = responseBody.replaceAll(<span class="string">&quot;&#123;&quot;</span>, <span class="string">&quot;\n&#123;&quot;</span>);</span><br><span class="line">debugPrint(<span class="string">&#x27;responseBody=<span class="subst">$responseBody</span>&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>于是输出了完整的请求返回结果：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">I/flutter (<span class="number">19183</span>): 请求成功</span><br><span class="line">I/flutter (<span class="number">19183</span>): responseBody=</span><br><span class="line">I/flutter (<span class="number">19183</span>): &#123;<span class="string">&quot;resultcode&quot;</span>:<span class="string">&quot;200&quot;</span>,<span class="string">&quot;reason&quot;</span>:<span class="string">&quot;successed!&quot;</span>,<span class="string">&quot;result&quot;</span>:</span><br><span class="line">I/flutter (<span class="number">19183</span>): &#123;<span class="string">&quot;sk&quot;</span>:</span><br><span class="line">I/flutter (<span class="number">19183</span>): &#123;<span class="string">&quot;temp&quot;</span>:<span class="string">&quot;8&quot;</span>,<span class="string">&quot;wind_direction&quot;</span>:<span class="string">&quot;西南风&quot;</span>,<span class="string">&quot;wind_strength&quot;</span>:<span class="string">&quot;2级&quot;</span>,<span class="string">&quot;humidity&quot;</span>:<span class="string">&quot;51%&quot;</span>,<span class="string">&quot;time&quot;</span>:<span class="string">&quot;22:09&quot;</span>&#125;,<span class="string">&quot;today&quot;</span>:</span><br><span class="line">I/flutter (<span class="number">19183</span>): &#123;<span class="string">&quot;temperature&quot;</span>:<span class="string">&quot;1℃~15℃&quot;</span>,<span class="string">&quot;weather&quot;</span>:<span class="string">&quot;晴&quot;</span>,<span class="string">&quot;weather_id&quot;</span>:</span><br><span class="line">I/flutter (<span class="number">19183</span>): &#123;<span class="string">&quot;fa&quot;</span>:<span class="string">&quot;00&quot;</span>,<span class="string">&quot;fb&quot;</span>:<span class="string">&quot;00&quot;</span>&#125;,<span class="string">&quot;wind&quot;</span>:<span class="string">&quot;南风微风&quot;</span>,<span class="string">&quot;week&quot;</span>:<span class="string">&quot;星期五&quot;</span>,<span class="string">&quot;city&quot;</span>:<span class="string">&quot;北京&quot;</span>,<span class="string">&quot;date_y&quot;</span>:<span class="string">&quot;2019年03月01日&quot;</span>,<span class="string">&quot;dressing_index&quot;</span>:<span class="string">&quot;较冷&quot;</span>,<span class="string">&quot;dressing_advice&quot;</span>:<span class="string">&quot;建议着厚外套加毛衣等服装。年老体弱者宜着大衣、呢外套加羊毛衫。&quot;</span>,<span class="string">&quot;uv_index&quot;</span>:<span class="string">&quot;中等&quot;</span>,<span class="string">&quot;comfort_index&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="string">&quot;wash_index&quot;</span>:<span class="string">&quot;较适宜&quot;</span>,<span class="string">&quot;travel_index&quot;</span>:<span class="string">&quot;较不宜&quot;</span>,<span class="string">&quot;exercise_index&quot;</span>:<span class="string">&quot;较不宜&quot;</span>,<span class="string">&quot;drying_index&quot;</span>:<span class="string">&quot;&quot;</span>&#125;,<span class="string">&quot;future&quot;</span>:[</span><br><span class="line">I/flutter (<span class="number">19183</span>): &#123;<span class="string">&quot;temperature&quot;</span>:<span class="string">&quot;1℃~15℃&quot;</span>,<span class="string">&quot;weather&quot;</span>:<span class="string">&quot;晴&quot;</span>,<span class="string">&quot;weather_id&quot;</span>:</span><br><span class="line">I/flutter (<span class="number">19183</span>): &#123;<span class="string">&quot;fa&quot;</span>:<span class="string">&quot;00&quot;</span>,<span class="string">&quot;fb&quot;</span>:<span class="string">&quot;00&quot;</span>&#125;,<span class="string">&quot;wind&quot;</span>:<span class="string">&quot;南风微风&quot;</span>,<span class="string">&quot;week&quot;</span>:<span class="string">&quot;星期五&quot;</span>,<span class="string">&quot;date&quot;</span>:<span class="string">&quot;20190301&quot;</span>&#125;,</span><br><span class="line">I/flutter (<span class="number">19183</span>): &#123;<span class="string">&quot;temperature&quot;</span>:<span class="string">&quot;3℃~15℃&quot;</span>,<span class="string">&quot;weather&quot;</span>:<span class="string">&quot;霾&quot;</span>,<span class="string">&quot;weather_id&quot;</span>:</span><br><span class="line">I/flutter (<span class="number">19183</span>): &#123;<span class="string">&quot;fa&quot;</span>:<span class="string">&quot;53&quot;</span>,<span class="string">&quot;fb&quot;</span>:<span class="string">&quot;53&quot;</span>&#125;,<span class="string">&quot;wind&quot;</span>:<span class="string">&quot;西南风微风&quot;</span>,<span class="string">&quot;week&quot;</span>:<span class="string">&quot;星期六&quot;</span>,<span class="string">&quot;date&quot;</span>:<span class="string">&quot;20190302&quot;</span>&#125;,</span><br><span class="line">I/flutter (<span class="number">19183</span>): &#123;<span class="string">&quot;temperature&quot;</span>:<span class="string">&quot;3℃~15℃&quot;</span>,<span class="string">&quot;weather&quot;</span>:<span class="string">&quot;霾转晴&quot;</span>,<span class="string">&quot;weather_id&quot;</span>:</span><br><span class="line">I/flutter (<span class="number">19183</span>): &#123;<span class="string">&quot;fa&quot;</span>:<span class="string">&quot;53&quot;</span>,<span class="string">&quot;fb&quot;</span>:<span class="string">&quot;00&quot;</span>&#125;,<span class="string">&quot;wind&quot;</span>:<span class="string">&quot;西南风微风&quot;</span>,<span class="string">&quot;week&quot;</span>:<span class="string">&quot;星期日&quot;</span>,<span class="string">&quot;date&quot;</span>:<span class="string">&quot;20190303&quot;</span>&#125;,</span><br><span class="line">I/flutter (<span class="number">19183</span>): &#123;<span class="string">&quot;temperature&quot;</span>:<span class="string">&quot;2℃~15℃&quot;</span>,<span class="string">&quot;weather&quot;</span>:<span class="string">&quot;晴&quot;</span>,<span class="string">&quot;weather_id&quot;</span>:</span><br><span class="line">I/flutter (<span class="number">19183</span>): &#123;<span class="string">&quot;fa&quot;</span>:<span class="string">&quot;00&quot;</span>,<span class="string">&quot;fb&quot;</span>:<span class="string">&quot;00&quot;</span>&#125;,<span class="string">&quot;wind&quot;</span>:<span class="string">&quot;北风微风&quot;</span>,<span class="string">&quot;week&quot;</span>:<span class="string">&quot;星期一&quot;</span>,<span class="string">&quot;date&quot;</span>:<span class="string">&quot;20190304&quot;</span>&#125;,</span><br><span class="line">I/flutter (<span class="number">19183</span>): &#123;<span class="string">&quot;temperature&quot;</span>:<span class="string">&quot;3℃~16℃&quot;</span>,<span class="string">&quot;weather&quot;</span>:<span class="string">&quot;晴&quot;</span>,<span class="string">&quot;weather_id&quot;</span>:</span><br><span class="line">I/flutter (<span class="number">19183</span>): &#123;<span class="string">&quot;fa&quot;</span>:<span class="string">&quot;00&quot;</span>,<span class="string">&quot;fb&quot;</span>:<span class="string">&quot;00&quot;</span>&#125;,<span class="string">&quot;wind&quot;</span>:<span class="string">&quot;北风微风&quot;</span>,<span class="string">&quot;week&quot;</span>:<span class="string">&quot;星期二&quot;</span>,<span class="string">&quot;date&quot;</span>:<span class="string">&quot;20190305&quot;</span>&#125;,</span><br><span class="line">I/flutter (<span class="number">19183</span>): &#123;<span class="string">&quot;temperature&quot;</span>:<span class="string">&quot;3℃~15℃&quot;</span>,<span class="string">&quot;weather&quot;</span>:<span class="string">&quot;霾&quot;</span>,<span class="string">&quot;weather_id&quot;</span>:</span><br><span class="line">I/flutter (<span class="number">19183</span>): &#123;<span class="string">&quot;fa&quot;</span>:<span class="string">&quot;53&quot;</span>,<span class="string">&quot;fb&quot;</span>:<span class="string">&quot;53&quot;</span>&#125;,<span class="string">&quot;wind&quot;</span>:<span class="string">&quot;西南风微风&quot;</span>,<span class="string">&quot;week&quot;</span>:<span class="string">&quot;星期三&quot;</span>,<span class="string">&quot;date&quot;</span>:<span class="string">&quot;20190306&quot;</span>&#125;,</span><br><span class="line">I/flutter (<span class="number">19183</span>): &#123;<span class="string">&quot;temperature&quot;</span>:<span class="string">&quot;3℃~15℃&quot;</span>,<span class="string">&quot;weather&quot;</span>:<span class="string">&quot;霾&quot;</span>,<span class="string">&quot;weather_id&quot;</span>:</span><br><span class="line">I/flutter (<span class="number">19183</span>): &#123;<span class="string">&quot;fa&quot;</span>:<span class="string">&quot;53&quot;</span>,<span class="string">&quot;fb&quot;</span>:<span class="string">&quot;53&quot;</span>&#125;,<span class="string">&quot;wind&quot;</span>:<span class="string">&quot;西南风微风&quot;</span>,<span class="string">&quot;week&quot;</span>:<span class="string">&quot;星期四&quot;</span>,<span class="string">&quot;date&quot;</span>:<span class="string">&quot;20190307&quot;</span>&#125;]&#125;,<span class="string">&quot;error_code&quot;</span>:<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第三方网络库dio"><a href="#第三方网络库dio" class="headerlink" title="第三方网络库dio"></a>第三方网络库dio</h3><p>dio是目前使用最多的Flutter三方网络库，它是对http请求的一个封装，功能非常强大，支持拦截器、全局配置、表单数据、请求取消、文件下载、超时等。目前dio的最新版本为2.0.15，2.x版本对1.x版本代码进行了一些重构，所以之前使用过1.x版本的同学，再升级到2.x时要注意需要修改一些代码。</p>
<p>下面基于2.0.15版本举个请求天气信息的例子：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">Null</span>&gt; _getWeatherInfo() <span class="keyword">async</span> &#123;</span><br><span class="line">  Dio dio = Dio();</span><br><span class="line">  <span class="comment">//设置代理</span></span><br><span class="line">  DefaultHttpClientAdapter adapter = dio.httpClientAdapter;</span><br><span class="line">  adapter.onHttpClientCreate = (HttpClient client) &#123;</span><br><span class="line">    <span class="keyword">if</span>(client == <span class="keyword">null</span>) &#123;</span><br><span class="line">      client = HttpClient();</span><br><span class="line">    &#125;</span><br><span class="line">    client.findProxy = (url) &#123;</span><br><span class="line">      <span class="keyword">return</span> HttpClient.findProxyFromEnvironment(url, environment: &#123;<span class="string">&quot;http_proxy&quot;</span>: <span class="string">&#x27;http://192.168.124.94:8888&#x27;</span>,&#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> client;</span><br><span class="line">  &#125;;</span><br><span class="line">  dio.options.baseUrl = <span class="string">&quot;http://v.juhe.cn/&quot;</span>;</span><br><span class="line">  <span class="comment">//设置连接超时时间</span></span><br><span class="line">  dio.options.connectTimeout = <span class="number">10000</span>;</span><br><span class="line">  <span class="comment">//设置数据接收超时时间</span></span><br><span class="line">  dio.options.receiveTimeout = <span class="number">10000</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//以表单的形式设置请求参数</span></span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; queryParameters = &#123;<span class="string">&#x27;format&#x27;</span>: <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;key&#x27;</span>: <span class="string">&#x27;939e592487c33b12c509f757500888b5&#x27;</span>, <span class="string">&#x27;lon&#x27;</span>: <span class="string">&#x27;116.39277&#x27;</span>, <span class="string">&#x27;lat&#x27;</span>: <span class="string">&#x27;39.933748&#x27;</span>&#125;;</span><br><span class="line">    Response response = <span class="keyword">await</span> dio.<span class="keyword">get</span>(<span class="string">&quot;/weather/geo&quot;</span>, queryParameters: queryParameters);</span><br><span class="line">    <span class="keyword">if</span> (response.statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;请求成功&#x27;</span>);</span><br><span class="line">      <span class="keyword">var</span> responseData = response.data.toString();</span><br><span class="line">      responseData = responseData.replaceAll(<span class="string">&quot;&#123;&quot;</span>, <span class="string">&quot;\n&#123;&quot;</span>);</span><br><span class="line">      debugPrint(<span class="string">&#x27;response.data=<span class="subst">$responseData</span>&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">on</span> DioError <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;exception: <span class="subst">$e</span>&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于代理设置代码块，在Dio 2.x版本和1.x版本上设置的方式是不同的，这是因为Dio 2.x版本代码重构的原因，1.x代码上onHttpClientCreate方法放在了Dio类中，而2.x版本将该方法封装到了一个名为DefaultHttpClientAdapter的类中，Dio类中的httpClientAdapter即是默认实现了DefaultHttpClientAdapter类的对象，所以此时根据httpClientAdapter对象来设置onHttpClientCreate为自定义方法即可。</p>
<p>1.x版本代理设置方法的代码块如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Dio dio = Dio();</span><br><span class="line">dio.onHttpClientCreate = (HttpClient client) &#123;</span><br><span class="line">  <span class="keyword">if</span>(client == <span class="keyword">null</span>) &#123;</span><br><span class="line">    client = HttpClient();</span><br><span class="line">  &#125;</span><br><span class="line">  client.findProxy = (url) &#123;</span><br><span class="line">    <span class="keyword">return</span> HttpClient.findProxyFromEnvironment(url, environment: &#123;<span class="string">&quot;http_proxy&quot;</span>: <span class="string">&#x27;http://192.168.124.94:8888&#x27;</span>,&#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> client;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>使用Dio处理网络请求可以设置拦截器，dio中定义了两个拦截器：LogInterceptor和CookieManager，这两个拦截器都是抽象类Interceptor的实现，具体是对抽象类中onRequest、onResponse、onError三个方法的实现，我们也可以自定义拦截器处理一些自己的需求。下面使用LogInterceptor来举例说明拦截器的作用：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在上文dio使用的代码中加入如下代码，即添加了Log拦截器</span></span><br><span class="line">dio.interceptors.add(LogInterceptor());</span><br></pre></td></tr></table></figure>
<p>添加拦截器之后，执行请求，会看到控制台打印如下信息：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">I/flutter (<span class="number">28939</span>): *** Request ***</span><br><span class="line">I/flutter (<span class="number">28939</span>): uri: http:<span class="comment">//v.juhe.cn/weather/geo?format=2&amp;key=939e592487c33b12c509f757500888b5&amp;lon=116.39277&amp;lat=39.933748</span></span><br><span class="line">I/flutter (<span class="number">28939</span>): method: GET</span><br><span class="line">I/flutter (<span class="number">28939</span>): contentType: application/json; charset=utf<span class="number">-8</span></span><br><span class="line">I/flutter (<span class="number">28939</span>): responseType: ResponseType.json</span><br><span class="line">I/flutter (<span class="number">28939</span>): followRedirects: <span class="keyword">true</span></span><br><span class="line">I/flutter (<span class="number">28939</span>): connectTimeout: <span class="number">10000</span></span><br><span class="line">I/flutter (<span class="number">28939</span>): receiveTimeout: <span class="number">10000</span></span><br><span class="line">I/flutter (<span class="number">28939</span>): extra: &#123;&#125;</span><br><span class="line">I/flutter (<span class="number">28939</span>): header: </span><br><span class="line">I/flutter (<span class="number">28939</span>): </span><br><span class="line">I/flutter (<span class="number">28939</span>): *** Response ***</span><br><span class="line">I/flutter (<span class="number">28939</span>): uri: http:<span class="comment">//v.juhe.cn/weather/geo?format=2&amp;key=939e592487c33b12c509f757500888b5&amp;lon=116.39277&amp;lat=39.933748</span></span><br><span class="line">I/flutter (<span class="number">28939</span>): statusCode: <span class="number">200</span></span><br><span class="line">I/flutter (<span class="number">28939</span>): headers:</span><br><span class="line">I/flutter (<span class="number">28939</span>):  proxy-connection: Keep-alive</span><br><span class="line">I/flutter (<span class="number">28939</span>):  etag: <span class="number">063</span>d270dc44003f39cf480b7ec6ff843</span><br><span class="line">I/flutter (<span class="number">28939</span>):  content-type: application/json;charset=utf<span class="number">-8</span></span><br><span class="line">I/flutter (<span class="number">28939</span>):  <span class="keyword">set</span>-cookie: aliyungf_tc=AQAAAP85/D47jwIAsongemk2vUOG/ZUW; Path=/; HttpOnly</span><br><span class="line">I/flutter (<span class="number">28939</span>):  transfer-encoding: chunked</span><br><span class="line">I/flutter (<span class="number">28939</span>):  date: Sat, <span class="number">02</span> Mar <span class="number">2019</span> <span class="number">04</span>:<span class="number">29</span>:<span class="number">17</span> GMT</span><br><span class="line">I/flutter (<span class="number">28939</span>):  </span><br><span class="line">I/flutter (<span class="number">28939</span>): </span><br></pre></td></tr></table></figure>
<p>由打印结果可以看出LogInterceptor拦截器其实就是对request和response相关信息的打印，这有助于我们对http请求进行调试。</p>
<h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><p>由以上代码可以看出使用dio实现网络请求时，可以通过dio.options的进行全局通用配置，比如baseUrl、超时时间、请求的header信息等。</p>
<h3 id="表单数据"><a href="#表单数据" class="headerlink" title="表单数据"></a>表单数据</h3><p>使用post请求我们可以使用form表单的形式发送参数数据，代码如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; queryParameters = &#123;<span class="string">&#x27;format&#x27;</span>: <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;key&#x27;</span>: <span class="string">&#x27;939e592487c33b12c509f757500888b5&#x27;</span>, <span class="string">&#x27;lon&#x27;</span>: <span class="string">&#x27;116.39277&#x27;</span>, <span class="string">&#x27;lat&#x27;</span>: <span class="string">&#x27;39.933748&#x27;</span>&#125;;</span><br><span class="line">Response response = <span class="keyword">await</span> dio.post(<span class="string">&quot;/weather/geo&quot;</span>, data: FormData.from(queryParameters), options: Options());</span><br></pre></td></tr></table></figure>
<p>通过抓取请求包，我们会发现content-type类型如下：<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607090887177.png" alt="Alt text"></p>
<h3 id="请求取消"><a href="#请求取消" class="headerlink" title="请求取消"></a>请求取消</h3><p>比如跳转到某个页面请求了一条远程数据，但在数据没有回来之前关闭了该页面，那这条请求是可以在关闭页面时取消掉的，这要求你在发请求时使用cancelToken参数，如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CancelToken _cancelToken = CancelToken();</span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; queryParameters = &#123;<span class="string">&#x27;format&#x27;</span>: <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;key&#x27;</span>: <span class="string">&#x27;939e592487c33b12c509f757500888b5&#x27;</span>, <span class="string">&#x27;lon&#x27;</span>: <span class="string">&#x27;116.39277&#x27;</span>, <span class="string">&#x27;lat&#x27;</span>: <span class="string">&#x27;39.933748&#x27;</span>&#125;;</span><br><span class="line">Response response = <span class="keyword">await</span> dio.post(<span class="string">&quot;/weather/geo&quot;</span>, data: FormData.from(queryParameters), cancelToken: _cancelToken);</span><br></pre></td></tr></table></figure>
<p>在页面退出之前可以通过调用_cancelToken.cancel()方法取消该请求。多个请求可以使用同一个CancelToken对象，故调用该对象的cancel()方法时所有的未完成的请求均会被取消。</p>
<h3 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h3><p>Dio中实现的文件下载功能也非常简单好用，实例代码如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">String</span>&gt; getSavePath() <span class="keyword">async</span> &#123;</span><br><span class="line">    Directory externalStorageDir = <span class="keyword">await</span> getExternalStorageDirectory();</span><br><span class="line">    <span class="built_in">String</span> externalStoragePath = externalStorageDir.path + <span class="string">&quot;/flutterdemo&quot;</span>;</span><br><span class="line">    Directory dir = Directory(externalStoragePath);</span><br><span class="line">    <span class="keyword">if</span>(!dir.existsSync()) &#123;</span><br><span class="line">      dir.createSync();</span><br><span class="line">    &#125;</span><br><span class="line">    File file = File(dir.path + <span class="string">&quot;/test.jpg&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!file.existsSync()) &#123;</span><br><span class="line">      file.createSync();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;file.path = <span class="subst">$&#123;file.path&#125;</span>&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> file.path;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Future&lt;<span class="built_in">Null</span>&gt; _downloadImage() <span class="keyword">async</span> &#123;</span><br><span class="line">    Dio dio = Dio();</span><br><span class="line">    dio.options.baseUrl = <span class="string">&quot;http://img.ipintu.cn/images/&quot;</span>;</span><br><span class="line">    dio.interceptors.add(LogInterceptor());</span><br><span class="line">    <span class="built_in">String</span> savePath = <span class="keyword">await</span> getSavePath();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Response response = <span class="keyword">await</span> dio.download(</span><br><span class="line">          <span class="string">&quot;/baomanwayong_04.jpg&quot;</span>,</span><br><span class="line">          savePath,</span><br><span class="line">          onReceiveProgress: (<span class="built_in">int</span> count, <span class="built_in">int</span> total) &#123;</span><br><span class="line">            <span class="keyword">if</span>(total &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="built_in">print</span>((count / total * <span class="number">100</span>).toStringAsFixed(<span class="number">0</span>) + <span class="string">&quot;%&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      <span class="keyword">if</span> (response.statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;下载完成&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">on</span> DioError <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;exception: <span class="subst">$e</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击按钮调用下载方法，控制台输出信息如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">I/flutter ( <span class="number">5603</span>): file.path = /storage/emulated/<span class="number">0</span>/flutterdemo/test.jpg</span><br><span class="line">I/flutter ( <span class="number">5603</span>): *** Request ***</span><br><span class="line">I/flutter ( <span class="number">5603</span>): uri: http:<span class="comment">//img.ipintu.cn/images/baomanwayong_04.jpg</span></span><br><span class="line">I/flutter ( <span class="number">5603</span>): method: GET</span><br><span class="line">I/flutter ( <span class="number">5603</span>): contentType: application/json; charset=utf<span class="number">-8</span></span><br><span class="line">I/flutter ( <span class="number">5603</span>): responseType: ResponseType.stream</span><br><span class="line">I/flutter ( <span class="number">5603</span>): followRedirects: <span class="keyword">true</span></span><br><span class="line">I/flutter ( <span class="number">5603</span>): connectTimeout: <span class="number">0</span></span><br><span class="line">I/flutter ( <span class="number">5603</span>): receiveTimeout: <span class="number">0</span></span><br><span class="line">I/flutter ( <span class="number">5603</span>): extra: &#123;&#125;</span><br><span class="line">I/flutter ( <span class="number">5603</span>): header: </span><br><span class="line">I/flutter ( <span class="number">5603</span>): </span><br><span class="line">I/flutter ( <span class="number">5603</span>): *** Response ***</span><br><span class="line">I/flutter ( <span class="number">5603</span>): uri: http:<span class="comment">//img.ipintu.cn/images/baomanwayong_04.jpg</span></span><br><span class="line">I/flutter ( <span class="number">5603</span>): statusCode: <span class="number">200</span></span><br><span class="line">I/flutter ( <span class="number">5603</span>): headers:</span><br><span class="line">I/flutter ( <span class="number">5603</span>):  last-modified: Fri, <span class="number">11</span> May <span class="number">2018</span> <span class="number">08</span>:<span class="number">45</span>:<span class="number">42</span> GMT</span><br><span class="line">I/flutter ( <span class="number">5603</span>):  date: Sat, <span class="number">02</span> Mar <span class="number">2019</span> <span class="number">07</span>:<span class="number">17</span>:<span class="number">01</span> GMT</span><br><span class="line">I/flutter ( <span class="number">5603</span>):  x-reqid: BwAAABaE5ayYe4YV</span><br><span class="line">I/flutter ( <span class="number">5603</span>):  access-control-expose-headers: X-Log, X-Reqid</span><br><span class="line">I/flutter ( <span class="number">5603</span>):  x-m-reqid: mmcAAMu4tv7GEogV</span><br><span class="line">I/flutter ( <span class="number">5603</span>):  server: marco/<span class="number">2.8</span></span><br><span class="line">I/flutter ( <span class="number">5603</span>):  x-request-id: <span class="number">8836</span>d6cebf799bbe22c678f2c9cdb5d3; <span class="number">6</span>b3ff4ec13b9de472e4bae298d38d9c9</span><br><span class="line">I/flutter ( <span class="number">5603</span>):  x-log: redis.g/<span class="number">404</span>;mc.g/<span class="number">404</span>;redis.g;rs40_shard.sel:<span class="number">4</span>/not found;rdb.g;bs.r<span class="number">.48</span><span class="number">.179</span><span class="number">.10783842506</span>;DBD;v4.<span class="keyword">get</span>;rwro.<span class="keyword">get</span>:<span class="number">5</span>;RS.dbs:<span class="number">5</span>;RS:<span class="number">6</span>;redis.s;redis.g;IO:<span class="number">42</span></span><br><span class="line">I/flutter ( <span class="number">5603</span>):  content-disposition: inline; filename=<span class="string">&quot;baomanwayong_04.jpg&quot;</span>; filename*=utf<span class="number">-8</span><span class="string">&#x27; &#x27;</span>baomanwayong_04.jpg</span><br><span class="line">I/flutter ( <span class="number">5603</span>):  accept-ranges: bytes</span><br><span class="line">I/flutter ( <span class="number">5603</span>):  content-length: <span class="number">151887</span></span><br><span class="line">I/flutter ( <span class="number">5603</span>):  etag: <span class="string">&quot;Fnlr7Ngb3uIdCjft615r4IJd6-BU&quot;</span></span><br><span class="line">I/flutter ( <span class="number">5603</span>):  x-qiniu-zone: <span class="number">0</span></span><br><span class="line">I/flutter ( <span class="number">5603</span>):  connection: keep-alive</span><br><span class="line">I/flutter ( <span class="number">5603</span>):  cache-control: max-age=<span class="number">2592000</span></span><br><span class="line">I/flutter ( <span class="number">5603</span>):  access-control-allow-origin: *</span><br><span class="line">I/flutter ( <span class="number">5603</span>):  age: <span class="number">304</span></span><br><span class="line">I/flutter ( <span class="number">5603</span>):  content-type: image/jpeg</span><br><span class="line">I/flutter ( <span class="number">5603</span>):  access-control-max-age: <span class="number">2592000</span></span><br><span class="line">I/flutter ( <span class="number">5603</span>):  x-source: C/<span class="number">200</span></span><br><span class="line">I/flutter ( <span class="number">5603</span>):  x-m-log: QNM:jjh1504;QNM3:<span class="number">80</span></span><br><span class="line">I/flutter ( <span class="number">5603</span>):  x-svr: IO</span><br><span class="line">I/flutter ( <span class="number">5603</span>):  content-transfer-encoding: binary</span><br><span class="line">I/flutter ( <span class="number">5603</span>):  via: S.mix-sd-dst1<span class="number">-081</span>, T<span class="number">.78</span>.M, V.mix-sd-dst1<span class="number">-078</span>, T<span class="number">.13</span>.H, M.ctn-js-taz1<span class="number">-015</span></span><br><span class="line">I/flutter ( <span class="number">5603</span>):  x-qnm-cache: Hit</span><br><span class="line">I/flutter ( <span class="number">5603</span>):  expires: Mon, <span class="number">01</span> Apr <span class="number">2019</span> <span class="number">07</span>:<span class="number">11</span>:<span class="number">57</span> G</span><br><span class="line">I/flutter ( <span class="number">5603</span>): </span><br><span class="line">I/flutter ( <span class="number">5603</span>): <span class="number">1</span>%</span><br><span class="line">I/flutter ( <span class="number">5603</span>): <span class="number">8</span>%</span><br><span class="line">I/flutter ( <span class="number">5603</span>): <span class="number">18</span>%</span><br><span class="line">I/flutter ( <span class="number">5603</span>): <span class="number">29</span>%</span><br><span class="line">I/flutter ( <span class="number">5603</span>): <span class="number">32</span>%</span><br><span class="line">I/flutter ( <span class="number">5603</span>): <span class="number">33</span>%</span><br><span class="line">I/flutter ( <span class="number">5603</span>): <span class="number">44</span>%</span><br><span class="line">I/flutter ( <span class="number">5603</span>): <span class="number">45</span>%</span><br><span class="line">I/flutter ( <span class="number">5603</span>): <span class="number">48</span>%</span><br><span class="line">I/flutter ( <span class="number">5603</span>): <span class="number">54</span>%</span><br><span class="line">I/flutter ( <span class="number">5603</span>): <span class="number">59</span>%</span><br><span class="line">I/flutter ( <span class="number">5603</span>): <span class="number">69</span>%</span><br><span class="line">I/flutter ( <span class="number">5603</span>): <span class="number">74</span>%</span><br><span class="line">I/flutter ( <span class="number">5603</span>): <span class="number">76</span>%</span><br><span class="line">I/flutter ( <span class="number">5603</span>): <span class="number">78</span>%</span><br><span class="line">I/flutter ( <span class="number">5603</span>): <span class="number">79</span>%</span><br><span class="line">I/flutter ( <span class="number">5603</span>): <span class="number">81</span>%</span><br><span class="line">I/flutter ( <span class="number">5603</span>): <span class="number">82</span>%</span><br><span class="line">I/flutter ( <span class="number">5603</span>): <span class="number">84</span>%</span><br><span class="line">I/flutter ( <span class="number">5603</span>): <span class="number">100</span>%</span><br><span class="line">I/flutter ( <span class="number">5603</span>): 下载完成</span><br></pre></td></tr></table></figure>
<p>dio.download()方法中提供了一个回调方法onReceiveProgress可以很好的跟踪下载的进度，方便做UI上的进度展示。</p>
<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>以上就是两种常用的Flutter网络请求库，Dio为我们封装了丰富的网络请求相关功能，所以Dio基本可以满足我们的日常开发需求，就不用再重复造轮子了。</p>
<h2 id="与Android交互"><a href="#与Android交互" class="headerlink" title="与Android交互"></a>与Android交互</h2><p>在开发中通常需要 Flutter 端与原生内容进行交互。Flutter 定义了三种不同的Channel，它们分别是</p>
<p>BasicMessageChannel：用于传递字符串和半结构化的信息<br>MethodChannel：用于传递方法调用<br>EventChannel：用于数据流的通信</p>
<h3 id="BasicMessageChannel"><a href="#BasicMessageChannel" class="headerlink" title="BasicMessageChannel"></a>BasicMessageChannel</h3><p>1.实现插件</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FlutterPluginBasicTest</span> <span class="keyword">implements</span> <span class="title">BasicMessageChannel</span>.<span class="title">MessageHandler</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    private <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">String</span> TAG = <span class="string">&quot;FlutterPluginBasicTest&quot;</span>;</span><br><span class="line">    public <span class="keyword">static</span> <span class="built_in">String</span> CHANNEL = <span class="string">&quot;com.mmd.flutterapp/plugin&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> BasicMessageChannel messageChannel;</span><br><span class="line"> </span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> registerWith(PluginRegistry.Registrar registrar) &#123;</span><br><span class="line">        messageChannel = <span class="keyword">new</span> BasicMessageChannel(registrar.messenger(),CHANNEL,StandardMessageCodec.INSTANCE);</span><br><span class="line">        FlutterPluginBasicTest flutterPluginBasicTest = <span class="keyword">new</span> FlutterPluginBasicTest();</span><br><span class="line">        messageChannel.setMessageHandler(flutterPluginBasicTest);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment"><span class="language-markdown">/<span class="strong">**</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment">     <span class="emphasis">* java 发起通信</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment">     *</span> @param string</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment">     <span class="emphasis">*/</span></span></span></span></span><br><span class="line">    <span class="keyword">void</span> sendMessage(<span class="built_in">String</span> string) &#123;</span><br><span class="line">        messageChannel.send(string, <span class="keyword">new</span> BasicMessageChannel.Reply() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            public <span class="keyword">void</span> reply(<span class="built_in">Object</span> o) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;reply: &quot;</span>+<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment"><span class="language-markdown"><span class="strong"><span class="emphasis">/*</span><span class="emphasis">*</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment">     *</span> Flutter 发起的通信</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment">     <span class="emphasis">* @param o</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment">     *</span> @param reply</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment">     <span class="emphasis">*/</span></span></span></span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public <span class="keyword">void</span> onMessage(<span class="built_in">Object</span> o, BasicMessageChannel.Reply reply) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onMessage: &quot;</span>+o);</span><br><span class="line">        reply.reply(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.注册</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.注册</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="language-markdown">/<span class="strong">**</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* 发送</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span>/</span></span></span></span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; sendMessage() <span class="keyword">async</span>&#123;</span><br><span class="line">  <span class="built_in">String</span> reply = <span class="keyword">await</span> messageChannel.send(<span class="string">&quot;Flutter send&quot;</span>);</span><br><span class="line">  <span class="built_in">print</span>(reply);</span><br><span class="line">  <span class="keyword">return</span> reply;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"><span class="language-markdown"><span class="strong">/**</span></span></span></span><br><span class="line"><span class="language-markdown"><span class="comment"><span class="bullet"> *</span> 接收</span></span></span><br><span class="line"><span class="language-markdown"><span class="comment"> <span class="emphasis">*/</span></span></span></span><br><span class="line"><span class="keyword">void</span> receiveMessage()&#123;</span><br><span class="line">  messageChannel.setMessageHandler((message) <span class="keyword">async</span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(message);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;is ok&quot;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MethodChannel"><a href="#MethodChannel" class="headerlink" title="MethodChannel"></a>MethodChannel</h3><p>flutter 调用 原生<br>1.实现插件</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FlutterPluginTest</span> <span class="keyword">implements</span> <span class="title">MethodChannel</span>.<span class="title">MethodCallHandler</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    private <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">String</span> TAG = <span class="string">&quot;FlutterPluginTest&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment"><span class="language-markdown">/<span class="strong">**</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment">     <span class="emphasis">* 插件标识</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment">     *</span>/</span></span></span></span><br><span class="line">    public <span class="keyword">static</span> <span class="built_in">String</span> CHANNEL = <span class="string">&quot;com.mmd.flutterapp/plugin&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    private <span class="keyword">static</span> <span class="built_in">String</span> ACTION_LOG = <span class="string">&quot;log&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    private <span class="keyword">static</span> <span class="built_in">String</span> LOG_ARGUMENT = <span class="string">&quot;data&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> MethodChannel channel;</span><br><span class="line"> </span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> registerWith(PluginRegistry.Registrar registrar) &#123;</span><br><span class="line">        channel = <span class="keyword">new</span> MethodChannel(registrar.messenger(), CHANNEL);</span><br><span class="line">        FlutterPluginTest instance = <span class="keyword">new</span> FlutterPluginTest();</span><br><span class="line">        channel.setMethodCallHandler(instance);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public <span class="keyword">void</span> onMethodCall(MethodCall methodCall, MethodChannel.Result result) &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment"><span class="language-markdown"><span class="strong">/**</span></span></span></span><br><span class="line"><span class="language-markdown"><span class="comment"><span class="bullet">         *</span> 通过 method 判断调用方法</span></span></span><br><span class="line"><span class="language-markdown"><span class="comment"><span class="code">         */</span></span></span></span><br><span class="line">        <span class="keyword">if</span> (methodCall.method.equals(ACTION_LOG)) &#123;</span><br><span class="line">            <span class="comment"><span class="language-markdown"><span class="code">/**</span></span></span></span><br><span class="line"><span class="code"><span class="language-markdown"><span class="comment">             * 解析参数</span></span></span></span><br><span class="line"><span class="code"><span class="language-markdown"><span class="comment">             */</span></span></span></span><br><span class="line">            <span class="built_in">String</span> text = methodCall.argument(LOG_ARGUMENT);</span><br><span class="line">            <span class="keyword">if</span> (TextUtils.isEmpty(text)) &#123;</span><br><span class="line">                <span class="comment"><span class="language-markdown"><span class="code">/**</span></span></span></span><br><span class="line"><span class="code"><span class="language-markdown"><span class="comment">                 * 错误返回</span></span></span></span><br><span class="line"><span class="code"><span class="language-markdown"><span class="comment">                 */</span></span></span></span><br><span class="line">                result.error(<span class="string">&quot;Data is Null&quot;</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;onMethodCall: &quot;</span>+text);</span><br><span class="line">                <span class="comment"><span class="language-markdown"><span class="code">/**</span></span></span></span><br><span class="line"><span class="code"><span class="language-markdown"><span class="comment">                 * 成功返回</span></span></span></span><br><span class="line"><span class="code"><span class="language-markdown"><span class="comment">                 */</span></span></span></span><br><span class="line">                result.success(<span class="string">&quot;is ok&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            result.notImplemented();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.注册插件</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">FlutterActivity</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  protected <span class="keyword">void</span> onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    <span class="comment"><span class="language-markdown">/<span class="strong">**</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment">     <span class="emphasis">* 注册插件</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment">     *</span>/</span></span></span></span><br><span class="line">    FlutterPluginTest.registerWith(<span class="keyword">this</span>.registrarFor(FlutterPluginTest.CHANNEL));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.Flutter 端调用</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/services.dart&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment"><span class="language-markdown">/<span class="strong">**</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* 名称要和Java端一致</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span>/</span></span></span></span><br><span class="line"><span class="keyword">const</span> channelName = <span class="string">&quot;com.mmd.flutterapp/plugin&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> methodName = <span class="string">&quot;log&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> MethodChannel channel = MethodChannel(channelName);</span><br><span class="line"> </span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; _testLog() <span class="keyword">async</span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">Map</span>&lt;<span class="built_in">String</span>,<span class="built_in">String</span>&gt; map = &#123;<span class="string">&quot;data&quot;</span>:<span class="string">&quot;Flutter Hello !&quot;</span>&#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">String</span> result = <span class="keyword">await</span> channel.invokeMethod(methodName,map);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="EventChannel"><a href="#EventChannel" class="headerlink" title="EventChannel"></a>EventChannel</h3><p>原生发送数据到Flutter<br>1.实现插件</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FlutterPluginEventTest</span> <span class="keyword">implements</span> <span class="title">EventChannel</span>.<span class="title">StreamHandler</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    private <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">String</span> TAG = <span class="string">&quot;FlutterPluginEventTest&quot;</span>;</span><br><span class="line">    public <span class="keyword">static</span> <span class="built_in">String</span> CHANNEL = <span class="string">&quot;com.mmd.flutterapp/plugin&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> EventChannel channel;</span><br><span class="line"> </span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> registerWith(PluginRegistry.Registrar registrar) &#123;</span><br><span class="line">        channel = <span class="keyword">new</span> EventChannel(registrar.messenger(), CHANNEL);</span><br><span class="line">        FlutterPluginEventTest flutterPluginEventTest = <span class="keyword">new</span> FlutterPluginEventTest();</span><br><span class="line">        channel.setStreamHandler(flutterPluginEventTest);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public <span class="keyword">void</span> onListen(<span class="built_in">Object</span> o, EventChannel.EventSink eventSink) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            public <span class="keyword">void</span> run() &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        eventSink.success(System.currentTimeMillis());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        eventSink.error(<span class="string">&quot;error&quot;</span>,<span class="string">&quot;error&quot;</span>,e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public <span class="keyword">void</span> onCancel(<span class="built_in">Object</span> o) &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onCancel: &quot;</span>+o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.注册插件</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FlutterPluginEventTest.registerWith(<span class="keyword">this</span>.registrarFor(FlutterPluginEventTest.CHANNEL));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3.Flutter 接收</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:async&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/services.dart&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment"><span class="language-markdown">/<span class="strong">**</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* 名称要和Java端一致</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span>/</span></span></span></span><br><span class="line"><span class="keyword">const</span> channelName = <span class="string">&quot;com.mmd.flutterapp/plugin&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> EventChannel eventChannel = EventChannel(channelName);</span><br><span class="line"> </span><br><span class="line">StreamSubscription _subcription = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> init(<span class="keyword">void</span> onEvent(<span class="built_in">String</span> value),<span class="built_in">Function</span> onError)&#123;</span><br><span class="line">  <span class="keyword">if</span>(_subcription == <span class="keyword">null</span>) &#123;</span><br><span class="line">    _subcription = eventChannel.receiveBroadcastStream().listen(onEvent,onError: onError);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> dispose()&#123;</span><br><span class="line">  <span class="keyword">if</span>(_subcription !=<span class="keyword">null</span>)&#123;</span><br><span class="line">    _subcription.cancel();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实战1Flutter-Gank"><a href="#实战1Flutter-Gank" class="headerlink" title="实战1Flutter_Gank"></a>实战1Flutter_Gank</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/AndroidAlvin/article/details/103489276">链接</a><br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607091148748.png" alt="Alt text"><br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607091151621.png" alt="Alt text"><br>没有设计，自己怎么想怎么弄的，调用了干活集中营的api，这个号称客户端最多的网站，由于已经过了两个多月才来写这篇博客，由于flutter的更新，现在最新的是6.0dev版本，可能会影响部分功能的使用，但应该不会有很大的改动，我就开发的过程谈谈，flutter的一些优缺点。</p>
<p>如果有面向对象的编程经验，入门还是很简单的，并且，官网也很细心的为我们讲解了一些概念，因为我是做android的我看得比较多的是这一篇flutter-for-android,还有针对于iOS devs，React Native devs，Xamarin.Forms devs，可以看出google的野心不小，不过我认为Flutter会降低移动端的开发成本，Flutter UI相比android原生更细腻一些，还原度会更高一些，毕竟做过android开发就知道碎片化的问题有多麻烦。<br>##实战2WanAndroid App<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/AndroidAlvin/article/details/103505500">链接</a><br>本项目包含启动页，引导页，主题色，国际化，Bloc，RxDart。拥有较好的项目结构，比较规范的代码。 App拥有精致的UI界面，统一的交互，侧滑退出，列表和Web界面均提供快速滚动至顶部功能(界面参考gitme)。<br>作者初衷是为大家提供一个比较规范的Flutter项目示例。<br>有关项目最新动态，可以关注App内第一条Hot Item信息。<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607091303081.png" alt="Alt text"><br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607091308432.png" alt="Alt text"><br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607091312307.png" alt="Alt text"><br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607091316222.png" alt="Alt text"><br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607091320290.png" alt="Alt text"><br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607091325040.png" alt="Alt text"><br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607091330591.png" alt="Alt text"><br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607091336768.png" alt="Alt text"><br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607091343437.png" alt="Alt text"></p>
<h2 id="图片加载原理与缓存"><a href="#图片加载原理与缓存" class="headerlink" title="图片加载原理与缓存"></a>图片加载原理与缓存</h2><p>在本书前面章节已经介绍过Image 组件，并提到Flutter框架对加载过的图片是有缓存的（内存），默认最大缓存数量是1000，最大缓存空间为100M。本节便详细介绍Image的原理及图片缓存机制，下面我们先看看ImageProvider 类。</p>
<h3 id="ImageProvider"><a href="#ImageProvider" class="headerlink" title="ImageProvider"></a>ImageProvider</h3><p>我们已经知道Image 组件的image 参数是一个必选参数，它是ImageProvider类型。下面我们便详细介绍一下ImageProvider，ImageProvider是一个抽象类，定义了图片数据获取和加载的相关接口。它的主要职责有两个：</p>
<ul>
<li>提供图片数据源</li>
<li>缓存图片<br>我们看看ImageProvider抽象类的详细定义：<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageProvider</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">  ImageStream resolve(ImageConfiguration configuration) &#123;</span><br><span class="line">    <span class="comment">// 实现代码省略</span></span><br><span class="line">  &#125;</span><br><span class="line">  Future&lt;<span class="built_in">bool</span>&gt; evict(&#123; ImageCache cache,</span><br><span class="line">                      ImageConfiguration configuration = ImageConfiguration.empty &#125;) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// 实现代码省略</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  Future&lt;T&gt; obtainKey(ImageConfiguration configuration); </span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  ImageStreamCompleter load(T key); <span class="comment">// 需子类实现</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
load(T key)方法<br>加载图片数据源的接口，不同的数据源的加载方法不同，每个ImageProvider的子类必须实现它。比如NetworkImage类和AssetImage类，它们都是ImageProvider的子类，但它们需要从不同的数据源来加载图片数据：NetworkImage是从网络来加载图片数据，而AssetImage则是从最终的应用包里来加载（加载打到应用安装包里的资源图片）。 我们以NetworkImage为例，看看其load方法的实现：<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">ImageStreamCompleter load(image_provider.NetworkImage key) &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">final</span> StreamController&lt;ImageChunkEvent&gt; chunkEvents = StreamController&lt;ImageChunkEvent&gt;();</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> MultiFrameImageStreamCompleter(</span><br><span class="line">    codec: _loadAsync(key, chunkEvents), <span class="comment">//调用</span></span><br><span class="line">    chunkEvents: chunkEvents.stream,</span><br><span class="line">    scale: key.scale,</span><br><span class="line">    ... <span class="comment">//省略无关代码</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
我们看到，load方法的返回值类型是ImageStreamCompleter ，它是一个抽象类，定义了管理图片加载过程的一些接口，Image Widget中正是通过它来监听图片加载状态的（我们将在下面介绍Image 原理时详细介绍）。</li>
</ul>
<p>MultiFrameImageStreamCompleter 是 ImageStreamCompleter的一个子类，是flutter sdk预置的类，通过该类，我们以方便、轻松地创建出一个ImageStreamCompleter实例来做为load方法的返回值。</p>
<p>我们可以看到，MultiFrameImageStreamCompleter 需要一个codec参数，该参数类型为Future&lt;ui.Codec&gt;。Codec 是处理图片编解码的类的一个handler，实际上，它只是一个flutter engine API 的包装类，也就是说图片的编解码逻辑不是在Dart 代码部分实现，而是在flutter engine中实现的。Codec类部分定义如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@pragma</span>(<span class="string">&#x27;vm:entry-point&#x27;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> <span class="keyword">extends</span> <span class="title">NativeFieldWrapperClass2</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 此类由flutter engine创建，不应该手动实例化此类或直接继承此类。</span></span><br><span class="line">  <span class="meta">@pragma</span>(<span class="string">&#x27;vm:entry-point&#x27;</span>)</span><br><span class="line">  Codec._();</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/// <span class="language-markdown">图片中的帧数(动态图会有多帧)</span></span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> frameCount native <span class="string">&#x27;Codec_frameCount&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/// <span class="language-markdown">动画重复的次数</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown"><span class="bullet">*</span> 0 表示只执行一次</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown"><span class="bullet">*</span> -1 表示循环执行</span></span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> repetitionCount native <span class="string">&#x27;Codec_repetitionCount&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/// <span class="language-markdown">获取下一个动画帧</span></span></span><br><span class="line">  Future&lt;FrameInfo&gt; getNextFrame() &#123;</span><br><span class="line">    <span class="keyword">return</span> _futurize(_getNextFrame);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">String</span> _getNextFrame(_Callback&lt;FrameInfo&gt; callback) native <span class="string">&#x27;Codec_getNextFrame&#x27;</span>;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>我们可以看到Codec最终的结果是一个或多个（动图）帧，而这些帧最终会绘制到屏幕上。</p>
<p>MultiFrameImageStreamCompleter 的 codec参数值为_loadAsync方法的返回值，我们继续看_loadAsync方法的实现：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Future&lt;ui.Codec&gt; _loadAsync(</span><br><span class="line">   NetworkImage key,</span><br><span class="line">   StreamController&lt;ImageChunkEvent&gt; chunkEvents,</span><br><span class="line"> ) <span class="keyword">async</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">//下载图片</span></span><br><span class="line">     <span class="keyword">final</span> <span class="built_in">Uri</span> resolved = <span class="built_in">Uri</span>.base.resolve(key.url);</span><br><span class="line">     <span class="keyword">final</span> HttpClientRequest request = <span class="keyword">await</span> _httpClient.getUrl(resolved);</span><br><span class="line">     headers?.forEach((<span class="built_in">String</span> name, <span class="built_in">String</span> value) &#123;</span><br><span class="line">       request.headers.add(name, value);</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="keyword">final</span> HttpClientResponse response = <span class="keyword">await</span> request.close();</span><br><span class="line">     <span class="keyword">if</span> (response.statusCode != HttpStatus.ok)</span><br><span class="line">       <span class="keyword">throw</span> Exception(...);</span><br><span class="line">     <span class="comment">// 接收图片数据 </span></span><br><span class="line">     <span class="keyword">final</span> Uint8List bytes = <span class="keyword">await</span> consolidateHttpClientResponseBytes(</span><br><span class="line">       response,</span><br><span class="line">       onBytesReceived: (<span class="built_in">int</span> cumulative, <span class="built_in">int</span> total) &#123;</span><br><span class="line">         chunkEvents.add(ImageChunkEvent(</span><br><span class="line">           cumulativeBytesLoaded: cumulative,</span><br><span class="line">           expectedTotalBytes: total,</span><br><span class="line">         ));</span><br><span class="line">       &#125;,</span><br><span class="line">     );</span><br><span class="line">     <span class="keyword">if</span> (bytes.lengthInBytes == <span class="number">0</span>)</span><br><span class="line">       <span class="keyword">throw</span> Exception(<span class="string">&#x27;NetworkImage is an empty file: <span class="subst">$resolved</span>&#x27;</span>);</span><br><span class="line">     <span class="comment">// 对图片数据进行解码</span></span><br><span class="line">     <span class="keyword">return</span> PaintingBinding.instance.instantiateImageCodec(bytes);</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     chunkEvents.close();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到_loadAsync方法主要做了两件事：</p>
<ul>
<li>下载图片。</li>
<li>对下载的图片数据进行解码。</li>
</ul>
<p>下载逻辑比较简单：通过HttpClient从网上下载图片，另外下载请求会设置一些自定义的header，开发者可以通过NetworkImage的headers命名参数来传递。</p>
<p>在图片下载完成后调用了PaintingBinding.instance.instantiateImageCodec(bytes)对图片进行解码，值得注意的是instantiateImageCodec(…)也是一个Native API的包装，实际上会调用Flutter engine的instantiateImageCodec方法，源码如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> _instantiateImageCodec(Uint8List list, _Callback&lt;Codec&gt; callback, _ImageInfo imageInfo, <span class="built_in">int</span> targetWidth, <span class="built_in">int</span> targetHeight)</span><br><span class="line">  native <span class="string">&#x27;instantiateImageCodec&#x27;</span>;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>obtainKey(ImageConfiguration)方法<br>该接口主要是为了配合实现图片缓存，ImageProvider从数据源加载完数据后，会在全局的ImageCache中缓存图片数据，而图片数据缓存是一个Map，而Map的key便是调用此方法的返回值，不同的key代表不同的图片数据缓存。</p>
<p>resolve(ImageConfiguration) 方法<br>resolve方法是ImageProvider的暴露的给Image的主入口方法，它接受一个ImageConfiguration参数，返回ImageStream，即图片数据流。我们重点看一下resolve执行流程：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">ImageStream resolve(ImageConfiguration configuration) &#123;</span><br><span class="line">  ... <span class="comment">//省略无关代码</span></span><br><span class="line">  <span class="keyword">final</span> ImageStream stream = ImageStream();</span><br><span class="line">  T obtainedKey; <span class="comment">//</span></span><br><span class="line">  <span class="comment">//定义错误处理函数</span></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; handleError(<span class="built_in">dynamic</span> exception, StackTrace stack) <span class="keyword">async</span> &#123;</span><br><span class="line">    ... <span class="comment">//省略无关代码</span></span><br><span class="line">    stream.setCompleter(imageCompleter);</span><br><span class="line">    imageCompleter.setError(...);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 创建一个新Zone，主要是为了当发生错误时不会干扰MainZone</span></span><br><span class="line">  <span class="keyword">final</span> Zone dangerZone = Zone.current.fork(...);</span><br><span class="line"> </span><br><span class="line">  dangerZone.runGuarded(() &#123;</span><br><span class="line">    Future&lt;T&gt; key;</span><br><span class="line">    <span class="comment">// 先验证是否已经有缓存</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 生成缓存key，后面会根据此key来检测是否有缓存</span></span><br><span class="line">      key = obtainKey(configuration);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error, stackTrace) &#123;</span><br><span class="line">      handleError(error, stackTrace);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    key.then&lt;<span class="keyword">void</span>&gt;((T key) &#123;</span><br><span class="line">      obtainedKey = key;</span><br><span class="line">      <span class="comment">// 缓存的处理逻辑在这里，记为A，下面详细介绍</span></span><br><span class="line">      <span class="keyword">final</span> ImageStreamCompleter completer = PaintingBinding.instance</span><br><span class="line">          .imageCache.putIfAbsent(key, () =&gt; load(key), onError: handleError);</span><br><span class="line">      <span class="keyword">if</span> (completer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stream.setCompleter(completer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).catchError(handleError);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>ImageConfiguration 包含图片和设备的相关信息，如图片的大小、所在的AssetBundle(只有打到安装包的图片存在)以及当前的设备平台、devicePixelRatio（设备像素比等）。Flutter SDK提供了一个便捷函数createLocalImageConfiguration来创建ImageConfiguration 对象：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ImageConfiguration createLocalImageConfiguration(BuildContext context, &#123; Size size &#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> ImageConfiguration(</span><br><span class="line">    bundle: DefaultAssetBundle.of(context),</span><br><span class="line">    devicePixelRatio: MediaQuery.of(context, nullOk: <span class="keyword">true</span>)?.devicePixelRatio ?? <span class="number">1.0</span>,</span><br><span class="line">    locale: Localizations.localeOf(context, nullOk: <span class="keyword">true</span>),</span><br><span class="line">    textDirection: Directionality.of(context),</span><br><span class="line">    size: size,</span><br><span class="line">    platform: defaultTargetPlatform,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>我们可以发现这些信息基本都是通过Context来获取。</p>
<p>上面代码A处就是处理缓存的主要代码，这里的PaintingBinding.instance.imageCache 是 ImageCache的一个实例，它是PaintingBinding的一个属性，而Flutter框架中的PaintingBinding.instance是一个单例，imageCache事实上也是一个单例，也就是说图片缓存是全局的，统一由PaintingBinding.instance.imageCache 来管理。</p>
<p>下面我们看看ImageCache类定义：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> _kDefaultSize = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> _kDefaultSizeBytes = <span class="number">100</span> &lt;&lt; <span class="number">20</span>; <span class="comment">// 100 MiB</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageCache</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 正在加载中的图片队列</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">Object</span>, _PendingImage&gt; _pendingImages = &lt;<span class="built_in">Object</span>, _PendingImage&gt;&#123;&#125;;</span><br><span class="line">  <span class="comment">// 缓存队列</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">Object</span>, _CachedImage&gt; _cache = &lt;<span class="built_in">Object</span>, _CachedImage&gt;&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 缓存数量上限(1000)</span></span><br><span class="line">  <span class="built_in">int</span> _maximumSize = _kDefaultSize;</span><br><span class="line">  <span class="comment">// 缓存容量上限 (100 MB)</span></span><br><span class="line">  <span class="built_in">int</span> _maximumSizeBytes = _kDefaultSizeBytes;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 缓存上限设置的setter</span></span><br><span class="line">  <span class="keyword">set</span> maximumSize(<span class="built_in">int</span> value) &#123;...&#125;</span><br><span class="line">  <span class="keyword">set</span> maximumSizeBytes(<span class="built_in">int</span> value) &#123;...&#125;</span><br><span class="line"> </span><br><span class="line">  ... <span class="comment">// 省略部分定义</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 清除所有缓存</span></span><br><span class="line">  <span class="keyword">void</span> clear() &#123;</span><br><span class="line">    <span class="comment">// ...省略具体实现代码</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 清除指定key对应的图片缓存</span></span><br><span class="line">  <span class="built_in">bool</span> evict(<span class="built_in">Object</span> key) &#123;</span><br><span class="line">   <span class="comment">// ...省略具体实现代码</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  ImageStreamCompleter putIfAbsent(<span class="built_in">Object</span> key, ImageStreamCompleter loader(), &#123; ImageErrorListener onError &#125;) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(key != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">assert</span>(loader != <span class="keyword">null</span>);</span><br><span class="line">    ImageStreamCompleter result = _pendingImages[key]?.completer;</span><br><span class="line">    <span class="comment">// 图片还未加载成功，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 有缓存，继续往下走</span></span><br><span class="line">    <span class="comment">// 先移除缓存，后再添加，可以让最新使用过的缓存在_map中的位置更近一些，清理时会LRU来清除</span></span><br><span class="line">    <span class="keyword">final</span> _CachedImage image = _cache.remove(key);</span><br><span class="line">    <span class="keyword">if</span> (image != <span class="keyword">null</span>) &#123;</span><br><span class="line">      _cache[key] = image;</span><br><span class="line">      <span class="keyword">return</span> image.completer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      result = loader();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error, stackTrace) &#123;</span><br><span class="line">      <span class="keyword">if</span> (onError != <span class="keyword">null</span>) &#123;</span><br><span class="line">        onError(error, stackTrace);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">rethrow</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> listener(ImageInfo info, <span class="built_in">bool</span> syncCall) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">int</span> imageSize = info?.image == <span class="keyword">null</span> ? <span class="number">0</span> : info.image.height * info.image.width * <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">final</span> _CachedImage image = _CachedImage(result, imageSize);</span><br><span class="line">      <span class="comment">// 下面是缓存处理的逻辑</span></span><br><span class="line">      <span class="keyword">if</span> (maximumSizeBytes &gt; <span class="number">0</span> &amp;&amp; imageSize &gt; maximumSizeBytes) &#123;</span><br><span class="line">        _maximumSizeBytes = imageSize + <span class="number">1000</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      _currentSizeBytes += imageSize;</span><br><span class="line">      <span class="keyword">final</span> _PendingImage pendingImage = _pendingImages.remove(key);</span><br><span class="line">      <span class="keyword">if</span> (pendingImage != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pendingImage.removeListener();</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      _cache[key] = image;</span><br><span class="line">      _checkCacheSize();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (maximumSize &gt; <span class="number">0</span> &amp;&amp; maximumSizeBytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> ImageStreamListener streamListener = ImageStreamListener(listener);</span><br><span class="line">      _pendingImages[key] = _PendingImage(result, streamListener);</span><br><span class="line">      <span class="comment">// Listener is removed in [_PendingImage.removeListener].</span></span><br><span class="line">      result.addListener(streamListener);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 当缓存数量超过最大值或缓存的大小超过最大缓存容量，会调用此方法清理到缓存上限以内</span></span><br><span class="line">  <span class="keyword">void</span> _checkCacheSize() &#123;</span><br><span class="line">   <span class="keyword">while</span> (_currentSizeBytes &gt; _maximumSizeBytes || _cache.length &gt; _maximumSize) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">Object</span> key = _cache.keys.first;</span><br><span class="line">      <span class="keyword">final</span> _CachedImage image = _cache[key];</span><br><span class="line">      _currentSizeBytes -= image.sizeBytes;</span><br><span class="line">      _cache.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line">    ... <span class="comment">//省略无关代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>有缓存则使用缓存，没有缓存则调用load方法加载图片，加载成功后:</p>
<p>先判断图片数据有没有缓存，如果有，则直接返回ImageStream。<br>如果没有缓存，则调用load(T key)方法从数据源加载图片数据，加载成功后先缓存，然后返回ImageStream。<br>另外，我们可以看到ImageCache类中有设置缓存上限的setter，所以，如果我们可以自定义缓存上限：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PaintingBinding.instance.imageCache.maximumSize=<span class="number">2000</span>; <span class="comment">//最多2000张</span></span><br><span class="line">PaintingBinding.instance.imageCache.maximumSizeBytes = <span class="number">200</span> &lt;&lt; <span class="number">20</span>; <span class="comment">//最大200M</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在我们看一下缓存的key，因为Map中相同key的值会被覆盖，也就是说key是图片缓存的一个唯一标识，只要是不同key，那么图片数据就会分别缓存（即使事实上是同一张图片）。那么图片的唯一标识是什么呢？跟踪源码，很容易发现key正是ImageProvider.obtainKey()方法的返回值，而此方法需要ImageProvider子类去重写，这也就意味着不同的ImageProvider对key的定义逻辑会不同。其实也很好理解，比如对于NetworkImage，将图片的url作为key会很合适，而对于AssetImage，则应该将“包名+路径”作为唯一的key。下面我们以NetworkImage为例，看一下它的obtainKey()实现：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Future&lt;NetworkImage&gt; obtainKey(image_provider.ImageConfiguration configuration) &#123;</span><br><span class="line">  <span class="keyword">return</span> SynchronousFuture&lt;NetworkImage&gt;(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>代码很简单，创建了一个同步的future，然后直接将自身做为key返回。因为Map中在判断key（此时是NetworkImage对象）是否相等时会使用“&#x3D;&#x3D;”运算符，那么定义key的逻辑就是NetworkImage的“&#x3D;&#x3D;”运算符：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="built_in">bool</span> <span class="keyword">operator</span> ==(<span class="built_in">dynamic</span> other) &#123;</span><br><span class="line">  ... <span class="comment">//省略无关代码</span></span><br><span class="line">  <span class="keyword">final</span> NetworkImage typedOther = other;</span><br><span class="line">  <span class="keyword">return</span> url == typedOther.url</span><br><span class="line">      &amp;&amp; scale == typedOther.scale;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>很清晰，对于网络图片来说，会将其“url+缩放比例”作为缓存的key。也就是说如果两张图片的url或scale只要有一个不同，便会重新下载并分别缓存。</p>
<p>另外，我们需要注意的是，图片缓存是在内存中，并没有进行本地文件持久化存储，这也是为什么网络图片在应用重启后需要重新联网下载的原因。</p>
<p>同时也意味着在应用生命周期内，如果缓存没有超过上限，相同的图片只会被下载一次。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>上面主要结合源码，探索了ImageProvider的主要功能和原理，如果要用一句话来总结ImageProvider功能，那么应该是：加载图片数据并进行缓存、解码。在此再次提醒读者，Flutter的源码是非常好的第一手资料，建议读者多多探索，另外，在阅读源码学习的同时一定要有总结，这样才不至于在源码中迷失。</p>
<h3 id="Image组件原理"><a href="#Image组件原理" class="headerlink" title="Image组件原理"></a>Image组件原理</h3><p>前面章节中我们介绍过Image的基础用法，现在我们更深入一些，研究一下Image是如何和ImageProvider配合来获取最终解码后的数据，然后又如何将图片绘制到屏幕上的。</p>
<p>本节换一个思路，我们先不去直接看Image的源码，而根据已经掌握的知识来实现一个简版的“Image组件” MyImage，代码大致如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyImage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> MyImage(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.imageProvider,</span><br><span class="line">  &#125;)</span><br><span class="line">      : <span class="keyword">assert</span>(imageProvider != <span class="keyword">null</span>),</span><br><span class="line">        <span class="keyword">super</span>(key: key);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">final</span> ImageProvider imageProvider;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _MyImageState createState() =&gt; _MyImageState();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyImageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyImage</span>&gt; </span>&#123;</span><br><span class="line">  ImageStream _imageStream;</span><br><span class="line">  ImageInfo _imageInfo;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didChangeDependencies() &#123;</span><br><span class="line">    <span class="keyword">super</span>.didChangeDependencies();</span><br><span class="line">    <span class="comment">// 依赖改变时，图片的配置信息可能会发生改变</span></span><br><span class="line">    _getImage();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didUpdateWidget(MyImage oldWidget) &#123;</span><br><span class="line">    <span class="keyword">super</span>.didUpdateWidget(oldWidget);</span><br><span class="line">    <span class="keyword">if</span> (widget.imageProvider != oldWidget.imageProvider)</span><br><span class="line">      _getImage();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">void</span> _getImage() &#123;</span><br><span class="line">    <span class="keyword">final</span> ImageStream oldImageStream = _imageStream;</span><br><span class="line">    <span class="comment">// 调用imageProvider.resolve方法，获得ImageStream。</span></span><br><span class="line">    _imageStream =</span><br><span class="line">        widget.imageProvider.resolve(createLocalImageConfiguration(context));</span><br><span class="line">    <span class="comment">//判断新旧ImageStream是否相同，如果不同，则需要调整流的监听器</span></span><br><span class="line">    <span class="keyword">if</span> (_imageStream.key != oldImageStream?.key) &#123;</span><br><span class="line">      <span class="keyword">final</span> ImageStreamListener listener = ImageStreamListener(_updateImage);</span><br><span class="line">      oldImageStream?.removeListener(listener);</span><br><span class="line">      _imageStream.addListener(listener);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">void</span> _updateImage(ImageInfo imageInfo, <span class="built_in">bool</span> synchronousCall) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      <span class="comment">// Trigger a build whenever the image changes.</span></span><br><span class="line">      _imageInfo = imageInfo;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    _imageStream.removeListener(ImageStreamListener(_updateImage));</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> RawImage(</span><br><span class="line">      image: _imageInfo?.image, <span class="comment">// this is a dart:ui Image object</span></span><br><span class="line">      scale: _imageInfo?.scale ?? <span class="number">1.0</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>上面代码流程如下：</p>
<ul>
<li>通过imageProvider.resolve方法可以得到一个ImageStream（图片数据流），然后监听ImageStream的变化。当图片数据源发生变化时，ImageStream会触发相应的事件，而本例中我们只设置了图片成功的监听器_updateImage，而_updateImage中只更新了_imageInfo。值得注意的是，如果是静态图，ImageStream只会触发一次时间，如果是动态图，则会触发多次事件，每一次都会有一个解码后的图片帧。</li>
<li>_imageInfo 更新后会rebuild，此时会创建一个RawImage Widget。RawImage最终会通过RenderImage来将图片绘制在屏幕上。如果继续跟进RenderImage类，我们会发现RenderImage的paint 方法中调用了paintImage方法，而paintImage方法中通过Canvas的drawImageRect(…)、drawImageNine(…)等方法来完成最终的绘制。</li>
<li>最终的绘制由RawImage来完成。</li>
</ul>
<p>下面测试一下MyImage：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageInternalTestRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Column(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        MyImage(</span><br><span class="line">          imageProvider: NetworkImage(</span><br><span class="line">            <span class="string">&quot;https://avatars2.githubusercontent.com/u/20411648?s=460&amp;v=4&quot;</span>,</span><br><span class="line">          ),</span><br><span class="line">        )</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/flutter/.1607092852044.png" alt="Alt text"><br>成功了！ 现在，想必Image Widget的源码已经没必要在花费篇章去介绍了，读者有兴趣可以自行去阅读。</p>
<p>总结<br>本节主要介绍了Flutter 图片的加载、缓存和绘制流程。其中ImageProvider主要负责图片数据的加载和缓存，而绘制部分逻辑主要是由RawImage来完成。 而Image正是连接起ImageProvider和RawImage 的桥梁。</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>王水泥</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://king-of-cement.gitee.io/blog/post/Android-%E5%91%A8%E8%BE%B9/Flutter/">http://king-of-cement.gitee.io/blog/post/Android-%E5%91%A8%E8%BE%B9/Flutter/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/flutter/"># flutter</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/post/Android/Android%20VM%20apk%20or%20dex%20%E4%BF%AE%E6%94%B9/">Android VM apk\dex 修改</a>
            
            
            <a class="next" rel="next" href="/post/Android/Android-RxJava%20&%20ioC%20DI%20&%20AOP/">Android-RxJava & ioC DI & AOP</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 王水泥 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>
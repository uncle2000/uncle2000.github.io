<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="王水泥">


    <meta name="subtitle" content="技术，etc">


    <meta name="description" content="不要传播">



<title>Android-RxJava &amp; ioC DI &amp; AOP | 王水泥个人博客</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    




<meta name="generator" content="Hexo 5.4.2"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">王水泥的博客</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">王水泥的博客</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Android-RxJava &amp; ioC DI &amp; AOP</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">王水泥</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">十一月 1, 2022&nbsp;&nbsp;16:23:33</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Android/">Android</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="Android-RxJava-amp-ioC-DI-amp-AOP"><a href="#Android-RxJava-amp-ioC-DI-amp-AOP" class="headerlink" title="Android-RxJava &amp; ioC DI &amp; AOP"></a>Android-RxJava &amp; ioC DI &amp; AOP</h1><p>[toc]</p>
<h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    Observable.just(<span class="string">&quot;a&quot;</span>)     <span class="comment">//Observable1</span></span><br><span class="line">            .map(<span class="keyword">new</span> <span class="title class_">Func1</span>&lt;String, String&gt;() &#123;  <span class="comment">//Observable2   </span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                    System.out.print(Thread.currentThread().getName() + <span class="string">&quot;:first--&quot;</span> + s +<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> s + s;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .subscribe(<span class="keyword">new</span> <span class="title class_">Subscriber</span>&lt;String&gt;() &#123; <span class="comment">//代码⑥ Subscriber</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompleted</span><span class="params">()</span> &#123;</span><br><span class="line">                    System.out.print(Thread.currentThread().getName()+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                    System.out.print(<span class="string">&quot;completed&quot;</span>+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                    System.out.println(s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先说说自己的理解，若把整个链条看成一个整体对象，那么just创建被观察者对象，而subscribe()里的Subscriber作为观察者；若每一步都分开看，just()和subscribe()中间的操作符即是观察者，又是被观察者。</p>
<p>Observable中每个操作符基本都会创建出一个新的Observable；因此可以解理成后一级的操作符去观察前一个Observable对象；以上例来说，.subscribe的Subscriber所观察的对象就是.map返回的Observable2，而.map的Subscriber所观察的对象就是 Observable.just(“a”)得到的对象Observable1；</p>
<p>下面介绍实现代码，整个链式调用真正开始的地方是.subscribe()，我们就从这里开始。省略掉一些代码，只看关键部分如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; Subscription <span class="title function_">subscribe</span><span class="params">(Subscriber&lt;? <span class="built_in">super</span> T&gt; subscriber, Observable&lt;T&gt; observable)</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// allow the hook to intercept and/or decorate</span></span><br><span class="line">            hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber); <span class="comment">//代码①</span></span><br><span class="line">            <span class="keyword">return</span> hook.onSubscribeReturn(subscriber);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hook.onSubscribeStart(observable, observable.onSubscribe)得到的对象就是observable.onSubscribe，而此处的observable明显就是this，也就是上例中的observable2对象，即把subscriber传入到了observable2里面以供其调用。</p>
<p>再跟着代码进入observable2（.map操作符）的实现。其主要实现是lift和OperatorMap。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; Observable&lt;R&gt; <span class="title function_">map</span><span class="params">(Func1&lt;? <span class="built_in">super</span> T, ? extends R&gt; func)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> lift(<span class="keyword">new</span> <span class="title class_">OperatorMap</span>&lt;T, R&gt;(func));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lift和OperatorMap各自干了什么事情呢？先看OperatorMap，Func1也作为构造参数传入。关键代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Subscriber&lt;? <span class="built_in">super</span> T&gt; call(<span class="keyword">final</span> Subscriber&lt;? <span class="built_in">super</span> R&gt; o) &#123;  <span class="comment">//代码②</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Subscriber</span>&lt;T&gt;(o) &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompleted</span><span class="params">()</span> &#123;</span><br><span class="line">            o.onCompleted();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">            o.onError(e);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(T t)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                o.onNext(transformer.call(t));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                Exceptions.throwOrReport(e, <span class="built_in">this</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里new出了一个观察者对象Subscriber，它实现了什么功能通过 o.onNext(transformer.call(t));即将例子中的Func1代码执行后将结果传入到下一层。即这里运行了Func1的代码。</p>
<p>再看lift()操作符，看其返回值也就是我们定义的observable2对象。因此subscribe里的”代码①”的call即是此处observable2里OnSubscribe的call方法；再看call方法，“代码④”部分则是调用到了observable1对象里OnSubscribe的call方法，而“代码③”将Func1操作动作转变为Subscriber，通过call(o)完成对下一级Subscriber的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; Observable&lt;R&gt; <span class="title function_">lift</span><span class="params">(<span class="keyword">final</span> Operator&lt;? extends R, ? <span class="built_in">super</span> T&gt; operator)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Observable</span>&lt;R&gt;(<span class="keyword">new</span> <span class="title class_">OnSubscribe</span>&lt;R&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">(Subscriber&lt;? <span class="built_in">super</span> R&gt; o)</span> &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Subscriber&lt;? <span class="built_in">super</span> T&gt; st = hook.onLift(operator).call(o); <span class="comment">//代码③</span></span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="comment">// new Subscriber created and being subscribed with so &#x27;onStart&#x27; it</span></span><br><span class="line">                       st.onStart();</span><br><span class="line">                       onSubscribe.call(st);  <span class="comment">//代码④</span></span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                       <span class="comment">// localized capture of errors rather than it skipping all operators </span></span><br><span class="line">                       <span class="comment">// and ending up in the try/catch of the subscribe method which then</span></span><br><span class="line">                       <span class="comment">// prevents onErrorResumeNext and other similar approaches to error handling</span></span><br><span class="line">                       Exceptions.throwIfFatal(e);</span><br><span class="line">                       st.onError(e);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                   Exceptions.throwIfFatal(e);</span><br><span class="line">                   <span class="comment">// if the lift function failed all we can do is pass the error to the final Subscriber</span></span><br><span class="line">                   <span class="comment">// as we don&#x27;t have the operator available to us</span></span><br><span class="line">                   o.onError(e);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>到这里“代码④”执行，即到了observable1对象，也就是例子中 Observable.just(“a”)所得到对象的OnSubscribe的call()方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> &lt;T&gt; Observable&lt;T&gt; <span class="title function_">just</span><span class="params">(<span class="keyword">final</span> T value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ScalarSynchronousObservable.create(value);</span><br><span class="line">    &#125;</span><br><span class="line">ScalarSynchronousObservable类代码如下：</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> &lt;T&gt; ScalarSynchronousObservable&lt;T&gt; <span class="title function_">create</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScalarSynchronousObservable</span>&lt;T&gt;(t);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">protected</span> <span class="title function_">ScalarSynchronousObservable</span><span class="params">(<span class="keyword">final</span> T t)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">OnSubscribe</span>&lt;T&gt;() &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">(Subscriber&lt;? <span class="built_in">super</span> T&gt; s)</span> &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 *  We don&#x27;t check isUnsubscribed as it is a significant performance impact in the fast-path use cases.</span></span><br><span class="line"><span class="comment">                 *  See PerfBaseline tests and https://github.com/ReactiveX/RxJava/issues/1383 for more information.</span></span><br><span class="line"><span class="comment">                 *  The assumption here is that when asking for a single item we should emit it and not concern ourselves with </span></span><br><span class="line"><span class="comment">                 *  being unsubscribed already. If the Subscriber unsubscribes at 0, they shouldn&#x27;t have subscribed, or it will </span></span><br><span class="line"><span class="comment">                 *  filter it out (such as take(0)). This prevents us from paying the price on every subscription. </span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                s.onNext(t);  <span class="comment">//代码⑤</span></span><br><span class="line">                s.onCompleted();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其中”代码⑤”是关键点，t即是我们just传入的”a”,s则是代码④传入的st，它其实是observable2的Subscriber(观察者)，相当于observable1持有observable2的引用。通过 s.onNext(t)，完成了observable1向下一层的observable2的回调，也就是Func1对象所在的Subscriber(OperatorMap)，再通过 o.onNext(transformer.call(t));回到例子中“代码⑥”，至此，整个调用链完成。</p>
<p>上面的分析比较混乱，重新梳理代码执行流程 ：<br>1、subscribe里，hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber); &#x2F;&#x2F;代码①<br>2、map里，通过lift(）将Func1操作符生成Subserber，Subscriber&lt;? super T&gt; st &#x3D; hook.onLift(operator).call(o); &#x2F;&#x2F;代码③<br>onSubscribe.call(st); &#x2F;&#x2F;代码④<br>3、just里create()， s.onNext(t); &#x2F;&#x2F;代码⑤<br>4、map里， OperatorMap里对象， o.onNext(transformer.call(t));<br>5、subscribe 的Subscriber（）;</p>
<p>Observable的所有链式调用，知道两个其两个关键点即可梳理清楚整个数据流传递原理；</p>
<p>Observable.onSubscribe对象，完成以call方法来向上一层传递；<br>Subserber向下一层的Subserber调用；</p>
<h2 id="RxJava-的观察者模式"><a href="#RxJava-的观察者模式" class="headerlink" title="RxJava 的观察者模式"></a>RxJava 的观察者模式</h2><p>Observable (可观察者，即被观察者)<br>Observer (观察者)<br>subscribe (订阅)<br>事件<br>Observable 和 Observer 通过 subscribe() 方法实现订阅关系，从而 Observable 可以在需要的时候发出事件来通知 Observer</p>
<p>Android 常见的观察者模式：</p>
<p><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/android/.1606924105657.png" alt="Alt text"></p>
<p>与传统观察者模式不同， RxJava 的事件回调方法除了普通事件 onNext() （相当于 onClick() &#x2F; onEvent()）之外，还定义了两个特殊的事件：onCompleted() 和 onError()</p>
<p>onCompleted()：事件队列完结。RxJava 不仅把每个事件单独处理，还会把它们看做一个队列。RxJava 规定，当不会再有新的 onNext() 发出时，需要触发 onCompleted() 方法作为标志</p>
<p>onError()：事件队列异常。在事件处理过程中出异常时，onError() 会被触发，同时队列自动终止，不允许再有事件发出</p>
<p>在一个正确运行的事件序列中, onCompleted() 和 onError() 有且只有一个，并且是事件序列中的最后一个。需要注意的是，onCompleted() 和 onError() 二者也是互斥的，即在队列中调用了其中一个，就不应该再调用另一个。</p>
<ol start="2">
<li>扩展的观察者模式<br>Observable 和 Observer 通过 subscribe() 方法实现订阅关系<br>RxJava 的事件回调方法 onNext() 、onCompleted() 和 onError()<br>如果一个Observable 中没有任何的 Observer ，那么这个Observable是不会发出任何事件的<br>第三点说明：</li>
</ol>
<p>在RxJava 中 Obseravable 有两种启动方式：热启动 和 冷启动</p>
<p>热启动 Obseravable在任何时候都会发送消息，即使没有任何观察者监听它<br>冷启动 Obseravable只有在至少有一个监听者时才会发送消息<br>热启动平时用不到，所以我们工作中用到的都是冷启动。</p>
<p><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/android/.1606924136437.png" alt="Alt text"></p>
<ol start="3">
<li>RxJava 的实现和使用<br>RxJava的实现主要有如下三步：</li>
</ol>
<p>第一步：创建观察者Observer。</p>
<p>Observer 即观察者，它决定事件触发的时候将有怎样的行为。注意:Observer是 个接口。<br>第二步：创建被观察者Observable。</p>
<p>第三步：Subscribe(订阅)（被观察者Observable订阅观察者Observer，注意：不同于普通观察者，这里是被观察者订阅观察者）。</p>
<p>创建 Observable 和 Observer 之后，再 subscribe() 法将它们联结起来，整条链子就可以 作 。代码形式很简单:</p>
<p><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/android/.1606924146108.png" alt="Alt text"></p>
<p>所以贴出之前实现过的代码：</p>
<p><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/android/.1606924151422.png" alt="Alt text"></p>
<p>编译运行：<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/android/.1606924157635.png" alt="Alt text"></p>
<p>这时制造一个异常再看下输出：</p>
<p><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/android/.1606924172114.png" alt="Alt text"></p>
<p>编译运行：<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/android/.1606924180248.png" alt="Alt text"></p>
<p>从打印中可以看出，onError()和onCompleted()是不共戴天滴。<br>除 Observer 接口之外，RxJava 还内置了一个实现 Observer 的抽象类:Subscriber(发 [səb’skraɪbɚ])。 Subscriber 对 Observer 接口进行了一些扩展，但他们的基本使用方式是完全一样的:<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/android/.1606924190151.png" alt="Alt text"></p>
<p>编译运行：<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/android/.1606924196084.png" alt="Alt text"></p>
<p>那既然观察者有两个：Observer和Subscriber，那这两者有啥区别呢？当然是有区别滴，不过在未来会进行学习，这里先有个印象。<br>另外在Rxjava中，如果对于事件回调中，只想要onNext()方法，onError()和onCompleted()都不需要，有木有简化方案呢？当然有：<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/android/.1606924203238.png" alt="Alt text"></p>
<p>而之前我们创建Observable是通过它：<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/android/.1606924211642.png" alt="Alt text"></p>
<p>所以简化版采用just操作符来，如下：<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/android/.1606924220722.png" alt="Alt text"></p>
<p>编译运行：<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/android/.1606924226425.png" alt="Alt text"></p>
<p>下面改用Action1类来达到我们所要的需求：<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/android/.1606924235948.png" alt="Alt text"></p>
<p>编译运行：<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/android/.1606924241201.png" alt="Alt text"></p>
<p>但是，官方并不推荐使用该类来简化操作，因为Action1并不支持背压(BackPressure)，而产生的大至原因是由于Rxjava的事件产生过快时导致。<br>##变换<br>RxJava 提供了对事件序列进行变换的支持，这是它的核心功能之一，也是大多数人说『RxJava 真是太好用了』的最大原因。所谓变换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。概念说着总是模糊难懂的，来看 API。</p>
<ol>
<li>API<br>首先看一个 map() 的例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">&quot;images/logo.png&quot;</span>) <span class="comment">// 输入类型 String</span></span><br><span class="line">    .map(<span class="keyword">new</span> <span class="title class_">Func1</span>&lt;String, Bitmap&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Bitmap <span class="title function_">call</span><span class="params">(String filePath)</span> &#123; <span class="comment">// 参数类型 String</span></span><br><span class="line">            <span class="keyword">return</span> getBitmapFromPath(filePath); <span class="comment">// 返回类型 Bitmap</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> <span class="title class_">Action1</span>&lt;Bitmap&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">(Bitmap bitmap)</span> &#123; <span class="comment">// 参数类型 Bitmap</span></span><br><span class="line">            showBitmap(bitmap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
这里出现了一个叫做 Func1 的类。它和 Action1 非常相似，也是 RxJava 的一个接口，用于包装含有一个参数的方法。 Func1 和 Action 的区别在于， Func1 包装的是有返回值的方法。另外，和 ActionX 一样， FuncX 也有多个，用于不同参数个数的方法。FuncX和 ActionX 的区别在 FuncX 包装的是有返回值的方法。</li>
</ol>
<p>可以看到，map() 方法将参数中的 String 对象转换成一个 Bitmap 对象后返回，而在经过 map() 方法后，事件的参数类型也由 String转为了 Bitmap。这种直接变换对象并返回的，是最常见的也最容易理解的变换。不过 RxJava 的变换远不止这样，它不仅可以针对事件对象，还可以针对整个事件队列，这使得 RxJava 变得非常灵活。我列举几个常用的变换：</p>
<ul>
<li>map(): 事件对象的直接变换，具体功能上面已经介绍过。它是 RxJava 最常用的变换。 map() 的示意图：<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/android/.1606924285801.png" alt="Alt text"></li>
<li>flatMap(): 这是一个很有用但非常难理解的变换，因此我决定花多些篇幅来介绍它。 首先假设这么一种需求：假设有一个数据结构『学生』，现在需要打印出一组学生的名字。实现方式很简单：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Student[] students = ...;</span><br><span class="line">Subscriber&lt;String&gt; subscriber = <span class="keyword">new</span> <span class="title class_">Subscriber</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        Log.d(tag, name);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Observable.from(students)</span><br><span class="line">    .map(<span class="keyword">new</span> <span class="title class_">Func1</span>&lt;Student, String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> student.getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(subscriber);</span><br></pre></td></tr></table></figure>
很简单。那么再假设：如果要打印出每个学生所需要修的所有课程的名称呢？（需求的区别在于，每个学生只有一个名字，但却有多个课程。）首先可以这样实现：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Student[] students = ...;</span><br><span class="line">Subscriber&lt;Student&gt; subscriber = <span class="keyword">new</span> <span class="title class_">Subscriber</span>&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">        List&lt;Course&gt; courses = student.getCourses();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; courses.size(); i++) &#123;</span><br><span class="line">            <span class="type">Course</span> <span class="variable">course</span> <span class="operator">=</span> courses.get(i);</span><br><span class="line">            Log.d(tag, course.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Observable.from(students)</span><br><span class="line">    .subscribe(subscriber);</span><br></pre></td></tr></table></figure>
依然很简单。那么如果我不想在 Subscriber 中使用 for 循环，而是希望 Subscriber 中直接传入单个的 Course 对象呢（这对于代码复用很重要）？用 map() 显然是不行的，因为 map() 是一对一的转化，而我现在的要求是一对多的转化。那怎么才能把一个 Student 转化成多个 Course 呢？</li>
</ul>
<p>这个时候，就需要用 flatMap() 了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Student[] students = ...;</span><br><span class="line">Subscriber&lt;Course&gt; subscriber = <span class="keyword">new</span> <span class="title class_">Subscriber</span>&lt;Course&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(Course course)</span> &#123;</span><br><span class="line">        Log.d(tag, course.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Observable.from(students)</span><br><span class="line">    .flatMap(<span class="keyword">new</span> <span class="title class_">Func1</span>&lt;Student, Observable&lt;Course&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Observable&lt;Course&gt; <span class="title function_">call</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Observable.from(student.getCourses());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(subscriber);</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出， flatMap() 和 map() 有一个相同点：它也是把传入的参数转化之后返回另一个对象。但需要注意，和 map()不同的是， flatMap() 中返回的是个 Observable 对象，并且这个 Observable 对象并不是被直接发送到了 Subscriber 的回调方法中。 flatMap() 的原理是这样的：1. 使用传入的事件对象创建一个 Observable 对象；2. 并不发送这个 Observable, 而是将它激活，于是它开始发送事件；3. 每一个创建出来的 Observable 发送的事件，都被汇入同一个 Observable ，而这个 Observable 负责将这些事件统一交给 Subscriber 的回调方法。这三个步骤，把事件拆成了两级，通过一组新创建的 Observable 将初始的对象『铺平』之后通过统一路径分发了下去。而这个『铺平』就是 flatMap() 所谓的 flat。</p>
<p>flatMap() 示意图：<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/android/.1606924340748.png" alt="Alt text"><br>flatMap() 示意图<br>扩展：由于可以在嵌套的 Observable 中添加异步代码， flatMap() 也常用于嵌套的异步操作，例如嵌套的网络请求。示例代码（Retrofit + RxJava）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">networkClient.token() <span class="comment">// 返回 Observable&lt;String&gt;，在订阅时请求 token，并在响应后发送 token</span></span><br><span class="line">    .flatMap(<span class="keyword">new</span> <span class="title class_">Func1</span>&lt;String, Observable&lt;Messages&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Observable&lt;Messages&gt; <span class="title function_">call</span><span class="params">(String token)</span> &#123;</span><br><span class="line">            <span class="comment">// 返回 Observable&lt;Messages&gt;，在订阅时请求消息列表，并在响应后发送请求到的消息列表</span></span><br><span class="line">            <span class="keyword">return</span> networkClient.messages();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> <span class="title class_">Action1</span>&lt;Messages&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">(Messages messages)</span> &#123;</span><br><span class="line">            <span class="comment">// 处理显示消息列表</span></span><br><span class="line">            showMessages(messages);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>传统的嵌套请求需要使用嵌套的 Callback 来实现。而通过 flatMap() ，可以把嵌套的请求写在一条链中，从而保持程序逻辑的清晰。</p>
<p>throttleFirst(): 在每次事件触发后的一定时间间隔内丢弃新的事件。常用作去抖动过滤，例如按钮的点击监听器：RxView.clickEvents(button) &#x2F;&#x2F; RxBinding 代码，后面的文章有解释 .throttleFirst(500, TimeUnit.MILLISECONDS) &#x2F;&#x2F; 设置防抖间隔为 500ms .subscribe(subscriber);妈妈再也不怕我的用户手抖点开两个重复的界面啦。<br>此外， RxJava 还提供很多便捷的方法来实现事件序列的变换，这里就不一一举例了。</p>
<ol start="2">
<li>变换的原理：lift()<br>这些变换虽然功能各有不同，但实质上都是针对事件序列的处理和再发送。而在 RxJava 的内部，它们是基于同一个基础的变换方法： lift(Operator)。首先看一下 lift() 的内部实现（仅核心代码）：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：这不是 lift() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。</span></span><br><span class="line"><span class="comment">// 如果需要看源码，可以去 RxJava 的 GitHub 仓库下载。</span></span><br><span class="line"><span class="keyword">public</span> &lt;R&gt; Observable&lt;R&gt; <span class="title function_">lift</span><span class="params">(Operator&lt;? extends R, ? <span class="built_in">super</span> T&gt; operator)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.create(<span class="keyword">new</span> <span class="title class_">OnSubscribe</span>&lt;R&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">(Subscriber subscriber)</span> &#123;</span><br><span class="line">            <span class="type">Subscriber</span> <span class="variable">newSubscriber</span> <span class="operator">=</span> operator.call(subscriber);</span><br><span class="line">            newSubscriber.onStart();</span><br><span class="line">            onSubscribe.call(newSubscriber);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这段代码很有意思：它生成了一个新的 Observable 并返回，而且创建新 Observable 所用的参数 OnSubscribe 的回调方法 call() 中的实现竟然看起来和前面讲过的 Observable.subscribe() 一样！然而它们并不一样哟~不一样的地方关键就在于第二行 onSubscribe.call(subscriber) 中的 onSubscribe 所指代的对象不同（高能预警：接下来的几句话可能会导致身体的严重不适）——</li>
</ol>
<ul>
<li>subscribe() 中这句话的 onSubscribe 指的是 Observable 中的 onSubscribe 对象，这个没有问题，但是 lift() 之后的情况就复杂了点。</li>
<li>当含有 lift() 时：<br>1.lift() 创建了一个 Observable 后，加上之前的原始 Observable，已经有两个 Observable 了；<br>2.而同样地，新 Observable 里的新 OnSubscribe 加上之前的原始 Observable 中的原始 OnSubscribe，也就有了两个 OnSubscribe；<br>3.当用户调用经过 lift() 后的 Observable 的 subscribe() 的时候，使用的是 lift() 所返回的新的 Observable ，于是它所触发的 onSubscribe.call(subscriber)，也是用的新 Observable 中的新 OnSubscribe，即在 lift() 中生成的那个 OnSubscribe；<br>4.而这个新 OnSubscribe 的 call() 方法中的 onSubscribe ，就是指的原始 Observable 中的原始 OnSubscribe ，在这个 call()方法里，新 OnSubscribe 利用 operator.call(subscriber) 生成了一个新的 Subscriber（Operator 就是在这里，通过自己的 call() 方法将新 Subscriber 和原始 Subscriber 进行关联，并插入自己的『变换』代码以实现变换），然后利用这个新 Subscriber 向原始 Observable 进行订阅。</li>
</ul>
<p>这样就实现了 lift() 过程，有点像一种代理机制，通过事件拦截和处理实现事件序列的变换。<br>精简掉细节的话，也可以这么说：在 Observable 执行了 lift(Operator) 方法之后，会返回一个新的 Observable，这个新的 Observable 会像一个代理一样，负责接收原始的 Observable 发出的事件，并在处理后发送给 Subscriber。</p>
<p>如果你更喜欢具象思维，可以看图：<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/android/.1606924400067.png" alt="Alt text"><br><image><a target="_blank" rel="noopener" href="https://ss.csdn.net/p?https://upload-images.jianshu.io/upload_images/19956127-8f0a34dc10d694f4.gif">https://ss.csdn.net/p?https://upload-images.jianshu.io/upload_images/19956127-8f0a34dc10d694f4.gif</a></image><br>lift 原理动图<br>两次和多次的 lift() 同理，如下图：<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/android/.1606924459831.png" alt="Alt text"><br>两次 lift<br>举一个具体的 Operator 的实现。下面这是一个将事件中的 Integer 对象转换成 String 的例子，仅供参考：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">observable.lift(<span class="keyword">new</span> <span class="title class_">Observable</span>.Operator&lt;String, Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Subscriber&lt;? <span class="built_in">super</span> Integer&gt; call(<span class="keyword">final</span> Subscriber&lt;? <span class="built_in">super</span> String&gt; subscriber) &#123;</span><br><span class="line">        <span class="comment">// 将事件序列中的 Integer 对象转换为 String 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Subscriber</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(Integer integer)</span> &#123;</span><br><span class="line">                subscriber.onNext(<span class="string">&quot;&quot;</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompleted</span><span class="params">()</span> &#123;</span><br><span class="line">                subscriber.onCompleted();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">                subscriber.onError(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>讲述 lift() 的原理只是为了让你更好地了解 RxJava ，从而可以更好地使用它。然而不管你是否理解了 lift() 的原理，RxJava 都不建议开发者自定义 Operator 来直接使用 lift()，而是建议尽量使用已有的 lift() 包装方法（如 map() flatMap() 等）进行组合来实现需求，因为直接使用 lift() 非常容易发生一些难以发现的错误。</p>
</blockquote>
<ol start="3">
<li>compose: 对 Observable 整体的变换<br>除了 lift() 之外， Observable 还有一个变换方法叫做 compose(Transformer)。它和 lift() 的区别在于， lift() 是针对事件项和事件序列的，而 compose() 是针对 Observable 自身进行变换。举个例子，假设在程序中有多个 Observable ，并且他们都需要应用一组相同的 lift() 变换。你可以这么写：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">observable1</span><br><span class="line">    .lift1()</span><br><span class="line">    .lift2()</span><br><span class="line">    .lift3()</span><br><span class="line">    .lift4()</span><br><span class="line">    .subscribe(subscriber1);</span><br><span class="line">observable2</span><br><span class="line">    .lift1()</span><br><span class="line">    .lift2()</span><br><span class="line">    .lift3()</span><br><span class="line">    .lift4()</span><br><span class="line">    .subscribe(subscriber2);</span><br><span class="line">observable3</span><br><span class="line">    .lift1()</span><br><span class="line">    .lift2()</span><br><span class="line">    .lift3()</span><br><span class="line">    .lift4()</span><br><span class="line">    .subscribe(subscriber3);</span><br><span class="line">observable4</span><br><span class="line">    .lift1()</span><br><span class="line">    .lift2()</span><br><span class="line">    .lift3()</span><br><span class="line">    .lift4()</span><br><span class="line">    .subscribe(subscriber1);</span><br></pre></td></tr></table></figure>
你觉得这样太不软件工程了，于是你改成了这样：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Observable <span class="title function_">liftAll</span><span class="params">(Observable observable)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> observable</span><br><span class="line">        .lift1()</span><br><span class="line">        .lift2()</span><br><span class="line">        .lift3()</span><br><span class="line">        .lift4();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">liftAll(observable1).subscribe(subscriber1);</span><br><span class="line">liftAll(observable2).subscribe(subscriber2);</span><br><span class="line">liftAll(observable3).subscribe(subscriber3);</span><br><span class="line">liftAll(observable4).subscribe(subscriber4);</span><br></pre></td></tr></table></figure>
<p>可读性、可维护性都提高了。可是 Observable 被一个方法包起来，这种方式对于 Observale 的灵活性似乎还是增添了那么点限制。怎么办？这个时候，就应该用 compose() 来解决了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LiftAllTransformer</span> <span class="keyword">implements</span> <span class="title class_">Observable</span>.Transformer&lt;Integer, String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Observable&lt;String&gt; <span class="title function_">call</span><span class="params">(Observable&lt;Integer&gt; observable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> observable</span><br><span class="line">            .lift1()</span><br><span class="line">            .lift2()</span><br><span class="line">            .lift3()</span><br><span class="line">            .lift4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="type">Transformer</span> <span class="variable">liftAll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiftAllTransformer</span>();</span><br><span class="line">observable1.compose(liftAll).subscribe(subscriber1);</span><br><span class="line">observable2.compose(liftAll).subscribe(subscriber2);</span><br><span class="line">observable3.compose(liftAll).subscribe(subscriber3);</span><br><span class="line">observable4.compose(liftAll).subscribe(subscriber4);</span><br></pre></td></tr></table></figure>
<p>像上面这样，使用 compose() 方法，Observable 可以利用传入的 Transformer 对象的 call 方法直接对自身进行处理，也就不必被包在方法的里面了。</p>
<h2 id="线程控制Scheduler"><a href="#线程控制Scheduler" class="headerlink" title="线程控制Scheduler"></a>线程控制Scheduler</h2><p>除了灵活的变换，RxJava 另一个牛逼的地方，就是线程的自由控制。</p>
<ol>
<li>Scheduler 的 API<br>前面讲到了，可以利用 subscribeOn() 结合 observeOn() 来实现线程控制，让事件的产生和消费发生在不同的线程。可是在了解了 map() flatMap() 等变换方法后，有些好事的（其实就是当初刚接触 RxJava 时的我）就问了：能不能多切换几次线程？</li>
</ol>
<p>答案是：能。因为 observeOn() 指定的是 Subscriber 的线程，而这个 Subscriber 并不是（严格说应该为『不一定是』，但这里不妨理解为『不是』）subscribe() 参数中的 Subscriber ，而是 observeOn() 执行时的当前 Observable 所对应的 Subscriber ，即它的直接下级 Subscriber 。换句话说，observeOn() 指定的是它之后的操作所在的线程。因此如果有多次切换线程的需求，只要在每个想要切换线程的位置调用一次 observeOn() 即可。上代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// IO 线程，由 subscribeOn() 指定</span></span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .observeOn(Schedulers.newThread())</span><br><span class="line">    .map(mapOperator) <span class="comment">// 新线程，由 observeOn() 指定</span></span><br><span class="line">    .observeOn(Schedulers.io())</span><br><span class="line">    .map(mapOperator2) <span class="comment">// IO 线程，由 observeOn() 指定</span></span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread) </span><br><span class="line">    .subscribe(subscriber);  <span class="comment">// Android 主线程，由 observeOn() 指定</span></span><br></pre></td></tr></table></figure>
<p>如上，通过 observeOn() 的多次调用，程序实现了线程的多次切换。</p>
<p>不过，不同于 observeOn() ， subscribeOn() 的位置放在哪里都可以，但它是只能调用一次的。</p>
<p>又有好事的（其实还是当初的我）问了：如果我非要调用多次 subscribeOn() 呢？会有什么效果？</p>
<p>这个问题先放着，我们还是从 RxJava 线程控制的原理说起吧。</p>
<ol start="2">
<li>Scheduler 的原理<br>其实， subscribeOn() 和 observeOn() 的内部实现，也是用的 lift()。具体看图（不同颜色的箭头表示不同的线程）：</li>
</ol>
<p>subscribeOn() 原理图：<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/android/.1606924564046.png" alt="Alt text"><br>subscribeOn() 原理<br>observeOn() 原理图：<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/android/.1606924575156.png" alt="Alt text"><br>observeOn() 原理<br>从图中可以看出，subscribeOn() 和 observeOn() 都做了线程切换的工作（图中的 “schedule…” 部位）。不同的是， subscribeOn()的线程切换发生在 OnSubscribe 中，即在它通知上一级 OnSubscribe 时，这时事件还没有开始发送，因此 subscribeOn() 的线程控制可以从事件发出的开端就造成影响；而 observeOn() 的线程切换则发生在它内建的 Subscriber 中，即发生在它即将给下一级 Subscriber 发送事件时，因此 observeOn() 控制的是它后面的线程。</p>
<p>最后，我用一张图来解释当多个 subscribeOn() 和 observeOn() 混合使用时，线程调度是怎么发生的（由于图中对象较多，相对于上面的图对结构做了一些简化调整）：<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/android/.1606924584910.png" alt="Alt text"><br>线程控制综合调用<br>图中共有 5 处含有对事件的操作。由图中可以看出，①和②两处受第一个 subscribeOn() 影响，运行在红色线程；③和④处受第一个 observeOn() 的影响，运行在绿色线程；⑤处受第二个 onserveOn() 影响，运行在紫色线程；而第二个 subscribeOn() ，由于在通知过程中线程就被第一个 subscribeOn() 截断，因此对整个流程并没有任何影响。这里也就回答了前面的问题：当使用了多个 subscribeOn() 的时候，只有第一个 subscribeOn() 起作用。</p>
<ol start="3">
<li>延伸：doOnSubscribe()<br>然而，虽然超过一个的 subscribeOn() 对事件处理的流程没有影响，但在流程之前却是可以利用的。</li>
</ol>
<p>在前面讲 Subscriber 的时候，提到过 Subscriber 的 onStart() 可以用作流程开始前的初始化。然而 onStart() 由于在 subscribe() 发生时就被调用了，因此不能指定线程，而是只能执行在 subscribe() 被调用时的线程。这就导致如果 onStart() 中含有对线程有要求的代码（例如在界面上显示一个 ProgressBar，这必须在主线程执行），将会有线程非法的风险，因为有时你无法预测 subscribe() 将会在什么线程执行。</p>
<p>而与 Subscriber.onStart() 相对应的，有一个方法 Observable.doOnSubscribe() 。它和 Subscriber.onStart() 同样是在 subscribe() 调用后而且在事件发送前执行，但区别在于它可以指定线程。默认情况下， doOnSubscribe() 执行在 subscribe() 发生的线程；而如果在 doOnSubscribe() 之后有 subscribeOn() 的话，它将执行在离它最近的 subscribeOn() 所指定的线程。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(onSubscribe)</span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .doOnSubscribe(<span class="keyword">new</span> <span class="title class_">Action0</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">            progressBar.setVisibility(View.VISIBLE); <span class="comment">// 需要在主线程执行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribeOn(AndroidSchedulers.mainThread()) <span class="comment">// 指定主线程</span></span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(subscriber);</span><br></pre></td></tr></table></figure>
<p>如上，在 doOnSubscribe()的后面跟一个 subscribeOn() ，就能指定准备工作的线程了。</p>
<h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><p>Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：</p>
<p>●谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建；谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。</p>
<p>●为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。</p>
<p>用图例说明一下，传统程序设计如图2-1，都是主动去创建相关对象然后再组合起来：<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/android/.1606924631791.png" alt="Alt text"></p>
<p>传统应用程序示意图<br>当有了IoC&#x2F;DI的容器后，在客户端类中不再主动去创建这些对象了，如图2-2所示:<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/android/.1606924641730.png" alt="Alt text"><br>有IoC&#x2F;DI容器后程序结构示意图<br>2、IoC能做什么<br>IoC不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。</p>
<p>其实IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC&#x2F;DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。</p>
<p>IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。</p>
<h2 id="IoC和DI"><a href="#IoC和DI" class="headerlink" title="IoC和DI"></a>IoC和DI</h2><p>DI—Dependency Injection，即“依赖注入”：是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p>
<p>理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：</p>
<p>●谁依赖于谁：当然是应用程序依赖于IoC容器；</p>
<p>●为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源；</p>
<p>●谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象；</p>
<p>●注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。</p>
<p>IoC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“<strong><strong>依赖注入”</strong></strong>明确描述了“被注入对象依赖IoC****容器配置依赖对象”。</p>
<p>注：如果想要更加深入的了解IoC和DI，请参考大师级人物Martin Fowler的一篇经典文章《Inversion of Control Containers and the Dependency Injection pattern》，原文地址：<a target="_blank" rel="noopener" href="http://www.martinfowler.com/articles/injection.html%E3%80%82">http://www.martinfowler.com/articles/injection.html。</a></p>
<h2 id="ButterKnife源码-amp-原理"><a href="#ButterKnife源码-amp-原理" class="headerlink" title="ButterKnife源码&amp;原理"></a>ButterKnife源码&amp;原理</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/AndroidAlvin/article/details/103159557">引入</a></p>
<h2 id="Dagger2架构设计"><a href="#Dagger2架构设计" class="headerlink" title="Dagger2架构设计"></a>Dagger2架构设计</h2><p>Dagger2依赖注入框架的好处：</p>
<ul>
<li>依赖的注入和配置独立于组件之外</li>
<li>依赖对象是在一个独立、不耦合的地方初始化，当初始化方式改变的时候修改的代码少。</li>
<li>依赖注入使得单元测试更加简单。</li>
</ul>
<p>Dagger2相对于其它框架的优点：</p>
<ul>
<li>编译期生成代码，有错误会在编译期报出。</li>
<li>错误可追踪。</li>
<li>易于调试。</li>
</ul>
<p>Dagger2的缺点：</p>
<ul>
<li>缺少灵活性。</li>
<li>没有动态机制。</li>
</ul>
<h3 id="Dagger2的注解"><a href="#Dagger2的注解" class="headerlink" title="Dagger2的注解"></a>Dagger2的注解</h3><p>Dagger2的注解主要有以下七类：</p>
<ul>
<li>@Inject：这个注解有两个作用：在目标类中标记成员变量告诉Dagger这个类型的变量需要一个实例对象；标记依赖类中的构造方法，告诉Dagger我可以提供这种类型的依赖实例。</li>
<li>@Component：用来标记接口或者抽象类，也被称为注入器，是@Inject和@Module的桥梁，所有的Component都可以通过它的modules知道它所提供的依赖范围，一个Componet可以依赖一个或多个Component，并拿到被依赖Component暴露出来的实例，Componenet的dependencies属性就是确定依赖关系的实现。</li>
<li>@Module：用来标记类，一般类名以Module结尾，Module的主要作用是用来集中管理@Provides标记的方法，我们定义一个被@Module注解的类，Dagger就会知道在哪里找到依赖来满足创建类的实例，Module的一个重要特征是被设计成区块并可以组合在一起。</li>
<li>@Provides：对方法进行注解，并且这些方法都是有返回类型的，告诉Dagger我们向如何创建并提供该类型的依赖实例（一般会在方法中new出实例），用@Provides标记的方法，推荐用provide作为前缀。</li>
<li>@Qualifier：限定符，当一个类的类型不足以标示一个依赖的时候，我们就可以用这个注解，它会调用DataModule中方法来返回合适的依赖类实例。</li>
<li>@Scope：通过自定义注解来限定作用域，所有的对象都不再需要知道怎么管理它的实例，Dagger2中有一个默认的作用域注解@Singleton，通常用来标记在App整个生命周期内存活的实例，也可以定义一个@PerActivity注解，用来表明生命周期要与Activity一致。</li>
<li>@SubComponent：如果我们需要父组件全部的提供对象，我们就可以用包含方式，而不是用依赖方式，包含方式不需要父组件显示显露对象，就可以拿到父组件全部对象，且SubComponent只需要在父Component接扣中声明就可以了。</li>
</ul>
<h3 id="Dagger2的简单应用-Inject和-Component"><a href="#Dagger2的简单应用-Inject和-Component" class="headerlink" title="Dagger2的简单应用 - @Inject和@Component"></a>Dagger2的简单应用 - @Inject和@Component</h3><p>第一步：基础配置，在build.gradle中添加相应的依赖：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加(1)</span></span><br><span class="line">apply plugin: <span class="string">&#x27;com.neenbedankt.android-apt&#x27;</span></span><br><span class="line"> </span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        <span class="comment">//添加(2)</span></span><br><span class="line">        classpath <span class="string">&#x27;com.neenbedankt.gradle.plugins:android-apt:1.8&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">23</span></span><br><span class="line">    buildToolsVersion <span class="string">&quot;23.0.0&quot;</span></span><br><span class="line"> </span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">&quot;com.demo.zejun.repodragger2&quot;</span></span><br><span class="line">        minSdkVersion <span class="number">15</span></span><br><span class="line">        targetSdkVersion <span class="number">23</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">&quot;1.0&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="literal">false</span></span><br><span class="line">            proguardFiles <span class="title function_">getDefaultProguardFile</span><span class="params">(<span class="string">&#x27;proguard-android.txt&#x27;</span>)</span>, <span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="title function_">fileTree</span><span class="params">(dir: <span class="string">&#x27;libs&#x27;</span>, include: [<span class="string">&#x27;*.jar&#x27;</span>])</span></span><br><span class="line">    testCompile <span class="string">&#x27;junit:junit:4.12&#x27;</span></span><br><span class="line">    compile <span class="string">&#x27;com.android.support:appcompat-v7:23.0.0&#x27;</span></span><br><span class="line">    <span class="comment">//添加(3)</span></span><br><span class="line">    apt <span class="string">&#x27;com.google.dagger:dagger-compiler:2.0&#x27;</span></span><br><span class="line">    <span class="comment">//添加(4)</span></span><br><span class="line">    compile <span class="string">&#x27;com.google.dagger:dagger:2.0&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>第二步：User作为目标类中需要实例化的成员对象，给其构造函数添加@Inject标签：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">        name = <span class="string">&quot;lizejun&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>第三步：声明Component：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Component()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OnlyInjectComponent</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(AnnotationActivity annotationActivity)</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>第四步：在目标类中添加注解@Inject，并根据我们第3步中声明的Component，调用DaggerXXX方法来进行注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> User mUser;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_dragger2);</span><br><span class="line">        <span class="comment">//在第3步声明的Component接口或者抽象类的基础上，添加Dagger前缀。</span></span><br><span class="line">        DaggerOnlyInjectComponent.builder().build().inject(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>上面这个例子有两个缺点：</p>
<ul>
<li>只能标记一个构造方法，因为如果标记两个以上，不知道要用哪一个构造提供实例。</li>
<li>不能标记其它我们不能修改的类，例如第三方库。</li>
<li>如果用@Inject标记的构造函数如果有参数，那么这个参数也需要其它地方提供依赖，而类似于String这些我们不能修改的类，只能用@Module中的@Provides来提供实例了。</li>
</ul>
<h3 id="采用-Module来提供依赖"><a href="#采用-Module来提供依赖" class="headerlink" title="采用@Module来提供依赖"></a>采用@Module来提供依赖</h3><p>采用@Module标记的类提供依赖是常规套路，@Module标记的类起管理作用，真正提供依赖实例靠的是@Provides标记的带返回类型的方法。<br>第一步：和上面类似，我们定义一个依赖类，但是它的构造方法并不需要用@Inject标记：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;lizejun&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>第二步：我们需要定义一个@Module来管理这些依赖类的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Module</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonDataModule</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">providePerson</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>第三步：定义一个@Component，它指向上面定义的@Module</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Component(modules = &#123;PersonDataModule.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonInjectComponent</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(PersonInjectActivity injectActivity)</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>第四步：在目标类中进行依赖注入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonInjectActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Person mPerson;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        DaggerPersonInjectComponent.create().inject(<span class="built_in">this</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Person name=&quot;</span> + mPerson.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>这里注入的方式有两种，一种是像上面这样的，它适合于PersonDataModule中只有一个无参的构造方法，否则我们需要这样调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DaggerPersonInjectComponent.builder().personDataModule(<span class="keyword">new</span> <span class="title class_">PersonDataModule</span>()).build().inject(<span class="built_in">this</span>);</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h3 id="初始化依赖实例的步骤"><a href="#初始化依赖实例的步骤" class="headerlink" title="初始化依赖实例的步骤"></a>初始化依赖实例的步骤</h3><ul>
<li><p>查找Module中是否存在创建该类型的方法（即@Component标记的接口中包含了@Module标记的Module类，如果没有则直接查找@Inject对应的构造方法）。</p>
</li>
<li><p>如果存在创建类方法，则查看该方法是否有参数</p>
</li>
<li><p>如果不存在参数，直接初始化该类的实例，一次依赖注入到此结束。</p>
</li>
<li><p>如果存在参数，则从步骤1开始初始化每个参数。</p>
</li>
<li><p>如果不存在创建类方法，则查找该类型的类中有@Inject标记的构造方法，查看构造方法是否有参数：</p>
</li>
<li><p>如果不存在参数，则直接初始化该类实例，一次依赖注入到此结束。</p>
</li>
<li><p>如果存在参数，则从步骤1开始初始化每个参数。</p>
</li>
</ul>
<h3 id="Qualifier限定符"><a href="#Qualifier限定符" class="headerlink" title="@Qualifier限定符"></a>@Qualifier限定符</h3><p>在Dagger中，有一个已经定义好的限定符，@Name，下面我们也自己定义一个限定符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Qualifier</span><br><span class="line"><span class="title function_">Retention</span><span class="params">(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PeopleThreeQualifier &#123;&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>第一步：和前面类似，我们先定义一个需要实例化的依赖类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">People</span><span class="params">()</span> &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">People</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>第二步：我定义一个DataModule，和前面不同的是，在它的provideXXX方法的注解中，我们添加了@Name(xxx)和自定义的注解PeopleThreePeople：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PeopleDataModule</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="meta">@Named(&quot;Five People&quot;)</span></span><br><span class="line">    People <span class="title function_">provideFivePeople</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">People</span>(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="meta">@Named(&quot;Ten People&quot;)</span></span><br><span class="line">    People <span class="title function_">provideTenPeople</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">People</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="meta">@PeopleThreeQualifier</span></span><br><span class="line">    People <span class="title function_">provideThreePeople</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">People</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>第三步：定义Component</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(modules = PeopleDataModule.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PeopleInjectComponent</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(PeopleInjectActivity peopleInjectActivity)</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>第四步：在目标类中进行依赖注入，在提供@Inject注解时，我们还需要声明和PeopleDataModule中对应的限定符，这样Dagger就知道该用那个函数来生成目标类中的依赖类实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PeopleInjectActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="meta">@Named(&quot;Five People&quot;)</span></span><br><span class="line">    People mFivePeople;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="meta">@Named(&quot;Ten People&quot;)</span></span><br><span class="line">    People mTenPeople;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="meta">@PeopleThreeQualifier</span></span><br><span class="line">    People mThreePeople;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        DaggerPeopleInjectComponent.builder().peopleDataModule(<span class="keyword">new</span> <span class="title class_">PeopleDataModule</span>()).build().inject(<span class="built_in">this</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Five People=&quot;</span> + mFivePeople.getCount() + <span class="string">&quot;,Ten People=&quot;</span> + mTenPeople.getCount() + <span class="string">&quot;, Three People=&quot;</span> + mThreePeople.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h3 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h3><p>@Scope的作用主要是在组织Component和Module的时候起到一个提醒和管理的作用，在Dagger中，有一个默认的作用域@Singleton。<br>@Scope的作用是：Dagger2可以通过自定义Scope注解，来限定通过Module和Inject方式创建的类的实例的生命周期能够与目标类的生命周期相同。Scope的真正作用在与Component的组织：</p>
<ul>
<li>更好的管理Component之间的组织方式，不管是依赖方式还是包含方式，都有必要用自定的Scope注解标注这些Component，而且编译器会检查有依赖关系或包含关系的Component，若发现有Component没有用自定义Scope注解，则会报错。</li>
<li>更好地管理Component与Module之间地关系，编译器会检查Component管理的Module，若发现Component的自定义Scope注解与Module中的标注创建类实例方法的注解不一样，就会报错。</li>
<li>提高程序的可读性。</li>
</ul>
<p>下面是一个使用@Singleton的例子：<br>第一步：定义需要实例化的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnSingleObject</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String objectId;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AnSingleObject</span><span class="params">()</span> &#123;</span><br><span class="line">        objectId = toString();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getObjectId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> objectId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>第二步：定义DataModule，在它的provideXXX方法，提供了@Singletion注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnSingleObjectDataModule</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="meta">@Singleton</span></span><br><span class="line">    AnSingleObject <span class="title function_">provideAnSingleObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnSingleObject</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>第三步：定义Component，和前面不同的是，需要给这个Component添加@Singleton注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(modules = &#123;AnSingleObjectDataModule.class&#125;)</span></span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AnSingleObjectInjectComponent</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AnSingleObjectInjectComponent sInstance;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(AnSingleObjectInjectActivity anSingleObjectInjectActivity)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AnSingleObjectInjectComponent <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            sInstance = DaggerAnSingleObjectInjectComponent.create();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>第四步：在目标类中进行依赖注入，每次启动Activity的时候，我们可以发现打印出来的hash值都是相同的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnSingleObjectInjectActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    AnSingleObject object;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        AnSingleObjectInjectComponent.getInstance().inject(<span class="built_in">this</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;AnSingleObject id=&quot;</span> + object.getObjectId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h3 id="组织Component"><a href="#组织Component" class="headerlink" title="组织Component"></a>组织Component</h3><p>Component有三种组织方式：</p>
<ul>
<li>依赖：一个Component依赖一个或多个Component，采用的是@Component的dependencies属性。</li>
<li>包含：这里就用到了@SubComponent注解，用它来标记接口或者抽象类，表示它可以被包干。一个Component可以包含一个或多个Component，而且被包含的Component还可以继续包含其它的Component。</li>
<li>继承：用一个Component继承另外一个Component。</li>
</ul>
<h3 id="Google官方框架分析"><a href="#Google官方框架分析" class="headerlink" title="Google官方框架分析"></a>Google官方框架分析</h3><p>下面是Google官方框架的目录结构：<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/android/.1606925116052.png" alt="Alt text"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/AndroidAlvin/article/details/103159554">引入</a></p>
<h1 id="IOC-优化-findViewById和x-setOnClickListener"><a href="#IOC-优化-findViewById和x-setOnClickListener" class="headerlink" title="IOC 优化 findViewById和x.setOnClickListener"></a>IOC 优化 findViewById和x.setOnClickListener</h1><blockquote>
<p>简介<br>这里其实有点像aop处理onCick，但是其做法和目的是不同的，这里是的好处是不需要写繁杂重复的代码</p>
</blockquote>
<ul>
<li>核心代码<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">injectField</span><span class="params">(viewFinder: <span class="type">ViewFinder</span>, any: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">    any.javaClass.declaredFields.forEach &#123; field -&gt;</span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">annotation</span> = field.getAnnotation(ViewById::<span class="keyword">class</span>.java)</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">annotation</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> view = viewFinder.getViewById(<span class="keyword">annotation</span>.value)</span><br><span class="line">            <span class="keyword">if</span> (view != <span class="literal">null</span>) &#123;</span><br><span class="line">                field.isAccessible = <span class="literal">true</span></span><br><span class="line">                field.<span class="keyword">set</span>(any, view)<span class="comment">//</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">injectMethod</span><span class="params">(viewFinder: <span class="type">ViewFinder</span>, any: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">    any.javaClass.declaredMethods.forEach &#123; method -&gt;</span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">annotation</span> = method.getAnnotation(OnClick::<span class="keyword">class</span>.java)</span><br><span class="line">        <span class="keyword">annotation</span>?.value?.forEach &#123; viewId -&gt;</span><br><span class="line">            <span class="keyword">val</span> isCheckNet = method.getAnnotation(CheckNet::<span class="keyword">class</span>.java) != <span class="literal">null</span></span><br><span class="line">            viewFinder.getViewById(viewId)</span><br><span class="line">                ?.setOnClickListener(DeclaredOnClickListener(method, any, isCheckNet))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeclaredOnClickListener</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> method: Method,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> any: Any,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> isCheckNet: <span class="built_in">Boolean</span></span><br><span class="line">) : View.OnClickListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> (isCheckNet) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isNetWorkAvilable(v.context)) &#123;</span><br><span class="line">                Toast.makeText(v.context, <span class="string">&quot;xxxx&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        method.invoke(any, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Android中使用AOP"><a href="#Android中使用AOP" class="headerlink" title="Android中使用AOP"></a>Android中使用AOP</h1><blockquote>
<p>AOP是面向切面编程</p>
</blockquote>
<h2 id="目的-x2F-能解决的问题-x2F-好处"><a href="#目的-x2F-能解决的问题-x2F-好处" class="headerlink" title="目的&#x2F;能解决的问题&#x2F;好处"></a>目的&#x2F;能解决的问题&#x2F;好处</h2><blockquote>
<p>xxxxxxxxxx</p>
</blockquote>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul>
<li><p>gradle文件加入</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.bridge.IMessage</span><br><span class="line"><span class="keyword">import</span> org.aspectj.bridge.MessageHandler</span><br><span class="line"><span class="keyword">import</span> org.aspectj.tools.ajc.Main</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">def</span> log = project.logger</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">def</span> variants = project.android.applicationVariants</span><br><span class="line"></span><br><span class="line">variants.all &#123; variant -&gt;</span><br><span class="line">    <span class="keyword">if</span> (!variant.buildType.isDebuggable()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Skipping non-debuggable build type &#x27;$&#123;variant.buildType.name&#125;&#x27;.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    JavaCompile javaCompile = variant.javaCompile</span><br><span class="line">    javaCompile.doLast &#123;</span><br><span class="line">        String[] args = [<span class="string">&quot;-showWeaveInfo&quot;</span>,</span><br><span class="line">                         <span class="string">&quot;-1.8&quot;</span>,</span><br><span class="line">                         <span class="string">&quot;-inpath&quot;</span>, javaCompile.destinationDir.toString(),</span><br><span class="line">                         <span class="string">&quot;-aspectpath&quot;</span>, javaCompile.classpath.asPath,</span><br><span class="line">                         <span class="string">&quot;-d&quot;</span>, javaCompile.destinationDir.toString(),</span><br><span class="line">                         <span class="string">&quot;-classpath&quot;</span>, javaCompile.classpath.asPath,</span><br><span class="line">                         <span class="string">&quot;-bootclasspath&quot;</span>, project.android.bootClasspath.join(File.pathSeparator)]</span><br><span class="line">        log.debug <span class="string">&quot;ajc args: &quot;</span> + Arrays.toString(args)</span><br><span class="line"></span><br><span class="line">        MessageHandler handler = <span class="keyword">new</span> MessageHandler(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">new</span> Main().run(args, handler);</span><br><span class="line">        <span class="keyword">for</span> (IMessage <span class="attr">message :</span> handler.getMessages(<span class="literal">null</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (message.getKind()) &#123;</span><br><span class="line">                <span class="keyword">case</span> IMessage.<span class="attr">ABORT:</span></span><br><span class="line">                <span class="keyword">case</span> IMessage.<span class="attr">ERROR:</span></span><br><span class="line">                <span class="keyword">case</span> IMessage.<span class="attr">FAIL:</span></span><br><span class="line">                    log.error message.message, message.thrown</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> IMessage.<span class="attr">WARNING:</span></span><br><span class="line">                    log.warn message.message, message.thrown</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> IMessage.<span class="attr">INFO:</span></span><br><span class="line">                    log.info message.message, message.thrown</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> IMessage.<span class="attr">DEBUG:</span></span><br><span class="line">                    log.debug message.message, message.thrown</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>dependencies中导包</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.aspectj:aspectjrt:1.9.5&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>处理切面的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找到处理的切点</span></span><br><span class="line"><span class="comment">     * * *(..)  可以处理所有的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(@com.uncle2000.learning.learning4.v2.CheckNetJump * *(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkNetBehavior</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理切面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around(&quot;checkNetBehavior()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">checkNet</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">````</span><br><span class="line">- 还有要加在类上的注释<span class="meta">@Aspect</span></span><br><span class="line">- 被监听的注解</span><br><span class="line">- 导包</span><br><span class="line"></span><br><span class="line">``` java</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.reflect.MethodSignature;</span><br></pre></td></tr></table></figure></li>
</ul>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>王水泥</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://uncle2000.github.io/post/Android/Android-RxJava%20&%20ioC%20DI%20&%20AOP/">https://uncle2000.github.io/post/Android/Android-RxJava%20&%20ioC%20DI%20&%20AOP/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/post/Android/Android%20%E8%BF%9B%E7%A8%8B%20or%20%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/">Android 进程\线程间的通信</a>
            
            
            <a class="next" rel="next" href="/post/Android/Android%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF%E7%9A%84%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF%EF%BC%9A%E7%94%A8LiveDataBus%E6%9B%BF%E4%BB%A3RxBus%E3%80%81EventBus/">Android消息总线的演进之路：用LiveDataBus替代RxBus、EventBus</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 王水泥 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>
<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="王水泥">


    <meta name="subtitle" content="技术，etc">


    <meta name="description" content="不要传播">



<title>JetPack | 王水泥个人博客</title>



    <link rel="icon" href="/blog/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/blog/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/blog/js/script.js"></script>
    
    <script src="/blog/js/tocbot.min.js"></script>
    




<meta name="generator" content="Hexo 5.4.2"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/blog/">王水泥的博客</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/blog/archives">Posts</a>
                
                    <a class="menu-item" href="/blog/category">Categories</a>
                
                    <a class="menu-item" href="/blog/tag">Tags</a>
                
                    <a class="menu-item" href="/blog/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/blog/">王水泥的博客</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/blog/archives">Posts</a>
                
                    <a class="menu-item" href="/blog/category">Categories</a>
                
                    <a class="menu-item" href="/blog/tag">Tags</a>
                
                    <a class="menu-item" href="/blog/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">JetPack</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">王水泥</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">十一月 1, 2022&nbsp;&nbsp;16:23:33</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/blog/categories/Android/">Android</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="JetPack"><a href="#JetPack" class="headerlink" title="JetPack"></a>JetPack</h1><p>[toc]</p>
<h2 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h2><p><a target="_blank" rel="noopener" href="https://developer.android.com/topic/libraries/architecture/livedata">工作的原理</a><br><a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle">Lifecycle</a><br>LiveData是一个数据持有类，它可以通过添加观察者被其他组件观察其变更。不同于普通的观察者，它最重要的特性就是遵从应用程序的生命周期，如在Activity中如果数据更新了但Activity已经是destroy状态，LivaeData就不会通知Activity(observer)。当然。LiveData的优点还有很多，如不会造成内存泄漏等。</p>
<p>LiveData通常会配合ViewModel来使用，ViewModel负责触发数据的更新，更新会通知到LiveData，然后LiveData再通知活跃状态的观察者。</p>
<h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>下面直接看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProfileViewModel</span> <span class="keyword">extends</span> <span class="title class_">ViewModel</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line">    <span class="keyword">private</span> MutableLiveData&lt;User&gt; user;</span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepo;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userId = userId;</span><br><span class="line">        userRepo = <span class="keyword">new</span> <span class="title class_">UserRepository</span>();</span><br><span class="line">        user = userRepo.getUser(userId);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">        user = userRepo.getUser(userId);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> MutableLiveData&lt;User&gt; <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面UserProfileViewModel内部持有 UserRepository 中 MutableLiveData<User>的引用，并且提供了获取 MutableLiveData 的方法 getUser()，UserRepository 负责从网络或数据库中获取数据并封装成 MutableLiveData 然后提供给 ViewModel。</p>
<p>我们在 UserProfileFragment 中为 MutableLiveData<User> 注册观察者，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityCreated</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">    <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> getArguments().getString(UID_KEY);</span><br><span class="line">    viewModel = ViewModelProviders.of(<span class="built_in">this</span>).get(UserProfileViewModel.class);</span><br><span class="line">    viewModel.init(userId);</span><br><span class="line">    <span class="comment">//标注1</span></span><br><span class="line">    viewModel.getUser().observe(UserProfileFragment.<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">Observer</span>&lt;User&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChanged</span><span class="params">(<span class="meta">@Nullable</span> User user)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">                tvUser.setText(user.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看标注1处，viewModel.getUser()获取到 MutableLiveData<User> 也就是我们的 LiveData，然后调用 LiveData的observer方法，并把UserProfileFragment作为参数传递进去。observer() 方法就是我们分析的入口了，接下来我们看LiveData的observer()方法都做了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">MainThread</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">observe</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner owner, <span class="meta">@NonNull</span> Observer&lt;T&gt; observer)</span> &#123;</span><br><span class="line">    <span class="comment">//标注1</span></span><br><span class="line">    <span class="keyword">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//标注2</span></span><br><span class="line">    <span class="type">LifecycleBoundObserver</span> <span class="variable">wrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LifecycleBoundObserver</span>(owner, observer);</span><br><span class="line">    <span class="type">ObserverWrapper</span> <span class="variable">existing</span> <span class="operator">=</span> mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="literal">null</span> &amp;&amp; !existing.isAttachedTo(owner)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot add the same observer&quot;</span></span><br><span class="line">                + <span class="string">&quot; with different lifecycles&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    owner.getLifecycle().addObserver(wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，UserProfileFragment 是作为 LifeCycleOwner 参数传进来的，如果你的support包版本大于等于26.1.0，support包中的 Fragment 会默认继承自 LifecycleOwner，而 LifecycleOwner 可获取到该组件的 LifeCycle，也就知道了 UserProfileFragment 组件的生命周期（在这里默认大家已经了解过LifeCycle了）。</p>
<p>看标注1处，如果我们的 UserProfileFragment 组件已经是destroy状态的话，将直接返回，不会被加入观察者行列。如果不是destroy状态，就到标注2处，新建一个 LifecycleBoundObserver 将我们的 LifecycleOwner 和 observer保存起来，然后调用 mObservers.putIfAbsent(observer, wrapper) 将observer和wrapper分别作为key和value存入Map中，putIfAbsent()方法会判断如果 value 已经能够存在，就返回，否则返回null。<br>如果返回existing为null，说明以前没有添加过这个观察者，就将 LifecycleBoundObserver 作为 owner 生命周期的观察者，也就是作为 UserProfileFragment 生命周期的观察者。</p>
<p>我们看下LifecycleBoundObserver 源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LifecycleBoundObserver</span> <span class="keyword">extends</span> <span class="title class_">ObserverWrapper</span> <span class="keyword">implements</span> <span class="title class_">GenericLifecycleObserver</span> &#123;</span><br><span class="line">    <span class="meta">@NonNull</span> <span class="keyword">final</span> LifecycleOwner mOwner;</span><br><span class="line"> </span><br><span class="line">    LifecycleBoundObserver(<span class="meta">@NonNull</span> LifecycleOwner owner, Observer&lt;T&gt; observer) &#123;</span><br><span class="line">        <span class="built_in">super</span>(observer);</span><br><span class="line">        mOwner = owner;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">shouldBeActive</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStateChanged</span><span class="params">(LifecycleOwner source, Lifecycle.Event event)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">            removeObserver(mObserver);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        activeStateChanged(shouldBeActive());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAttachedTo</span><span class="params">(LifecycleOwner owner)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mOwner == owner;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">detachObserver</span><span class="params">()</span> &#123;</span><br><span class="line">        mOwner.getLifecycle().removeObserver(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码并不多，LifecycleBoundObserver 继承自 ObserverWrapper 并实现了 GenericLifecycleObserver接口，而 GenericLifecycleObserver 接口又继承自 LifecycleObserver 接口，那么根据 Lifecycle 的特性，实现了LifecycleObserver接口并且加入 LifecycleOwner 的观察者里就可以感知或主动获取 LifecycleOwner 的状态。</p>
<p>好了，看完了观察者，那么我们的LiveData什么时候会通知观察者呢？不用想，肯定是数据更新的时候，而数据的更新是我们代码自己控制的，如请求网络返回User信息后，我们会主动将User放入MutableLiveData中，这里我在UserRepository中直接模拟网络请求如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRepository</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> MutableLiveData&lt;User&gt; data = <span class="keyword">new</span> <span class="title class_">MutableLiveData</span>&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> MutableLiveData&lt;User&gt; <span class="title function_">getUser</span><span class="params">(<span class="keyword">final</span> String userId)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;xiasm&quot;</span>.equals(userId)) &#123;</span><br><span class="line">            data.setValue(<span class="keyword">new</span> <span class="title class_">User</span>(userId, <span class="string">&quot;夏胜明&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;123456&quot;</span>.equals(userId)) &#123;</span><br><span class="line">            data.setValue(<span class="keyword">new</span> <span class="title class_">User</span>(userId, <span class="string">&quot;哈哈哈&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data.setValue(<span class="keyword">new</span> <span class="title class_">User</span>(userId, <span class="string">&quot;unknow&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用getUser()方法的时候，我们调用MutableLiveData的setValue()方法将数据放入LiveData中，这里MutableLiveData实际上就是继承自LiveData，没有什么特别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MutableLiveData</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">LiveData</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postValue</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.postValue(value);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setValue(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>setValue()在放入User的时候必须在主线程，否则会报错，而postValue则没有这个检查，而是会把数据传入到主线程。我们直接看setValue()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MainThread</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    assertMainThread(<span class="string">&quot;setValue&quot;</span>);</span><br><span class="line">    mVersion++;</span><br><span class="line">    mData = value;</span><br><span class="line">    dispatchingValue(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先调用assertMainThread()检查是否在主线程，接着将要更新的数据赋给mData，然后调用 dispatchingValue()方法并传入null，将数据分发给各个观察者，如我们的 UserProfileFragment。看 dispatchingValue()方法实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dispatchingValue</span><span class="params">(<span class="meta">@Nullable</span> ObserverWrapper initiator)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mDispatchingValue) &#123;</span><br><span class="line">        mDispatchInvalidated = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mDispatchingValue = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        mDispatchInvalidated = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//标注1</span></span><br><span class="line">        <span class="keyword">if</span> (initiator != <span class="literal">null</span>) &#123;</span><br><span class="line">            considerNotify(initiator);</span><br><span class="line">            initiator = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//标注2</span></span><br><span class="line">            <span class="keyword">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class="line">                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class="line">                considerNotify(iterator.next().getValue());</span><br><span class="line">                <span class="keyword">if</span> (mDispatchInvalidated) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (mDispatchInvalidated);</span><br><span class="line">    mDispatchingValue = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从标注1可以看出，dispatchingValue()参数传null和不传null的区别就是如果传null将会通知所有的观察者，反之仅仅通知传入的观察者。我们直接看标注2，通知所有的观察者通过遍历 mObservers ，将所有的 ObserverWrapper 拿到，实际上就是我们上面提到的 LifecycleBoundObserver，通知观察者调用considerNotify()方法，这个方法就是通知的具体实现了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">considerNotify</span><span class="params">(ObserverWrapper observer)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!observer.mActive) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Check latest state b4 dispatch. Maybe it changed state but we didn&#x27;t get the event yet.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// we still first check observer.active to keep it as the entrance for events. So even if</span></span><br><span class="line">    <span class="comment">// the observer moved to an active state, if we&#x27;ve not received that event, we better not</span></span><br><span class="line">    <span class="comment">// notify for a more predictable notification order.</span></span><br><span class="line">    <span class="keyword">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class="line">        observer.activeStateChanged(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    observer.mLastVersion = mVersion;</span><br><span class="line">    <span class="comment">//noinspection unchecked</span></span><br><span class="line">    observer.mObserver.onChanged((T) mData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果观察者不是活跃状态，将不会通知此观察者，看最后一行，observer.mObserver.onChanged((T) mData)，observer.mObserver就是我们调用LiveData的observer()方法传入的 Observer，然后调用 Observer 的 onChanged((T) mData)方法，将保存的数据mData传入，也就实现了更新。在看下我们实现的Observer：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">viewModel.getUser().observe(UserProfileFragment.<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">Observer</span>&lt;User&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChanged</span><span class="params">(<span class="meta">@Nullable</span> User user)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            tvUser.setText(user.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果哪个控件要根据user的变更而及时更新，就在onChanged()方法里处理就可以了。到这里，LiveData已经能够分析完了，其实LiveData的实现还是要依赖于Lifecycle。</p>
<h2 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h2><p>ViewModel，从字面上理解的话，它肯定是跟视图(View)以及数据(Model)相关的。正像它字面意思一样，它是负责准备和管理和UI组件(Fragment&#x2F;Activity)相关的数据类，也就是说ViewModel是用来管理UI相关的数据的，同时ViewModel还可以用来负责UI组件间的通信。</p>
<h3 id="之前存在的问题"><a href="#之前存在的问题" class="headerlink" title="之前存在的问题"></a>之前存在的问题</h3><p>ViewModel用来存储和管理UI相关的数据，可于将一个Activity或Fragment组件相关的数据逻辑抽象出来，并能适配组件的生命周期，如当屏幕旋转Activity重建后，ViewModel中的数据依然有效。</p>
<h3 id="引入ViewModel之前，存在如下几个问题："><a href="#引入ViewModel之前，存在如下几个问题：" class="headerlink" title="引入ViewModel之前，存在如下几个问题："></a>引入ViewModel之前，存在如下几个问题：</h3><p>通常Android系统来管理UI controllers（如Activity、Fragment）的生命周期，由系统响应用户交互或者重建组件，用户无法操控。当组件被销毁并重建后，原来组件相关的数据也会丢失，如果数据类型比较简单，同时数据量也不大，可以通过onSaveInstanceState()存储数据，组件重建之后通过onCreate()，从中读取Bundle恢复数据。但如果是大量数据，不方便序列化及反序列化，则上述方法将不适用。<br>UI controllers经常会发送很多异步请求，有可能会出现UI组件已销毁，而请求还未返回的情况，因此UI controllers需要做额外的工作以防止内存泄露。<br>当Activity因为配置变化而销毁重建时，一般数据会重新请求，其实这是一种浪费，最好就是能够保留上次的数据。<br>UI controllers其实只需要负责展示UI数据、响应用户交互和系统交互即可。但往往开发者会在Activity或Fragment中写许多数据请求和处理的工作，造成UI controllers类代码膨胀，也会导致单元测试难以进行。我们应该遵循职责分离原则，将数据相关的事情从UI controllers中分离出来。</p>
<h3 id="ViewModel基本使用"><a href="#ViewModel基本使用" class="headerlink" title="ViewModel基本使用"></a>ViewModel基本使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyViewModel</span> <span class="keyword">extends</span> <span class="title class_">ViewModel</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MutableLiveData&lt;List&lt;User&gt;&gt; users;</span><br><span class="line">    <span class="keyword">public</span> LiveData&lt;List&lt;User&gt;&gt; <span class="title function_">getUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (users == <span class="literal">null</span>) &#123;</span><br><span class="line">            users = <span class="keyword">new</span> <span class="title class_">MutableLiveData</span>&lt;List&lt;Users&gt;&gt;();</span><br><span class="line">            loadUsers();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 异步调用获取用户列表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新的Activity如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="type">MyViewModel</span> <span class="variable">model</span> <span class="operator">=</span> ViewModelProviders.of(<span class="built_in">this</span>).get(MyViewModel.class);</span><br><span class="line">        model.getUsers().observe(<span class="built_in">this</span>, users -&gt; &#123;</span><br><span class="line">            <span class="comment">// 更新 UI</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果Activity被重新创建了，它会收到被之前Activity创建的相同MyViewModel实例。当所属Activity终止后，框架调用ViewModel的onCleared()方法清除资源。</p>
<p>因为ViewModel在指定的Activity或Fragment实例外存活，它应该永远不能引用一个View，或持有任何包含Activity context引用的类。如果ViewModel需要Application的context（如获取系统服务），可以扩展AndroidViewmodel，并拥有一个构造器接收Application。</p>
<h3 id="在Fragment间共享数据"><a href="#在Fragment间共享数据" class="headerlink" title="在Fragment间共享数据"></a>在Fragment间共享数据</h3><p>一个Activity中的多个Fragment相互通讯是很常见的。之前每个Fragment需要定义接口描述，所属Activity将二者捆绑在一起。此外，每个Fragment必须处理其他Fragment未创建或不可见的情况。通过使用ViewModel可以解决这个痛点，这些Fragment可以使用它们的Activity共享ViewModel来处理通讯：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SharedViewModel</span> <span class="keyword">extends</span> <span class="title class_">ViewModel</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MutableLiveData&lt;Item&gt; selected = <span class="keyword">new</span> <span class="title class_">MutableLiveData</span>&lt;Item&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">        selected.setValue(item);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> LiveData&lt;Item&gt; <span class="title function_">getSelected</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> selected;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MasterFragment</span> <span class="keyword">extends</span> <span class="title class_">Fragment</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> SharedViewModel model;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityCreated</span><span class="params">()</span> &#123;</span><br><span class="line">        model = ViewModelProviders.of(getActivity()).get(SharedViewModel.class);</span><br><span class="line">        itemSelector.setOnClickListener(item -&gt; &#123;</span><br><span class="line">            model.select(item);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DetailFragment</span> <span class="keyword">extends</span> <span class="title class_">LifecycleFragment</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityCreated</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SharedViewModel</span> <span class="variable">model</span> <span class="operator">=</span> ViewModelProviders.of(getActivity()).get(SharedViewModel.class);</span><br><span class="line">        model.getSelected().observe(<span class="built_in">this</span>, &#123; item -&gt;</span><br><span class="line">           <span class="comment">// update UI</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意:上面两个Fragment都用到了如下代码来获取ViewModel，getActivity()返回的是同一个宿主Activity，因此两个Fragment之间返回的是同一个SharedViewModel对象。</p>
<p>SharedViewModel model &#x3D; ViewModelProviders.of(getActivity()).get(SharedViewModel.class);<br>这种方式的好处包括：</p>
<p>1.Activity不需要做任何事情，也不需要知道通讯的事情<br>2.Fragment不需要知道彼此，除了SharedViewModel进行联系。如果它们(Fragment)其中一个消失了，其余的仍然能够像往常一样工作。<br>3.每个Fragment有自己的生命周期，而且不会受其它Fragment生命周期的影响。事实上，一个Fragment替换另一个Fragment，UI的工作也不会受到任何影响。</p>
<h3 id="ViewModel的生命周期"><a href="#ViewModel的生命周期" class="headerlink" title="ViewModel的生命周期"></a>ViewModel的生命周期</h3><p>ViewModel对象的范围由获取ViewModel时传递至ViewModelProvider的Lifecycle所决定。ViewModel始终处在内存中，直到Lifecycle永久地离开—对于Activity来说，是当它终止（finish）的时候，对于Fragment来说，是当它分离（detached）的时候。<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/android/.1606970294545.png" alt="Alt text"></p>
<p>上图左侧为Activity的生命周期过程，期间有一个旋转屏幕的操作；右侧则为ViewModel的生命周期过程。</p>
<p>一般通过如下代码初始化ViewModel：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viewModel = ViewModelProviders.of(<span class="built_in">this</span>).get(UserProfileViewModel.class);</span><br></pre></td></tr></table></figure>
<p>this参数一般为Activity或Fragment，因此ViewModelProvider可以获取组件的生命周期。</p>
<p>Activity在生命周期中可能会触发多次onCreate()，而ViewModel则只会在第一次onCreate()时创建，然后直到最后Activity销毁。</p>
<p>ViewModel相关类图<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/android/.1606970304120.png" alt="Alt text"></p>
<p>ViewModelProviders是ViewModel工具类，该类提供了通过Fragment和Activity得到ViewModel的方法，而具体实现又是由ViewModelProvider实现的。</p>
<p>ViewModelProvider是实现ViewModel创建、获取的工具类。在ViewModelProvider中定义了一个创建ViewModel的接口类——Factory。ViewModelProvider中有个ViewModelStore对象，用于存储ViewModel对象。</p>
<p>ViewModelStore是存储ViewModel的类，具体实现是通过HashMap来保存ViewModle对象。</p>
<p>ViewModel是个抽象类，里面只定义了一个onCleared()方法，该方法在ViewModel不在被使用时调用。ViewModel有一个子类AndroidViewModel，这个类是便于要在ViewModel中使用Context对象，因为我们前面提到不能在ViewModel中持有Activity的引用。</p>
<p>ViewModelStores是ViewModelStore的工厂方法类，它会关联HolderFragment，HolderFragment有个嵌套类——HolderFragmentManager。</p>
<p>###ViewModel相关时序图<br>追溯创建一个ViewModel的源码，会察觉需要的步骤有点多。下面以在Fragment中得到ViewModel对象为例看下整个过程的时序图。<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/android/.1606970314229.png" alt="Alt text"></p>
<p>时序图看起来比较复杂，但是它只描述了两个过程：</p>
<p>得到ViewModel对象。<br>HolderFragment被销毁时，ViewModel收到onCleared()通知。</p>
<p>ViewModel相关源码分析<br>ViewModelProviders类的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewModelProviders</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Application <span class="title function_">checkApplication</span><span class="params">(Activity activity)</span> &#123;</span><br><span class="line">        <span class="type">Application</span> <span class="variable">application</span> <span class="operator">=</span> activity.getApplication();</span><br><span class="line">        <span class="keyword">if</span> (application == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Your activity/fragment is not yet attached to &quot;</span></span><br><span class="line">                    + <span class="string">&quot;Application. You can&#x27;t request ViewModel before onCreate call.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> application;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Activity <span class="title function_">checkActivity</span><span class="params">(Fragment fragment)</span> &#123;</span><br><span class="line">        <span class="type">Activity</span> <span class="variable">activity</span> <span class="operator">=</span> fragment.getActivity();</span><br><span class="line">        <span class="keyword">if</span> (activity == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Can&#x27;t create ViewModelProvider for detached fragment&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> activity;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ViewModelProvider <span class="title function_">of</span><span class="params">(<span class="meta">@NonNull</span> Fragment fragment)</span> &#123;</span><br><span class="line">        ViewModelProvider.<span class="type">AndroidViewModelFactory</span> <span class="variable">factory</span> <span class="operator">=</span></span><br><span class="line">                ViewModelProvider.AndroidViewModelFactory.getInstance(</span><br><span class="line">                        checkApplication(checkActivity(fragment)));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ViewModelProvider</span>(ViewModelStores.of(fragment), factory);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ViewModelProvider <span class="title function_">of</span><span class="params">(<span class="meta">@NonNull</span> FragmentActivity activity)</span> &#123;</span><br><span class="line">        ViewModelProvider.<span class="type">AndroidViewModelFactory</span> <span class="variable">factory</span> <span class="operator">=</span></span><br><span class="line">                ViewModelProvider.AndroidViewModelFactory.getInstance(</span><br><span class="line">                        checkApplication(activity));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ViewModelProvider</span>(ViewModelStores.of(activity), factory);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ViewModelProvider <span class="title function_">of</span><span class="params">(<span class="meta">@NonNull</span> Fragment fragment, <span class="meta">@NonNull</span> Factory factory)</span> &#123;</span><br><span class="line">        checkApplication(checkActivity(fragment));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ViewModelProvider</span>(ViewModelStores.of(fragment), factory);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ViewModelProvider <span class="title function_">of</span><span class="params">(<span class="meta">@NonNull</span> FragmentActivity activity,</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> Factory factory)</span> &#123;</span><br><span class="line">        checkApplication(activity);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ViewModelProvider</span>(ViewModelStores.of(activity), factory);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>ViewModelProviders提供了四个of()方法，四个方法功能类似，其中of(FragmentActivity activity, Factory factory)和of(Fragment fragment, Factory factory)提供了自定义创建ViewModel的方法。</p>
<p>判断Fragment的是否Attached to Activity，Activity的Application对象是否为空。<br>创建ViewModel对象看似很简单，一行代码搞定。<br>new ViewModelProvider(ViewModelStores.of(fragment), factory)<br>先看看ViewModelStores.of()方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ViewModelStore <span class="title function_">of</span><span class="params">(<span class="meta">@NonNull</span> Fragment fragment)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (fragment <span class="keyword">instanceof</span> ViewModelStoreOwner) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((ViewModelStoreOwner) fragment).getViewModelStore();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> holderFragmentFor(fragment).getViewModelStore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续深入发现其实是实现了一个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ViewModelStoreOwner</span> &#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    ViewModelStore <span class="title function_">getViewModelStore</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>holderFragmentFor()是HolderFragment的静态方法，HolderFragment继承自Fragment。我们先看holderFragment()方法的具体实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> HolderFragment <span class="title function_">holderFragmentFor</span><span class="params">(Fragment fragment)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sHolderFragmentManager.holderFragmentFor(fragment);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ViewModelStore <span class="title function_">getViewModelStore</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mViewModelStore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续看HolderFragmentManager.holderFragmentFor()方法的具体实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">HolderFragment <span class="title function_">holderFragmentFor</span><span class="params">(Fragment parentFragment)</span> &#123;</span><br><span class="line">            <span class="type">FragmentManager</span> <span class="variable">fm</span> <span class="operator">=</span> parentFragment.getChildFragmentManager();</span><br><span class="line">            <span class="type">HolderFragment</span> <span class="variable">holder</span> <span class="operator">=</span> findHolderFragment(fm);</span><br><span class="line">            <span class="keyword">if</span> (holder != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> holder;</span><br><span class="line">            &#125;</span><br><span class="line">            holder = mNotCommittedFragmentHolders.get(parentFragment);</span><br><span class="line">            <span class="keyword">if</span> (holder != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> holder;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            parentFragment.getFragmentManager()</span><br><span class="line">                    .registerFragmentLifecycleCallbacks(mParentDestroyedCallback, <span class="literal">false</span>);</span><br><span class="line">            holder = createHolderFragment(fm);</span><br><span class="line">            mNotCommittedFragmentHolders.put(parentFragment, holder);</span><br><span class="line">            <span class="keyword">return</span> holder;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="type">FragmentLifecycleCallbacks</span> <span class="variable">mParentDestroyedCallback</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">FragmentLifecycleCallbacks</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFragmentDestroyed</span><span class="params">(FragmentManager fm, Fragment parentFragment)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.onFragmentDestroyed(fm, parentFragment);</span><br><span class="line">            <span class="type">HolderFragment</span> <span class="variable">fragment</span> <span class="operator">=</span> mNotCommittedFragmentHolders.remove(</span><br><span class="line">                    parentFragment);</span><br><span class="line">            <span class="keyword">if</span> (fragment != <span class="literal">null</span>) &#123;</span><br><span class="line">                Log.e(LOG_TAG, <span class="string">&quot;Failed to save a ViewModel for &quot;</span> + parentFragment);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> HolderFragment <span class="title function_">createHolderFragment</span><span class="params">(FragmentManager fragmentManager)</span> &#123;</span><br><span class="line">    <span class="type">HolderFragment</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HolderFragment</span>(); <span class="comment">// 创建HolderFragment对象</span></span><br><span class="line">    fragmentManager.beginTransaction().add(holder, HOLDER_TAG).commitAllowingStateLoss();</span><br><span class="line">    <span class="keyword">return</span> holder;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HolderFragment</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//这个是关键，这就使得Activity被recreate时，Fragment的onDestroy()和onCreate()不会被调用</span></span><br><span class="line">    setRetainInstance(<span class="literal">true</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>setRetainInstance(boolean) 是Fragment中的一个方法。将这个方法设置为true就可以使当前Fragment在Activity重建时存活下来, 如果不设置或者设置为 false, 当前 Fragment 会在 Activity 重建时同样发生重建, 以至于被新建的对象所替代。</p>
<p>在setRetainInstance(boolean)为true的 Fragment 中放一个专门用于存储ViewModel的Map, 自然Map中所有的ViewModel都会幸免于Activity重建，让Activity, Fragment都绑定一个这样的Fragment, 将ViewModel存放到这个 Fragment 的 Map 中, ViewModel 组件就这样实现了。</p>
<p>到此为止，我们已经得到了ViewStore对象，前面我们在创建ViewModelProvider对象是通过这行代码实现的new ViewModelProvider(ViewModelStores.of(fragment), sDefaultFactory)现在再看下ViewModelProvider的构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ViewModelProvider</span><span class="params">(<span class="meta">@NonNull</span> ViewModelStore store, <span class="meta">@NonNull</span> Factory factory)</span> &#123;</span><br><span class="line">        mFactory = factory;</span><br><span class="line">        <span class="built_in">this</span>.mViewModelStore = store;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>现在就可以通过ViewModelProvider.get()方法得到ViewModel对象，继续看下该方法的具体实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">ViewModel</span>&gt; T <span class="title function_">get</span><span class="params">(<span class="meta">@NonNull</span> String key, <span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> &#123;</span><br><span class="line">    <span class="type">ViewModel</span> <span class="variable">viewModel</span> <span class="operator">=</span> mViewModelStore.get(key); <span class="comment">//从缓存中查找是否有已有ViewModel对象。</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (modelClass.isInstance(viewModel)) &#123;</span><br><span class="line">        <span class="comment">//noinspection unchecked</span></span><br><span class="line">        <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//noinspection StatementWithEmptyBody</span></span><br><span class="line">        <span class="keyword">if</span> (viewModel != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> log a warning.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    viewModel = mFactory.create(modelClass); <span class="comment">//创建ViewModel对象，然后缓存起来。</span></span><br><span class="line">    mViewModelStore.put(key, viewModel);</span><br><span class="line">    <span class="comment">//noinspection unchecked</span></span><br><span class="line">    <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ViewModelProvider.get()方法比较简单，注释中都写明了。最后我们看下ViewModelStore类的具体实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewModelStore</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, ViewModel&gt; mMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, ViewModel viewModel)</span> &#123;</span><br><span class="line">        <span class="type">ViewModel</span> <span class="variable">oldViewModel</span> <span class="operator">=</span> mMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (oldViewModel != <span class="literal">null</span>) &#123;</span><br><span class="line">            oldViewModel.onCleared();</span><br><span class="line">        &#125;</span><br><span class="line">        mMap.put(key, viewModel);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">final</span> ViewModel <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (ViewModel vm : mMap.values()) &#123;</span><br><span class="line">            vm.onCleared();</span><br><span class="line">        &#125;</span><br><span class="line">        mMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ViewModelStore是缓存ViewModel的类，put()、get()方法用于存取ViewModel对象，另外提供了clear()方法用于清空缓存的ViewModel对象，在该方法中会调用ViewModel.onCleared()方法通知ViewModel对象不再被使用。</p>
<p>ViewModel收到onCleared()通知<br>HolderFragment的onDestroy()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onDestroy();</span><br><span class="line">    mViewModelStore.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在onDestroy()方法中调用了ViewModelStore.clear()方法，我们知道在该方法中会调用ViewModel的onCleared()方法。在你看了HolderFragment源码后，或许你会有个疑问，mViewModelStore保存的ViewModel对象是在哪里添加的呢？ 细心的话，你会发现在ViewModelProvider的构造方法中，已经将HolderFragment中的ViwModelStore对象mViewModelStore的引用传递给了ViewModelProvider中的mViewModelStore，而在ViewModelProvider.get()方法中会向mViewModelStore添加ViewModel对象。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ViewModel职责是为Activity或Fragment管理、请求数据，具体数据请求逻辑不应该写在ViewModel中，否则ViewModel的职责会变得太重，此处需要一个引入一个Repository，负责数据请求相关工作。具体请参考 Android架构组件。<br>ViewModel可以用于Activity内不同Fragment的交互，也可以用作Fragment之间一种解耦方式。<br>ViewModel也可以负责处理部分Activity&#x2F;Fragment与应用其他模块的交互。<br>ViewModel生命周期（以Activity为例）起始于Activity第一次onCreate()，结束于Activity最终finish时。</p>
<h2 id="Room"><a href="#Room" class="headerlink" title="Room"></a>Room</h2><p>Room是Google推出的Android架构组件库中的数据持久化组件库, 也可以说是在SQLite上实现的一套ORM解决方案。Room主要包含三个部分：</p>
<ul>
<li>Database : 持有DB和DAO</li>
<li>Entity : 定义POJO类，即数据表结构</li>
<li>DAO(Data Access Objects) : 定义访问数据（增删改查）的接口<br>其关系如下图所示：<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/android/.1606970791952.png" alt="Alt text"></li>
</ul>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p> 一个简单的Entitiy<br>一个简单Entity定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity(tableName = &quot;user&quot; </span></span><br><span class="line"><span class="meta">          indices = &#123;@Index(value = &#123;&quot;first_name&quot;, &quot;last_name&quot;&#125;)&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@PrimaryKey</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> uid;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@ColumnInfo(name = &quot;first_name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@ColumnInfo(name = &quot;last_name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Ignore</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String firstName, String lastName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.uid = UUID.randomUUID().toString();</span><br><span class="line">        <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">        <span class="built_in">this</span>. lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String id, String firstName, String lastName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.uid = id;</span><br><span class="line">        <span class="built_in">this</span>.firstName = userName;</span><br><span class="line">        <span class="built_in">this</span>. lastName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>@Entity(tableName &#x3D; “table_name**”) 注解POJO类，定义数据表名称;</li>
<li>@PrimaryKey 定义主键，如果一个Entity使用的是复合主键，可以通过@Entity注解的primaryKeys 属性定义复合主键：- @Entity(primaryKeys &#x3D; {“firstName”, “lastName”})</li>
<li>@ColumnInfo(name &#x3D; “column_name”) 定义数据表中的字段名</li>
<li>@Ignore 用于告诉Room需要忽略的字段或方法</li>
<li>建立索引：在@Entity注解的indices属性中添加索引字段。例如：indices &#x3D; {@Index(value &#x3D; {“first_name”, “last_name”}, unique &#x3D; true), …}, unique &#x3D; true可以确保表中不会出现{“first_name”, “last_name”} 相同的数据。</li>
</ul>
<h3 id="Entitiy间的关系"><a href="#Entitiy间的关系" class="headerlink" title="Entitiy间的关系"></a>Entitiy间的关系</h3><p>不同于目前存在的大多数ORM库，Room不支持Entitiy对象间的直接引用。（具体原因可以参考： Understand why Room doesn’t allow object references）<br>但Room允许通过外键(Foreign Key)来表示Entity之间的关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity(foreignKeys = @ForeignKey(entity = User.class,</span></span><br><span class="line"><span class="meta">                                  parentColumns = &quot;id&quot;,</span></span><br><span class="line"><span class="meta">                                  childColumns = &quot;user_id&quot;))</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="meta">@PrimaryKey</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> bookId;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String title;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@ColumnInfo(name = &quot;user_id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> userId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上面代码所示，Book对象与User对象是属于的关系。Book中的user_id,对应User中的id。 那么当一个User对象被删除时， 对应的Book会发生什么呢？</p>
<p>@ForeignKey注解中有两个属性onDelete和onUpdate， 这两个属性对应ForeignKey中的onDelete()和onUpdate(), 通过这两个属性的值来设置当User对象被删除／更新时，Book对象作出的响应。这两个属性的可选值如下：</p>
<ul>
<li>CASCADE：User删除时对应Book一同删除； 更新时，关联的字段一同更新</li>
<li>NO_ACTION：User删除时不做任何响应</li>
<li>RESTRICT：禁止User的删除／更新。当User删除或更新时，Sqlite会立马报错。</li>
<li>SET_NULL：当User删除时， Book中的userId会设为NULL</li>
<li>SET_DEFAULT：与SET_NULL类似，当User删除时，Book中的userId会设为默认值</li>
</ul>
<p>###对象嵌套<br>在某些情况下， 对于一张表中的数据我们会用多个POJO类来表示，在这种情况下可以用@Embedded注解嵌套的对象，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String street;</span><br><span class="line">    <span class="keyword">public</span> String state;</span><br><span class="line">    <span class="keyword">public</span> String city;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@ColumnInfo(name = &quot;post_code&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> postCode;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@PrimaryKey</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String firstName;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Embedded</span></span><br><span class="line">    <span class="keyword">public</span> Address address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码所产生的User表中，Column 为id, firstName, street, state, city, post_code</p>
<h3 id="创建数据访问对象（DAO）"><a href="#创建数据访问对象（DAO）" class="headerlink" title="创建数据访问对象（DAO）"></a>创建数据访问对象（DAO）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Query(&quot;SELECT * FROM user&quot;)</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">getAll</span><span class="params">()</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Query(&quot;SELECT * FROM user WHERE uid IN (:userIds)&quot;)</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">loadAllByIds</span><span class="params">(<span class="type">int</span>[] userIds)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Query(&quot;SELECT * FROM user WHERE first_name LIKE :first AND &quot;</span></span><br><span class="line"><span class="meta">           + &quot;last_name LIKE :last LIMIT 1&quot;)</span></span><br><span class="line">    User <span class="title function_">findByName</span><span class="params">(String first, String last)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insertAll</span><span class="params">(List&lt;User&gt; users)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Insert(onConflict = OnConflictStrategy.REPLACE)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertUsers</span><span class="params">(User... users)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Delete</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(User user)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Update</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUsers</span><span class="params">(List&lt;User&gt; users)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DAO 可以是一个接口，也可以是一个抽象类， Room会在编译时创建DAO的实现。</p>
<p>Tips:</p>
<ul>
<li>@Insert方法也可以定义返回值， 当传入参数仅有一个时返回long, 传入多个时返回long[]或List<Long>, Room在实现insert方法的实现时会在一个事务进行所有参数的插入。</li>
<li>@Insert的参数存在冲突时， 可以设置onConflict属性的值来定义冲突的解决策略， 比如代码中定义的是@Insert(onConflict &#x3D; OnConflictStrategy.REPLACE), 即发生冲突时替换原有数据</li>
<li>@Update和@Delete 可以定义int类型返回值，指更新／删除的函数<br>DAO中的增删改方法的定义都比较简单，这里不展开讨论，下面更多的聊一下查询方法。</li>
</ul>
<p>2.1 简单的查询<br>Talk is cheap, 直接show code:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query(&quot;SELECT * FROM user&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">getAll</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Room会在编译时校验sql语句，如果@Query() 中的sql语句存在语法错误，或者查询的表不存在，Room会在编译时报错。</p>
</blockquote>
<h3 id="查询参数传递"><a href="#查询参数传递" class="headerlink" title="查询参数传递"></a>查询参数传递</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query(&quot;SELECT * FROM user WHERE uid IN (:userIds)&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">loadAllByIds</span><span class="params">(<span class="type">int</span>[] userIds)</span>;</span><br><span class="line"><span class="meta">@Query(&quot;SELECT * FROM user WHERE first_name LIKE :first AND &quot;</span></span><br><span class="line"><span class="meta">           + &quot;last_name LIKE :last LIMIT 1&quot;)</span></span><br><span class="line">User <span class="title function_">findByName</span><span class="params">(String first, String last)</span>;</span><br></pre></td></tr></table></figure>
<p>看代码应该比较好理解， 方法中传递参数arg, 在sql语句中用:arg即可。编译时Room会匹配对应的参数。</p>
<blockquote>
<p>如果在传参中没有匹配到:arg对应的参数, Room会在编译时报错。</p>
</blockquote>
<h3 id="查询表中部分字段的信息"><a href="#查询表中部分字段的信息" class="headerlink" title="查询表中部分字段的信息"></a>查询表中部分字段的信息</h3><p>在实际某个业务场景中， 我们可能仅关心一个表部分字段的值，这时我仅需要查询关心的列即可。</p>
<p>定义子集的POJO类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NameTuple</span> &#123;</span><br><span class="line">    <span class="meta">@ColumnInfo(name=&quot;first_name&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String firstName;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@ColumnInfo(name=&quot;last_name&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在DAO中添加查询方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query(&quot;SELECT first_name, last_name FROM user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;NameTuple&gt; <span class="title function_">loadFullName</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里定义的POJO也支持使用@Embedded</p>
</blockquote>
<h3 id="查询结果的返回类型"><a href="#查询结果的返回类型" class="headerlink" title="查询结果的返回类型"></a>查询结果的返回类型</h3><p>Room中查询操作除了返回POJO对象及其List以外， 还支持：</p>
<ul>
<li><p>LiveData<T>:<br>LiveData是架构组件库中提供的另一个组件，可以很好满足数据变化驱动UI刷新的需求。Room会实现更新LiveData的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query(&quot;SELECT first_name, last_name FROM user WHERE region IN (:regions)&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> LiveData&lt;List&lt;User&gt;&gt; <span class="title function_">loadUsersFromRegionsSync</span><span class="params">(List&lt;String&gt; regions)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Flowablbe<T> Maybe<T> Single<T>:<br>Room 支持返回RxJava2 的Flowablbe, Maybe和Single对象，对于使用RxJava的项目可以很好的衔接， 但需要在gradle添加该依赖：android.arch.persistence.room:rxjava2。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query(&quot;SELECT * from user where id = :id LIMIT 1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Flowable&lt;User&gt; <span class="title function_">loadUserById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Cursor:<br>返回Cursor是为了支持现有项目中使用Cursor的场景，官方不建议直接返回Cursor.</p>
<blockquote>
<p>Caution: It’s highly discouraged to work with the Cursor API because it doesn’t guarantee whether the rows exist or what values the rows contain. Use this functionality only if you already have code that expects a cursor and that you can’t refactor easily.</p>
</blockquote>
</li>
</ul>
<h3 id="联表查询"><a href="#联表查询" class="headerlink" title="联表查询"></a>联表查询</h3><p>Room支持联表查询，接口定义上与其他查询差别不大， 主要还是sql语句的差别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyDao</span> &#123;</span><br><span class="line">    <span class="meta">@Query(&quot;SELECT * FROM book &quot;</span></span><br><span class="line"><span class="meta">           + &quot;INNER JOIN loan ON loan.book_id = book.id &quot;</span></span><br><span class="line"><span class="meta">           + &quot;INNER JOIN user ON user.id = loan.user_id &quot;</span></span><br><span class="line"><span class="meta">           + &quot;WHERE user.name LIKE :userName&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">findBooksBorrowedByNameSync</span><span class="params">(String userName)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>Room中DataBase类似SQLite API中SQLiteOpenHelper，是提供DB操作的切入点，但是除了持有DB外， 它还负责持有相关数据表（Entity）的数据访问对象（DAO）, 所以Room中定义Database需要满足三个条件：</p>
<p>继承RoomDataBase，并且是一个抽象类<br>用@Database 注解，并定义相关的entity对象， 当然还有必不可少的数据库版本信息<br>定义返回DAO对象的抽象方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Database(entities = &#123;User.class&#125;, version = 1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AppDatabase</span> <span class="keyword">extends</span> <span class="title class_">RoomDatabase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> UserDao <span class="title function_">userDao</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建好以上Room的三大组件后， 在代码中就可以通过以下代码创建Database实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AppDatabase</span> <span class="variable">db</span> <span class="operator">=</span> Room.databaseBuilder(getApplicationContext(),</span><br><span class="line">        AppDatabase.class, <span class="string">&quot;database-name&quot;</span>).build();</span><br></pre></td></tr></table></figure>
<h3 id="数据库迁移"><a href="#数据库迁移" class="headerlink" title="数据库迁移"></a>数据库迁移</h3><p>3.1 Room数据库升级<br>在传统的SQLite API中，我们如果要升级数据库， 通常在SQLiteOpenHelper.onUpgrade方法执行数据库升级的sql语句，这些sql语句的通常根据数据库版本以文件的方式或者用数组来管理。有人说这种方式升级数据库就像在拆炸弹，相比之下在Room中升级数据库简单的就像是按一个开关而已。</p>
<p>Room提供了Migration类来实现数据库的升级:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Room.databaseBuilder(getApplicationContext(), MyDb.class, <span class="string">&quot;database-name&quot;</span>)</span><br><span class="line">        .addMigrations(MIGRATION_1_2, MIGRATION_2_3).build();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Migration</span> <span class="variable">MIGRATION_1_2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Migration</span>(<span class="number">1</span>, <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">migrate</span><span class="params">(SupportSQLiteDatabase database)</span> &#123;</span><br><span class="line">        database.execSQL(<span class="string">&quot;CREATE TABLE `Fruit` (`id` INTEGER, &quot;</span></span><br><span class="line">                + <span class="string">&quot;`name` TEXT, PRIMARY KEY(`id`))&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Migration</span> <span class="variable">MIGRATION_2_3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Migration</span>(<span class="number">2</span>, <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">migrate</span><span class="params">(SupportSQLiteDatabase database)</span> &#123;</span><br><span class="line">        database.execSQL(<span class="string">&quot;ALTER TABLE Book &quot;</span></span><br><span class="line">                + <span class="string">&quot; ADD COLUMN pub_year INTEGER&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在创建Migration类时需要指定startVersion和endVersion, 代码中MIGRATION_1_2和MIGRATION_2_3的startVersion和endVersion是递增的， Migration其实是支持从版本1直接升到版本3，只要其migrate()方法里执行的语句正常即可。那么Room是怎么实现数据库升级的呢？其实本质上还是调用SQLiteOpenHelper.onUpgrade，Room中自己实现了一个SQLiteOpenHelper， 在onUpgrade()方法被调用时触发Migration，当第一次访问数据库时，Room做了以下几件事：</p>
<ul>
<li>创建Room Database实例</li>
<li>SQLiteOpenHelper.onUpgrade被调用，并且触发Migration</li>
<li>打开数据库</li>
</ul>
<p>这样一看， Room中处理数据库升级确实很像是加一个开关。</p>
<p>3.2 原有SQLite数据库迁移至Room<br>因为Room使用的也是SQLite， 所以可以很好的支持原有Sqlite数据库迁移到Room。</p>
<p>假设原有一个版本号为1的数据库有一张表User, 现在要迁移到Room， 我们需要定义好Entity, DAO, Database, 然后创建Database时添加一个空实现的Migraton即可。需要注意的是，即使对数据库没有任何升级操作，也需要升级版本， 否则会抛异常IllegalStateException.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Database(entities = &#123;User.class&#125;, version = 2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">UsersDatabase</span> <span class="keyword">extends</span> <span class="title class_">RoomDatabase</span> &#123;</span><br><span class="line">…</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Migration</span> <span class="variable">MIGRATION_1_2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Migration</span>(<span class="number">1</span>, <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">migrate</span><span class="params">(SupportSQLiteDatabase database)</span> &#123;</span><br><span class="line">        <span class="comment">// Since we didn&#x27;t alter the table, there&#x27;s nothing else to do here.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">…</span><br><span class="line">database =  Room.databaseBuilder(context.getApplicationContext(),</span><br><span class="line">        UsersDatabase.class, <span class="string">&quot;Sample.db&quot;</span>)</span><br><span class="line">        .addMigrations(MIGRATION_1_2)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>
<h3 id="复杂数据的处理"><a href="#复杂数据的处理" class="headerlink" title="复杂数据的处理"></a>复杂数据的处理</h3><p>在某些场景下我们的应用可能需要存储复杂的数据类型，比如Date，但是Room的Entity仅支持基本数据类型和其装箱类之间的转换，不支持其它的对象引用。所以Room提供了TypeConverter给使用者自己实现对应的转换。</p>
<p>一个Date类型的转换如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Converters</span> &#123;</span><br><span class="line">    <span class="meta">@TypeConverter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">fromTimestamp</span><span class="params">(Long value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value == <span class="literal">null</span> ? <span class="literal">null</span> : <span class="keyword">new</span> <span class="title class_">Date</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@TypeConverter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">dateToTimestamp</span><span class="params">(Date date)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> date == <span class="literal">null</span> ? <span class="literal">null</span> : date.getTime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义好转换方法后，指定到对应的Database上即可， 这样就可以在对应的POJO（User）中使用Date类了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Database(entities = &#123;User.class&#125;, version = 1)</span></span><br><span class="line"><span class="meta">@TypeConverters(&#123;Converters.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AppDatabase</span> <span class="keyword">extends</span> <span class="title class_">RoomDatabase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> UserDao <span class="title function_">userDao</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>在SQLite API方式实现数据持久化的项目中，相信都有一个任务繁重的SQLiteOpenHelper实现, 一堆维护表的字段的Constant类， 一堆代码类似的数据库访问类（DAO），访问数据库时需要做Cursor的遍历，构建并返回对应的POJO类…相比之下，Room作为在SQLite之上封装的ORM库确实有诸多优势，比较直观的体验是：</p>
<ul>
<li>比SQLite API更简单的使用方式</li>
<li>省略了许多重复代码</li>
<li>能在编译时校验sql语句的正确性</li>
<li>数据库相关的代码分为Entity, DAO, Database三个部分，结构清晰</li>
<li>简单安全的数据库升级方案</li>
</ul>
<p>想要了解更多Room相关内容可以戳下面的链接：</p>
<p>Google Sample <a target="_blank" rel="noopener" href="https://github.com/googlesamples/android-architecture-components">https://github.com/googlesamples/android-architecture-components</a><br>Room数据库迁移<a target="_blank" rel="noopener" href="https://medium.com/google-developers/understanding-migrations-with-room-f01e04b07929">https://medium.com/google-developers/understanding-migrations-with-room-f01e04b07929</a><br>Room使用引导说明 <a target="_blank" rel="noopener" href="https://medium.com/google-developers/7-steps-to-room-27a5fe5f99b2">https://medium.com/google-developers/7-steps-to-room-27a5fe5f99b2</a><br>Room 🔗 RxJava <a target="_blank" rel="noopener" href="https://medium.com/google-developers/room-rxjava-acb0cd4f3757">https://medium.com/google-developers/room-rxjava-acb0cd4f3757</a><br>7 Pro-tips for Room <a target="_blank" rel="noopener" href="https://medium.com/google-developers/7-pro-tips-for-room-fbadea4bfbd1">https://medium.com/google-developers/7-pro-tips-for-room-fbadea4bfbd1</a></p>
<h2 id="DataBinding"><a href="#DataBinding" class="headerlink" title="DataBinding"></a>DataBinding</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/AndroidAlvin/article/details/103161348">引入</a></p>
<h2 id="WorkManager"><a href="#WorkManager" class="headerlink" title="WorkManager"></a>WorkManager</h2><p>WorkManager是google提供的异步执行任务的管理框架，会根据手机的API版本和应用程序的状态来选择适当的方式执行任务。当应用在运行的时候会在应用的进程中开一条线程来执行任务，当退出应用时，WorkManager会选择根据设备的API版本使用适合的算法调用JobScheduler或者Firebase JobDispatcher,或者AlarmManager来执行任务。如下图：<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/android/.1606972273371.png" alt="Alt text"><br>由上图可以看出WorkManager管理任务执行时底层还是调用JobScheduler,JobDispatcher,AlarmManager，不过WorkManager会根据Android系统的API和应用的运行状态来选择合适的方式执行，并不用我们自己去考虑应用复杂的运行状态来进行选择使用JobScheduler还是JobDispatcher或者AlarmManager调用规则如下图：</p>
<p><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/android/.1606972281244.png" alt="Alt text"></p>
<h3 id="WorkManager在项目中配置"><a href="#WorkManager在项目中配置" class="headerlink" title="WorkManager在项目中配置"></a>WorkManager在项目中配置</h3><p>使用WorkManager需要gradle依赖，进行一下简单配置就可以使用了。找到项目中的app&#x2F;build.gradle目录下在上面加上下面的依赖。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// 其他依赖配置</span></span><br><span class="line">    <span class="type">def</span> <span class="variable">work_version</span> <span class="operator">=</span> <span class="string">&quot;1.0.0-beta02&quot;</span></span><br><span class="line">    implementation <span class="string">&quot;android.arch.work:work-runtime:$work_version&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以在<a target="_blank" rel="noopener" href="https://developer.android.com/topic/libraries/architecture/adding-components#workmanager%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%9A%84work-runtime%E7%89%88%E6%9C%AC%E5%B9%B6%E4%B8%94%E8%AE%BE%E7%BD%AE%E6%AD%A3%E7%A1%AE%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%B7%E3%80%82">https://developer.android.com/topic/libraries/architecture/adding-components#workmanager获取当前的work-runtime版本并且设置正确的版本号。</a></p>
<h3 id="WorkManager主要类及使用"><a href="#WorkManager主要类及使用" class="headerlink" title="WorkManager主要类及使用"></a>WorkManager主要类及使用</h3><p>如下图给出了WorkManager中主要的类以及关系图，黄色区域是最主要的三个类，构成了WorkManager的基本框架，红色部分和绿色部分是关联的黄色部分的具体实现或者类里面包含一些规则或数据。<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/android/.1606972322216.png" alt="Alt text"><br>1、Worker处理要执行的任务的具体逻辑。</p>
<p>2、WorkerRequest代表一个独立的可以执行的任务，以及任务执行时的条件和规则，比如说任务执行一次还是多次以及任务的触发条件是什么任务有什么约束等。</p>
<p>3、WorkManager提供队列将要执行的WorkerRequest放到队列中管理和执行。<br>如下图，三个主要类的关系：<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/android/.1606972387392.png" alt="Alt text"><br>下面分别介绍三个类的作用和使用方法。</p>
<p>Worker<br>Worker是一个抽象类，当有一个要执行的任务的时候可以继承Worker类，重写doWork()方法在doWork()方法中实现具体任务的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWorker</span> <span class="keyword">extends</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyWorker</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> Context appContext,</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> WorkerParameters workerParams)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(appContext, workerParams);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Worker.Result <span class="title function_">doWork</span><span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="type">Context</span> <span class="variable">applicationContext</span> <span class="operator">=</span> getApplicationContext();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="type">Bitmap</span> <span class="variable">picture</span> <span class="operator">=</span> BitmapFactory.decodeResource(</span><br><span class="line">                    applicationContext.getResources(),</span><br><span class="line">                    R.drawable.test);</span><br><span class="line">                    </span><br><span class="line">            <span class="keyword">return</span> Worker.Result.SUCCESS;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">return</span> Worker.Result.FAILURE;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的MyWorker实例中，继承了Worker 并且重写了doWork()方法，需要注意的是doWork()方法是有返回值Worker.Result的，可以在任务执行成功是返回Worker.Result.SUCCESS，在任务执行出现异常时返回Worker.Result.FAILURE<br>doWork()方法的返回值主要有三种<br>1、Worker.Result.SUCCESS 表示任务执行成功</p>
<p>2、Worker.Result.FAILURE 表示任务执行失败</p>
<p>3、Worker.Result.RETRY 通知WorkManager之后再尝试执行该任务</p>
<p>WorkRequest<br>WorkRequest要指定执行任务的Worker，也可以给WorkRequest加一些规则，比如说什么时候执行任务，任务执行一次还是多次，每一个WorkRequest都有一个自动产生的唯一ID，可以根据唯一ID获取对应任务的状态以及是否取消对应的任务。如下图WorkRequest有两个实现类如下图：<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/android/.1606972431496.png" alt="Alt text"><br>1、OneTimeWorkRequest 任务只执行一次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OneTimeWorkRequest</span> <span class="variable">myWorkRequest</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">OneTimeWorkRequest</span>.Builder(MyWorker.class)</span><br><span class="line">    .build();</span><br><span class="line">    <span class="comment">//将上面定义的MyWorker加入到OneTimeRequest.Builder方法中</span></span><br><span class="line">WorkManager.getInstance().enqueue(myWorkRequest);<span class="comment">//获取WorkManager实例并将WorkRequest进队</span></span><br></pre></td></tr></table></figure>
<p>2、PeriodicWorkRequest<br>PeriodicWorkRequest重复执行任务，直到被取消才停止。首次执行是任务提交后立即执行或者满足所给的 Constraints条件。以后执行都会根据所给的时间间隔来执行。注意任务的执行可能会有延时，因为WorkManager会根据OS的电量进行优化。<br>假如设置的Periodic Work是24小时执行一次，有可能根据电池优化策略执行的过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>     | Jan <span class="number">01</span>, <span class="number">06</span>:<span class="number">00</span> AM</span><br><span class="line"><span class="number">2</span>     | Jan <span class="number">02</span>, <span class="number">06</span>:<span class="number">24</span> AM</span><br><span class="line"><span class="number">3</span>     | Jan <span class="number">03</span>, <span class="number">07</span>:<span class="number">15</span> AM</span><br><span class="line"><span class="number">4</span>     | Jan <span class="number">04</span>, 08:<span class="number">00</span> AM</span><br><span class="line"><span class="number">5</span>     | Jan <span class="number">05</span>, 08:<span class="number">00</span> AM</span><br><span class="line"><span class="number">6</span>     | Jan <span class="number">06</span>, 08:<span class="number">02</span> AM</span><br></pre></td></tr></table></figure>
<p>由上面的执行时间可以看出，PeriodicWorkRequest并不是准确的按照24小时来执行，会有一定的时间延迟。因此如果需要准确的间隔时间来执行任务的话不能使用PeriodicWorkRequest。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Constraints</span> <span class="variable">constraints</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Constraints</span>.Builder().setRequiredNetworkType(NetworkType.CONNECTED).build();</span><br><span class="line"><span class="type">PeriodicWorkRequest</span> <span class="variable">build</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PeriodicWorkRequest</span>.Builder(MyWorker.class, <span class="number">25</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">           .addTag(TAG)</span><br><span class="line">           .setConstraints(constraints)</span><br><span class="line">           .build();</span><br><span class="line"> </span><br><span class="line"><span class="type">WorkManager</span> <span class="variable">instance</span> <span class="operator">=</span> WorkManager.getInstance();</span><br><span class="line"><span class="keyword">if</span> (instance != <span class="literal">null</span>) &#123;</span><br><span class="line">          instance.enqueueUniquePeriodicWork(TAG, ExistingPeriodicWorkPolicy.REPLACE, build);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Constraints<br>可以给任务加一些运行的Constraints条件，比如说当设备空闲时或者正在充电或者连接WiFi时执行任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Constraints</span> <span class="variable">myConstraints</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Constraints</span>.Builder()</span><br><span class="line">    .setRequiresDeviceIdle(<span class="literal">true</span>)</span><br><span class="line">    .setRequiresCharging(<span class="literal">true</span>)</span><br><span class="line">    <span class="comment">// Many other constraints are available, see the</span></span><br><span class="line">    <span class="comment">// Constraints.Builder reference</span></span><br><span class="line">     .build();</span><br><span class="line"><span class="type">OneTimeWorkRequest</span> <span class="variable">myWork</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">OneTimeWorkRequest</span>.Builder(CompressWorker.class)</span><br><span class="line">     .setConstraints(myConstraints)</span><br><span class="line">     .build();</span><br></pre></td></tr></table></figure>
<p>WorkManager<br>WorkManager管理WorkRequest队列。并根据设备和其他条件选择执行的具体方式。在大部分情况在如果没有给队列加Contraints，WorkManager会立即执行任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WorkManager.getInstance().enqueue(myWork);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果要检查任务的执行状态可以通过获取WorkInfo,WorkInfo在WorkManager里面的LiveData<WorkInfo>中。下面是判断任务是否结束的方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WorkManager.getInstance().getWorkInfoByIdLiveData(myWork.getId())</span><br><span class="line">    .observe(lifecycleOwner, workInfo -&gt; &#123;</span><br><span class="line">        <span class="comment">// Do something with the status</span></span><br><span class="line">        <span class="keyword">if</span> (workInfo != <span class="literal">null</span> &amp;&amp; workInfo.getState().isFinished()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>取消任务执行<br>通过任务的ID可以获取任务从而取消任务。任务ID可以从WorkRequest中获取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UUID</span> <span class="variable">compressionWorkId</span> <span class="operator">=</span> compressionWork.getId();</span><br><span class="line">WorkManager.getInstance().cancelWorkById(compressionWorkId);</span><br></pre></td></tr></table></figure>
<p>注意并不是所有的任务都可以取消，当任务正在执行时是不能取消的，当然任务执行完成了，取消也是意义的，也就是说当任务加入到ManagerWork的队列中但是还没有执行时才可以取消。</p>
<p>WorkManager多任务调度<br>有时候可能有很多任务需要执行，并且这些任务之前可能有先后顺序或者某些依赖关系，WorkManager提供了很好的方式。<br>1、先后顺序执行单个任务<br>比如说有三个任务workA,workB,workC,并且执行顺序只能时workA—-&gt;workB—-&gt;workC可以用如下的方式处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WorkManager.getInstance()</span><br><span class="line">    .beginWith(workA)</span><br><span class="line">    .then(workB)  instance</span><br><span class="line">    .then(workC)</span><br><span class="line">    .enqueue();</span><br></pre></td></tr></table></figure>
<p>上面的workA,workB,workC,都是WorkRequest的子类实现对象。WorkManager会根据上面的先后顺序来执行workA,workB,workC,，但是如果执行过程中三个任务中有一个失败，整个执行都会结束。并且返回Result.failure()。<br>2、先后顺序执行多个任务列<br>有时候可能要先执行一组任务，然后再执行下一组任务，可以使用下面的方式来完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WorkManager.getInstance()</span><br><span class="line">    <span class="comment">// First, run all the A tasks (in parallel):</span></span><br><span class="line">    .beginWith(Arrays.asList(workA1, workA2, workA3))</span><br><span class="line">    <span class="comment">// ...when all A tasks are finished, run the single B task:</span></span><br><span class="line">    .then(workB)</span><br><span class="line">    <span class="comment">// ...then run the C tasks (in any order):</span></span><br><span class="line">    .then(Arrays.asList(workC1, workC2))</span><br><span class="line">    .enqueue();</span><br></pre></td></tr></table></figure>
<p>3、多路径先后执行<br>上面两种方式都是单路径执行，可以实现更加复杂的多路径执行方式，使用WorkContinuation.combine(List<OneTimeWorkRequest>)如下图要实现的执行方式：<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/android/.1606972635024.png" alt="Alt text"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">WorkContinuation</span> <span class="variable">chain1</span> <span class="operator">=</span> WorkManager.getInstance()</span><br><span class="line">    .beginWith(workA)</span><br><span class="line">    .then(workB);</span><br><span class="line"><span class="type">WorkContinuation</span> <span class="variable">chain2</span> <span class="operator">=</span> WorkManager.getInstance()</span><br><span class="line">    .beginWith(workC)</span><br><span class="line">    .then(workD);</span><br><span class="line"><span class="type">WorkContinuation</span> <span class="variable">chain3</span> <span class="operator">=</span> WorkContinuation</span><br><span class="line">    .combine(Arrays.asList(chain1, chain2))</span><br><span class="line">    .then(workE);</span><br><span class="line">chain3.enqueue();</span><br></pre></td></tr></table></figure>
<p>使用WorkManager遇到的问题<br>1、使用PeriodicWorkRequest只执行一次，并不重复执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WorkManager instance= <span class="keyword">new</span> <span class="title class_">PeriodicWorkRequest</span>.Builder(PollingWorker.class, <span class="number">10</span>, TimeUnit.MINUTES)</span><br><span class="line">           .build();</span><br></pre></td></tr></table></figure>
<p>原因：PeriodicWorkRequest默认的时间间隔是15分钟如果设置的时间小于15分钟，就会出现问题。</p>
<p>解决方法：设置的默认时间必须大于或等于15分钟。另外要注意，就算设置的时间为15分钟也不一定间隔15分钟就执行。</p>
<p>2、在doWork()方法中更新UI导致崩溃。<br>原因：doWork()方法是在WorkManager管理的后台线程中执行的，更新UI操作只能在主线程中进行。</p>
<p>解决方法：当doWork()耗时方法执行完之后，将更新UI操作抛到主线中执行，可以用handle来实现，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created time 15:32.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> huhanjun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/1/23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PollingWorker</span> <span class="keyword">extends</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;PollingWorker&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">doWork</span><span class="params">()</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;doWork&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            polling();</span><br><span class="line">            runOnUIThread(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">//更新UI操作</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> Result.SUCCESS;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;failure&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> Result.FAILURE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">polling</span><span class="params">()</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;Polling&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">runOnUIThread</span><span class="params">(Runnable runnable)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Handler</span>(Looper.getMainLooper()).post(runnable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在执行完Polling方法后，将更新操作抛给了runOnUIThread()方法，这样就可以在上面代码注释的地方执行更新操作。<br>##Lifecycle<br>生命周期感知组件可以在其他组件（例如 activity 和 fragment）的生命周期状态更改时执行操作。这些组件可帮助我们生成更轻量级且更容易维护的代码。</p>
<p>我们通常会在 activity 和 fragment 的生命周期方法中实现自己的业务逻辑。但是，这种方式会导致我们代码组织的不良和出错的增加。但是通过使用生命周期感知组件，我们就可以将依赖组件生命周期的代码移出生命周期方法。</p>
<p>android.arch.lifecycle 包提供的类和接口，使我们可以构建生命周期感知组件 - 这些组件可以根据 activity 和 fragment 的当前生命周期状态自动调整其行为。</p>
<p>Android Framework 中定义的大多数应用程序组件都附加了生命周期。生命周期由操作系统或进程中运行的 Framework 代码管理。它们是Android工作原理的核心，我们的应用程序必须遵循它们，如果不这样做可能会触发内存泄漏甚至应用程序崩溃。</p>
<p>假设我们现在有一个 activity ，用来在手机屏幕上显示设备位置。常见的实现可能如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLocationListener</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLocationListener</span><span class="params">(Context context, Callback callback)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// connect to system location service</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// disconnect from system location service</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MyLocationListener myLocationListener;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(...)</span> &#123;</span><br><span class="line">        myLocationListener = <span class="keyword">new</span> <span class="title class_">MyLocationListener</span>(<span class="built_in">this</span>, (location) -&gt; &#123;</span><br><span class="line">            <span class="comment">// update UI</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onStart();</span><br><span class="line">        myLocationListener.start();</span><br><span class="line">        <span class="comment">// manage other components that need to respond</span></span><br><span class="line">        <span class="comment">// to the activity lifecycle</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onStop();</span><br><span class="line">        myLocationListener.stop();</span><br><span class="line">        <span class="comment">// manage other components that need to respond</span></span><br><span class="line">        <span class="comment">// to the activity lifecycle</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管这个示例看起来很好，但在实际的应用程序中，最终会有太多的回调来管理 UI 和 其他组件以响应生命周期的当前状态。管理多个组件会在生命周期方法中放置大量代码，导致如 onStart() 和 onStop() 这样的方法难以维护。</p>
<p>此外，我们无法保证 MyLocationListener 在 MyActivity 停止之前启动，如果我们需要执行长时间运行的操作（例如在 onStart() 中进行一些 配置检查），这会导致 MyActivity 的 onStop() 完成之前而这个操作才会回调，这就使组件保持活动的时间会长于其所需的时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MyLocationListener myLocationListener;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(...)</span> &#123;</span><br><span class="line">        myLocationListener = <span class="keyword">new</span> <span class="title class_">MyLocationListener</span>(<span class="built_in">this</span>, location -&gt; &#123;</span><br><span class="line">            <span class="comment">// update UI</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onStart();</span><br><span class="line">        Util.checkUserStatus(result -&gt; &#123;</span><br><span class="line">            <span class="comment">// what if this callback is invoked AFTER activity is stopped?</span></span><br><span class="line">            <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                myLocationListener.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onStop();</span><br><span class="line">        myLocationListener.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>android.arch.lifecycle 包提供了类和接口，可以帮助我们以弹性和隔离的方式解决这些问题。</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>Lifecycle 是一个持有关于组件（如 activity 或fragment）生命周期状态信息并允许其他对象观察此状态的类。</p>
<p>Lifecycle 使用两个主要枚举来跟踪其关联组件的生命周期状态：</p>
<p>Event</p>
<p>从 Framework 和 Lifecycle 类分发生命周期事件 。这些事件映射到 activities 和 fragments 中的回调事件。</p>
<p>State</p>
<p>通过 Lifecycle 对象来跟踪组件的当前状态 。<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/android/.1606972987369.png" alt="Alt text"><br>将 State 视为图形的节点，将 Event 视为这些节点之间的边缘。</p>
<p>一个类可以通过向组件的方法添加注解来监视其生命周期状态。我们可以通过调用 Lifecycle 类的 addObserver() 方法来添加观察者，并传递观察者的实例，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyObserver</span> <span class="keyword">implements</span> <span class="title class_">LifecycleObserver</span> &#123;</span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_RESUME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connectListener</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">disconnectListener</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">myLifecycleOwner.getLifecycle().addObserver(<span class="keyword">new</span> <span class="title class_">MyObserver</span>());</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，myLifecycleOwner 对象实现了 LifecycleOwner 接口，这个在下一节中进行说明。</p>
<p>###LifecycleOwner<br>LifecycleOwner 是一个接口，它只有一个 getLifecycle() 方法，表明实现LifecycleOwner接口的类有一个 Lifecycle 。如果你正在尝试管理整个应用进程的生命周期，可以看下 ProcessLifecycleOwner。</p>
<p>LifecycleOwner 接口从个别类（例如Fragment 和 AppCompatActivity）中抽象出了 Lifecycle 的所有权，并允许编写与其一起使用的组件。任何自定义类都可以实现 LifecycleOwner 接口。</p>
<p>实现了 LifecycleObserver 的组件与实现了 LifecycleOwner 的组件可以无缝工作，因为所有者可以提供生命周期，观察者可以注册观察。</p>
<p>例如位置跟踪的例子，我们可以使 MyLocationListener类实现 LifecycleObserver ，然后在 activity 生命周期的 onCreate() 方法中初始化它，这意味着响应生命周期状态变化的逻辑可以被声明在 MyLocationListener 而不是 activity，当把逻辑代码置于在各个组件中后，就能使 activities 和 fragments 更易于管理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MyLocationListener myLocationListener;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(...)</span> &#123;</span><br><span class="line">        myLocationListener = <span class="keyword">new</span> <span class="title class_">MyLocationListener</span>(<span class="built_in">this</span>, getLifecycle(), location -&gt; &#123;</span><br><span class="line">            <span class="comment">// update UI</span></span><br><span class="line">        &#125;);</span><br><span class="line">        Util.checkUserStatus(result -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                myLocationListener.enable();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个常见的用例是，如果 Lifecycle 现在不处于激活状态，则应避免调用某些回调 。例如：如果回调在 Activity 状态被保存到 onSaveInstanceState() 后运行 Fragment Transaction，就会触发崩溃，因此我们会避免调用该回调。</p>
<p>为了简化这个用例， Lifecycle 类允许其他对象查询当前状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLocationListener</span> <span class="keyword">implements</span> <span class="title class_">LifecycleObserver</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">enabled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLocationListener</span><span class="params">(Context context, Lifecycle lifecycle, Callback callback)</span> &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_START)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (enabled) &#123;</span><br><span class="line">           <span class="comment">// connect</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enable</span><span class="params">()</span> &#123;</span><br><span class="line">        enabled = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (lifecycle.getCurrentState().isAtLeast(STARTED)) &#123;</span><br><span class="line">            <span class="comment">// connect if not connected</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_STOP)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// disconnect if connected</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这种实现，我们的LocationListener类完全可以感知生命周期。如果我们需要从另一个 activity 或 fragment 使用LocationListener，我们只需要初始化它。所有设置和卸载操作都由LocationListener类本身管理。</p>
<p>如果一个库提供了需要使用Android生命周期的类，Google 建议我们使用生命周期感知组件。我们的客户端可以轻松地集成这些组件，而无需在客户端进行手动管理生命周期。</p>
<h3 id="实现自定义LifecycleOwner"><a href="#实现自定义LifecycleOwner" class="headerlink" title="实现自定义LifecycleOwner"></a>实现自定义LifecycleOwner</h3><p>在 Support Library 26.1.0 及更高版本的 Fragments 和 Activities 已实现了 LifecycleOwner 接口。</p>
<p>如果你想让自定义的类成为 LifecycleOwner，可以使用 LifecycleRegistry 类，但是你需要将生命周期事件转发到此类，如以下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> <span class="keyword">implements</span> <span class="title class_">LifecycleOwner</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LifecycleRegistry mLifecycleRegistry;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line"> </span><br><span class="line">        mLifecycleRegistry = <span class="keyword">new</span> <span class="title class_">LifecycleRegistry</span>(<span class="built_in">this</span>);</span><br><span class="line">        mLifecycleRegistry.markState(Lifecycle.State.CREATED);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onStart();</span><br><span class="line">        mLifecycleRegistry.markState(Lifecycle.State.STARTED);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Lifecycle <span class="title function_">getLifecycle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mLifecycleRegistry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生命周期感知组件的最佳实践"><a href="#生命周期感知组件的最佳实践" class="headerlink" title="生命周期感知组件的最佳实践"></a>生命周期感知组件的最佳实践</h3><p>尽可能精简我们的 UI 控制器（Activity 和 Fragment）。它们不应该尝试获取自己的数据， 相反，应该使用 ViewModel 来执行此操作，并观察 LiveData 对象以将数据更改反映到视图上。</p>
<p>编写数据驱动的UI，UI控制器负责在数据更改时更新视图，或者将用户操作通知给 ViewModel 。</p>
<p>把我们的数据逻辑放在 ViewModel 类中。 ViewModel 应该作为 UI 控制器和应用程序其余部分之间的桥接器。不过 ViewModel 是没有获取数据（例如从网络）的职责的。相反， ViewModel 应该调用合适的组件（例如 Repository组件）来获取数据，然后将结果提供给 UI 控制器。</p>
<p>使用 Data Binding 在 视图 和 UI 控制器之间维持一个干净的界面。这会使我们的视图更具声明性，并最大限度地减少在 Activity 和 Fragment 中编写所需的更新代码。如果你更喜欢使用Java 编程语言执行此操作，那就使用 Butter Knife 之类的库来避免样板代码，使代码具有更好的抽象。</p>
<p>如果你的 UI 很复杂，可以考虑创建一个 presenter 类来处理UI修改。这可能是一项蛋疼的任务，但是它可以让我们的 UI 组件更容易测试。</p>
<p>避免在你的 ViewModel 中引用 View 或 Activity 的 context 。如果 ViewModel 的存活时间超过这个activity（如在 configuration 更改的情况下），导致垃圾收集器未正确处理 activity 造成内存泄露。</p>
<h3 id="生命周期感知组件的用例"><a href="#生命周期感知组件的用例" class="headerlink" title="生命周期感知组件的用例"></a>生命周期感知组件的用例</h3><p>生命周期感知组件可以让我们在各种情况下更轻松地管理生命周期。比如以下场景：</p>
<p>在粗粒度和细粒度的位置更新之间切换。使用生命周期感知组件可在我们的位置应用程序可见时启用细粒度位置更新，并在应用程序位于后台时切换到粗粒度更新。LiveData 是一个生命周期感知组件，它允许我们的应用在用户更改位置时自动更新 UI。</p>
<p>停止和开始视频缓冲。使用生命周期感知组件可以尽快开启视频缓冲，但推迟播放直到应用程序完全启动。我们还可以使用生命周期感知组件在销毁应用程序时终止缓冲。</p>
<p>开启和停止网络连接。使用生命周期感知组件在应用程序处于前台时启用网络数据的实时更新（流式传输），并在应用程序进入后台时自动暂停。</p>
<p>暂停和恢复动画绘制。当应用程序在后台时，使用生命周期感知组件暂停绘制动画内容，并在应用程序位于前台后恢复绘制内容。</p>
<h3 id="处理-ON-STOP-事件"><a href="#处理-ON-STOP-事件" class="headerlink" title="处理 ON_STOP 事件"></a>处理 ON_STOP 事件</h3><p>如果一个 Lifecycle 属于一个 AppCompatActivity 或 Fragment，当 AppCompatActivity 或 Fragment 的 onSaveInstanceState() 方法被调用时， 这个 Lifecycle 的状态就会变为 CREATED ，它的 ON_STOP 事件也会被分发 。</p>
<p>当一个 AppCompatActivity 或 Fragment 的状态被保存到 onSaveInstanceState() 后，它的UI在 ON_START 被调用之前被认为是不可变的 。保存状态后尝试修改UI 可能会导致应用程序的导航状态不一致，这就是为什么如果应用程序在保存状态后运行 FragmentTransaction ，FragmentManager 会抛出异常的原因，详细原因请查看 commit() 。</p>
<p>如果观察者的关联 Lifecycle 不是STARTED 状态， LiveData 会通过避免调用其观察者来防止这种边缘情况开箱即用。在背后，它会确保在调用它的观察者之前调用 isAtLeast() 。</p>
<p>蛋疼的是，AppCompatActivity 的 onStop() 方法会在 onSaveInstanceState() 之后调用，这就导致程序留下了不允许更改UI状态但 Lifecycle 又还没转变为 CREATED 状态的间隔。</p>
<p>为了防止出现此问题， Lifecycle 类的 beta2 版本以及更低版本将 CREATED 状态标记为不调度事件，即使在系统调用 onStop() 之前未调度事件，任何检查当前状态的代码都会获得实际值。</p>
<p>悲催的是这个解决方案有两个重大问题：</p>
<p>在API 23 和更低级别，Android系统实际上保存了 activity 的状态，即使它被另一个 activity 部分覆盖。换句话说，Android系统调用 onSaveInstanceState() 但不一定要调用 onStop() 。这会创建一个潜在的长间隔，即使无法修改其UI状态，观察者仍然- - 认为生命周期处于活跃状态。</p>
<p>任何类想要向 LiveData 类暴露类似行为 都必须实现 Lifecycle beta 2 版本 和更低版本提供的解决方法 。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>为了使此流程更简单并提供与旧版本的更好兼容性，从1.0.0-rc1版本开始，在调用 onSaveInstanceState() 时 Lifecycle 对象被标记为 CREATED 并且调度 ON_STOP ，而无须等待调用 onStop() 方法。这可能不会影响我们的代码，但我们需要注意这一点，因为它与 API 26及更低级别的Activity 类中的调用顺序不匹配。</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>王水泥</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://uncle2000.github.io/post/Android/JetPack/">https://uncle2000.github.io/post/Android/JetPack/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/blog/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/blog/post/%E5%85%B6%E4%BB%96/hexo%E6%90%AD%E5%BB%BA%E9%85%8D%E7%BD%AE/">hexo搭建配置</a>
            
            
            <a class="next" rel="next" href="/blog/post/java/%5Bjava%5D%5B%E8%BF%9B%E7%A8%8B+%E7%BA%BF%E7%A8%8B%5D%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/">进程和线程</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 王水泥 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>
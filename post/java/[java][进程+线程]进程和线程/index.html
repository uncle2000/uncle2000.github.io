<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="王水泥">


    <meta name="subtitle" content="技术，etc">


    <meta name="description" content="不要传播">



<title>进程和线程 | 王水泥个人博客</title>



    <link rel="icon" href="/blog/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/blog/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/blog/js/script.js"></script>
    
    <script src="/blog/js/tocbot.min.js"></script>
    




<meta name="generator" content="Hexo 5.4.2"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/blog/">王水泥的博客</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/blog/archives">Posts</a>
                
                    <a class="menu-item" href="/blog/category">Categories</a>
                
                    <a class="menu-item" href="/blog/tag">Tags</a>
                
                    <a class="menu-item" href="/blog/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/blog/">王水泥的博客</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/blog/archives">Posts</a>
                
                    <a class="menu-item" href="/blog/category">Categories</a>
                
                    <a class="menu-item" href="/blog/tag">Tags</a>
                
                    <a class="menu-item" href="/blog/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">进程和线程</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">王水泥</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">十一月 1, 2022&nbsp;&nbsp;16:23:33</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/blog/categories/java/">java</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="java-进程-线程-进程和线程"><a href="#java-进程-线程-进程和线程" class="headerlink" title="[java][进程\线程]进程和线程"></a>[java][进程\线程]进程和线程</h1><p>@[java, 进程\线程]<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/AndroidAlvin/article/details/103161680">引入</a></p>
<p>[toc]</p>
<h2 id="网上和书上的说法："><a href="#网上和书上的说法：" class="headerlink" title="网上和书上的说法："></a>网上和书上的说法：</h2><blockquote>
<p>进程就是程序执行的一个实例<br>进程的目的就是担当分配系统资源（CPU时间，内存）的实体<br>线程是操作系统能够进行运算调度的最小单位<br>也就是说CPU的执行内容是由线程来决定的，而线程的执行环境则是由进程来分配的。</p>
</blockquote>
<h3 id="进程（Process）"><a href="#进程（Process）" class="headerlink" title="进程（Process）"></a>进程（Process）</h3><blockquote>
<pre><code>    表示资源分配的基本单位，又是调度运行的基本单位。列入，用户运行自己的程序，系统就创建一个进程，并为它分配资源，包括各种表格，内存空间，磁盘空间，I/O设备等。然后，吧该进程放入进程的就绪队列。进程调度程序选中它，为它分配CPU以及其他有关资源，该进程才真正的运行。所以，进程是系统中的并发执行单位。
   在mac,Windows NT等采用微内核结构的操作系统中，进程的功能发生了变化：它只是资源分配的单位，而不再是调度运行的单位。在微内核系统中，真正调度运行的基本单位是线程。因此，实现并发功能的单位是线程。
   是系统进行资源分配和调度的基本单位，是操作系统结构的基础。
   进程的概念主要有两点：第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为进程。
</code></pre>
</blockquote>
<h4 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h4><blockquote>
<pre><code>   进行进程切换就是从正在运行的进程中收回处理器，然后再使待运行进程来占用处理器。 这里所说的从某个进程收回处理器，实质上就是把进程存放在处理器的寄存器中的中间数据找个地方存起来，从而把处理器的寄存器腾出来让其他进程使用。那么被中止运行进程的中间数据存在何处好呢？当然这个地方应该是进程的私有堆栈。
</code></pre>
</blockquote>
<h4 id="和“程序”的区别"><a href="#和“程序”的区别" class="headerlink" title="和“程序”的区别"></a>和“程序”的区别</h4><blockquote>
<pre><code>程序是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。而进程是程序在处理机上的一次执行过程，它是一个动态的概念。
程序可以作为一种软件资料长期存在，而进程是有一定生命期的。程序是永久的，进程是暂时的。
</code></pre>
</blockquote>
<h3 id="线程（Thread）"><a href="#线程（Thread）" class="headerlink" title="线程（Thread）"></a>线程（Thread）</h3><blockquote>
<pre><code>是进程中执行运算的最小单位，亦即执行处理机调度的基本单位。如果把进程理解为在逻辑上操作系统所完成的任务，那么线程表示完成该任务的许多可能子任务之一。线程可以在处理器上独立调度执行，这样，在多处理器环境下就允许几个线程各自在单独处理器上进行。操作系统提供线程就算为了方便而有效的实现这种并发性。
有时被称为轻量进程(Lightweight Process，LWP），是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成。
一条线程指的是进程中一个单一顺序的控制流
同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage）。
线程是进程中的实体，一个进程可以拥有多个线程，一个线程必须有一个父进程。线程不拥有系统资源，只有运行必须的一些数据结构；它与父进程的其它线程共享该进程所拥有的全部资源。线程可以创建和撤消线程，从而实现程序的并发执行。一般，线程具有就绪、阻塞和运行三种基本状态。
在多中央处理器的系统里，不同线程可以同时在不同的中央处理器上运行，甚至当它们属于同一个进程时也是如此。大多数支持多处理器的操作系统都提供编程接口来让进程可以控制自己的线程与各处理器之间的关联度（affinity）。
</code></pre>
</blockquote>
<h4 id="线程的引入"><a href="#线程的引入" class="headerlink" title="线程的引入"></a>线程的引入</h4><blockquote>
<pre><code>60年代，在OS中能拥有资源和独立运行的基本单位是进程，然而随着计算机技术的发展，进程出现了很多弊端，一是由于进程是资源拥有者，创建、撤消与切换存在较大的时空开销，因此需要引入轻型进程；二是由于对称多处理机（SMP）出现，可以满足多个运行单位，而多个进程并行开销过大。 因此在80年代，出现了能独立运行的基本单位——线程（Threads）。
</code></pre>
</blockquote>
<h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><blockquote>
<pre><code>守护线程是特殊的线程，一般用于在后台为其他线程提供服务.
Java中，isDaemon()：判断一个线程是否为守护线程.
Java中，setDaemon()：设置一个线程为守护线程.
</code></pre>
</blockquote>
<h4 id="如何正确的停止线程"><a href="#如何正确的停止线程" class="headerlink" title="如何正确的停止线程"></a>如何正确的停止线程</h4><blockquote>
<pre><code>Thread.stop()不安全
应该使用interruput方法
</code></pre>
</blockquote>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>xxx</p>
<blockquote>
<p>如果线程是通过线程池创建，线程异常发生时UncaughtExceptionHandler接口不一定会立即回调。</p>
</blockquote>
<h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>跟线程没什么关系，打电话</p>
<blockquote>
<p>同步：打电话 -&gt; 处理（没挂断） -&gt; 反馈<br>异步：打电话 -&gt; 处理（挂断）-&gt; 打回来</p>
</blockquote>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><blockquote>
<pre><code>不带返回值的一个函数调用
</code></pre>
</blockquote>
<h4 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h4><blockquote>
<pre><code>进程和线程的主要差别在于他们是不同的操作系统的资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其他进程产生影响。而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程直接没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要查一下，但对于一些要求同时进行并发且又要共享某些变量的并发操作，只能用线程，不能用进程。
1.简而言之，一个程序至少有一个进程，一个进程至少有一个线程
2.线程的划分尺度小于进程，使得多个线程程序的并发性高
3.另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大的提高了程序的运行效率
4.线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口，顺序执行序列和程序的出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
5.从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看作是多个独立的应用，来实现进程的调度和管理以及资源分配。
</code></pre>
</blockquote>
<h3 id="进程之间通信（IPC：InterProcess-Communication）的方式及优缺点"><a href="#进程之间通信（IPC：InterProcess-Communication）的方式及优缺点" class="headerlink" title="进程之间通信（IPC：InterProcess Communication）的方式及优缺点"></a>进程之间通信（IPC：InterProcess Communication）的方式及优缺点</h3><h4 id="1管道"><a href="#1管道" class="headerlink" title="1管道"></a>1管道</h4><h5 id="无名管道"><a href="#无名管道" class="headerlink" title="无名管道"></a>无名管道</h5><p>无名管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系一般指父子关系。无名管道一般用于两个不同进程之间的通信。当一个进程创建一个管道，并调用fork创建自己的一个子进程后，父进程关闭读管道端，这样就提供两个进程之间数据流动的一种方式</p>
<h5 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a>有名管道</h5><p>有名管道也是一种半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p>
<blockquote>
<p>无名管道：优点：简单方便。缺点：1局限于单向通信。2只能创建在它的进程以及其有亲缘关系的进程之间。3缓冲区有限。<br>有名管道：优点：可以实现任意关系的进程间的通信。缺点：1长期存于系统中，使用不当容易出错。2缓冲区有限。</p>
</blockquote>
<h4 id="2信号量"><a href="#2信号量" class="headerlink" title="2信号量"></a>2信号量</h4><p>信号量是一个计数器，可以用来控制多个线程对共享资源的访问，它不是用于交换大批数据，而是用于多线程之间的同步，它常作为一种锁机制，防止某些进程在访问资源时，其他进程也访问该资源。因此，主要作为进程之间以及同一个进程内不同线程之间的同步手段。</p>
<blockquote>
<p>优点：可以同步进程。缺点：信号量有限</p>
</blockquote>
<h4 id="3信号"><a href="#3信号" class="headerlink" title="3信号"></a>3信号</h4><p>信号是一种比较复杂的通信方式，用于通知接受进程某个事件已经发生。</p>
<h4 id="4消息队列"><a href="#4消息队列" class="headerlink" title="4消息队列"></a>4消息队列</h4><p>消息队列是消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点。消息队列是UNIX下不同进程之间可以实现共享资源的一种机制，UNIX允许不同进程将格式化的数据流以消息队列形式发送给任意进程，对消息队列具有操作权限的进程可以使用msget完成对消息队列的操作控制，通过使用消息类型，进程可以按任何顺序读信息。或为消息安排优先级顺序。</p>
<blockquote>
<p>优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接受之间的同步，无需考虑同步问题，方便。<br>缺点：信息的复制需要额外消耗CPU时间，不适宜于信息量大或操作频繁的场合</p>
</blockquote>
<h4 id="5共享内存"><a href="#5共享内存" class="headerlink" title="5共享内存"></a>5共享内存</h4><p>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC(进程间通信)的方式，它是针对其他进程间通信方式运行效率低而专门设计的，它往往与其他通信机制配合使用，用于实现进程之间的同步与通信。</p>
<blockquote>
<p>优点：无须复制，快捷，信息量大；<br>缺点：1通信是通过将无法实现共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作同步问题。2利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信</p>
</blockquote>
<h4 id="6套接字（Socket）"><a href="#6套接字（Socket）" class="headerlink" title="6套接字（Socket）"></a>6套接字（Socket）</h4><blockquote>
<p>优点：1传输数据为字节级，传输数据可自定义，数据量小，效率高。2传输数据时间短，性能高.3适用于客户端和服务端之间信息实时交互。4可以加密，数据安全性强。<br>缺点：需要对传输的数据进行解析，转化成应用级的数据。</p>
</blockquote>
<h3 id="线程之间的通信方式"><a href="#线程之间的通信方式" class="headerlink" title="线程之间的通信方式"></a>线程之间的通信方式</h3><h4 id="1锁机制（互斥锁，条件变量，读写锁…）"><a href="#1锁机制（互斥锁，条件变量，读写锁…）" class="headerlink" title="1锁机制（互斥锁，条件变量，读写锁…）"></a>1锁机制（互斥锁，条件变量，读写锁…）</h4><ul>
<li>互斥锁提供了以排他方式房主数据结构被并发修改的方法</li>
<li>读写锁允许多个线程同时读共享数据，而对写操作是互斥的。</li>
<li>条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li>
</ul>
<h4 id="2信号量机制（Semaphore）"><a href="#2信号量机制（Semaphore）" class="headerlink" title="2信号量机制（Semaphore）"></a>2信号量机制（Semaphore）</h4><p>包括无名线程信号量和命名线程信号量</p>
<h4 id="3信号机制（Signal）"><a href="#3信号机制（Signal）" class="headerlink" title="3信号机制（Signal）"></a>3信号机制（Signal）</h4><p>类似进程间的信号处理<br><code>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</code></p>
<h2 id="简而言之"><a href="#简而言之" class="headerlink" title="简而言之"></a>简而言之</h2><p>对操作系统来说，一个独立运行的程序，就是进程，是操作系统分配内存资源的最小单位<br>一个程序里面，不同的执行路径 就是一个线程，是CPU最小执行的单元，也就是内核空间。</p>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="CPU核心数、线程数"><a href="#CPU核心数、线程数" class="headerlink" title="CPU核心数、线程数"></a>CPU核心数、线程数</h3><p>两者的关系：cpu的核心数与线程数是1:1的关系，例如一个8核的cpu，支持8个线程同时运行。但在intel引入超线程技术以后，cpu与线程数的关系就变成了1:2。此外在开发过程中并没感觉到线程的限制，那是因为<code>cpu时间片轮转机制（RR调度）</code>的算法的作用。</p>
<h3 id="CPU时间片轮转机制"><a href="#CPU时间片轮转机制" class="headerlink" title="CPU时间片轮转机制"></a>CPU时间片轮转机制</h3><p>含义就是：cpu给每个进程分配一个“时间段”，这个时间段就叫做这个进程的“时间片”，这个时间片就是这个进程允许运行的时间，如果当这个进程的时间片段结束，操作系统就会把分配给这个进程的cpu剥夺，分配给另外一个进程。如果进程在时间片还没结束的情况下阻塞了，或者说进程跑完了，cpu就会进行切换。<code>cpu在两个进程之间的切换称为“上下文切换”</code>，上下文切换是需要时间的，大约需要花费5000~20000（5毫秒到20毫秒，这个花费的时间是由操作系统决定）个时钟周期，尽管我们平时感觉不到。所以在开发过程中要注意上下文切换（两个进程之间的切换）对我们程序性能的影响。</p>
<h2 id="线程之间的共享"><a href="#线程之间的共享" class="headerlink" title="线程之间的共享"></a>线程之间的共享</h2><h3 id="synchronized内置锁"><a href="#synchronized内置锁" class="headerlink" title="synchronized内置锁"></a>synchronized内置锁</h3><p>线程开始运行，拥有自己的栈空间，就如同一个脚本一样，按照既定的代码一步一步地执行，直到终止。但是，每个运行中的线程，如果仅仅是孤立地运行，那么没有一点儿价值，或者说价值很少，如果多个线程能够相互配合完成工作，包括数据之间的共享，协同处理事情。这将会带来巨大的价值。</p>
<p>Java支持多个线程同时访问一个对象或者对象的成员变量，关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性，又称为内置锁机制。</p>
<h3 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h3><p>volatile保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">boolean</span> ready;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> number;</span><br></pre></td></tr></table></figure>
<p>不加volatile时，子线程无法感知主线程修改了ready的值，从而不会退出循环，而加了volatile后，子线程可以感知主线程修改了ready的值，迅速退出循环。但是volatile不能保证数据在多个线程下同时写时的线程安全，参见代码：<br>thread-platform\src\com\chj\thread\capt01\volatiles\NotSafe.java<br>volatile最适用的场景：一个线程写，多个线程读。</p>
<h3 id="线程私有变量-ThreadLocal"><a href="#线程私有变量-ThreadLocal" class="headerlink" title="线程私有变量 ThreadLocal"></a>线程私有变量 ThreadLocal</h3><ul>
<li>get() 获取每个线程自己的threadLocals中的本地变量副本。</li>
<li>set() 设置每个线程自己的threadLocals中的线程本地变量副本。<br>ThreadLocal有一个内部类ThreadLocalMap:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">//根据当前的线程返回一个ThreadLocalMap.点进去getMap</span></span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//点击去getMap(t)方法发现其实返回的是当前线程t的一个内部变量ThreadLocal.ThreadLocalMap</span></span><br><span class="line">        ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//由此可以知道，当调用ThreadLocal的get方法是，其实返回的是当前线程的threadLocals(类型是ThreadLocal.ThreadLocalMap)中的变量。调用set方法也类似。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//举例一个使用场景</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ThreadLocal使用场景：把数据库连接对象存放在ThreadLocal当中.</span></span><br><span class="line"><span class="comment"> * 优点：减少了每次获取Connection需要创建Connection</span></span><br><span class="line"><span class="comment"> * 缺点：因为每个线程本地会存放一份变量，需要考虑内存的消耗问题。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luke Lin</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectionThreadLocal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">DB_URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306:test&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder  = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Connection&gt;()&#123;</span><br><span class="line">        <span class="keyword">protected</span> Connection <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> DriverManager.getConnection(DB_URL);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> connectionHolder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">releaseConnection</span><span class="params">()</span>&#123;</span><br><span class="line">        connectionHolder.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//解决ThreadLocal中弱引用导致内存泄露的问题的建议</span></span><br><span class="line">    + 声明ThreadLoal时，使用<span class="keyword">private</span> <span class="keyword">static</span>修饰</span><br><span class="line">    + 线程中如果本地变量不再使用，即使使用remove()</span><br></pre></td></tr></table></figure>
<h2 id="线程间的协作"><a href="#线程间的协作" class="headerlink" title="线程间的协作"></a>线程间的协作</h2><p>wait() notify() notifyAll()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//1.3.1通知等候唤醒模式</span></span><br><span class="line"> <span class="comment">//1)等候方</span></span><br><span class="line">    获取对象的锁</span><br><span class="line">    在循环中判断是否满足条件，如果不满足条件，执行wait，阻塞等待。</span><br><span class="line">    如果满足条件跳出循环，执行自己的业务代码</span><br><span class="line">            </span><br><span class="line"> <span class="comment">//2)通知方</span></span><br><span class="line">     获取对象的锁</span><br><span class="line">     更改条件</span><br><span class="line">     执行notifyAll通知等等待方</span><br><span class="line">  <span class="comment">//1.3.2 </span></span><br><span class="line">  <span class="comment">//wait notify notifyAll都是对象内置的方法</span></span><br><span class="line">  <span class="comment">//wait notify notifyAll 都需要加synchronized内被执行，否则会抱错。</span></span><br><span class="line">  <span class="comment">//执行wait方法是，会让出对象持有的锁，直到以下2个情况发生：1。被notify/notifyAll唤醒。2。wait超时</span></span><br><span class="line">  <span class="comment">//1.3.3 举例使用wait(int millis),notifyAll实现一个简单的线城池超时连接</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 连接池，支持连接超时。</span></span><br><span class="line"><span class="comment"> * 当连接超过一定时间后，做超时处理。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBPool2</span> &#123;</span><br><span class="line">    LinkedList&lt;Connection&gt; pools;</span><br><span class="line">    <span class="comment">//初始化一个指定大小的新城池</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DBPool2</span> <span class="params">(<span class="type">int</span> poolSize)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(poolSize &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            pools =  <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Connection&gt;(); </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; poolSize; i++)&#123;</span><br><span class="line">                pools.addLast(SqlConnectImpl.fetchConnection());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> remain 等待超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">fetchConn</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 超时时间必须大于0，否则抛一场</span></span><br><span class="line">        <span class="keyword">synchronized</span> (pools) &#123;</span><br><span class="line">            <span class="keyword">if</span> (millis&lt;<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span>(pools.isEmpty()) &#123;</span><br><span class="line">                    pools.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> pools.removeFirst();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 超时时间</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">timeout</span> <span class="operator">=</span> System.currentTimeMillis() + millis;</span><br><span class="line">                <span class="type">long</span> <span class="variable">remain</span> <span class="operator">=</span> millis;</span><br><span class="line">                <span class="comment">// 如果当前pools的连接为空，则等待timeout，如果timeout时间还没有返回，则返回null。</span></span><br><span class="line">                <span class="keyword">while</span> (pools.isEmpty() &amp;&amp; remain &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        pools.wait(remain);</span><br><span class="line">                        remain = timeout - System.currentTimeMillis();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">Connection</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (!pools.isEmpty()) &#123;</span><br><span class="line">                    result = pools.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">releaseConn</span><span class="params">(Connection con)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> != con)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (pools) &#123;</span><br><span class="line">                pools.addLast(con);</span><br><span class="line">                pools.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sleep() yield()<br>join()<br>面试点：线程A执行了线程B的join方法，那么线程A必须等到线程B执行以后，线程A才会继续自己的工作。<br>wait() notify() yield() sleep()对锁的影响<br>面试点:<br>线程执行yield(),线程让出cpu执行时间，和其他线程同时竞争cup执行机会，但如果持有的锁不释放。<br>线程执行sleep(),线程让出cpu执行时间，在sleep()醒来前都不竞争cpu执行时间，但如果持有的锁不释放。<br>notify调用前必须持有锁，调用notify方法本身不会释放锁。<br>wait()方法调用前必须持有锁，调用了wait方法之后，锁就会被释放。当wait方法返回的时候，线程会重新持有锁。</p>
<h1 id="CAS（比较和交换Conmpare-And-Swap）"><a href="#CAS（比较和交换Conmpare-And-Swap）" class="headerlink" title="CAS（比较和交换Conmpare And Swap）"></a>CAS（比较和交换Conmpare And Swap）</h1><p>是用于实现多线程同步的原子指令。 它将内存位置的内容与给定值进行比较，只有在相同的情况下，将该内存位置的内容修改为新的给定值。 这是作为单个原子操作完成的。 原子性保证新值基于最新信息计算; 如果该值在同一时间被另一个线程更新，则写入将失败。 操作结果必须说明是否进行替换; 这可以通过一个简单的布尔响应（这个变体通常称为比较和设置），或通过返回从内存位置读取的值来完成（摘自维基本科）</p>
<p>JAVA1.5开始引入了CAS，主要代码都放在JUC的atomic包下，如下图：</p>
<h2 id="CAS导致的ABA问题"><a href="#CAS导致的ABA问题" class="headerlink" title="CAS导致的ABA问题"></a>CAS导致的ABA问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote>
<p>多线程情况下，每个线程使用CAS操作欲将数据A修改成B，当然我们只希望只有一个线程能够正确的修改数据，并且只修改一次。当并发的时候，其中一个线程已经将A成功的改成了B，但是在线程并发调度过程中尚未被调度，在这个期间，另外一个线程(不在并发中的请求线程)将B又修改成了A，那么原来并发中的线程又可以通过CAS操作将A改成B</p>
</blockquote>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>java中提供了AtomicStampedReference来解决这个问题，它是基于版本或者是一种状态，在修改的过程中不仅对比值，也同时会对比版本号</p>
<p> private static final AtomicStampedReference<String> ATOMIC_STAMPED_REFERENCE &#x3D; new AtomicStampedReference&lt;&gt;(A,0);</p>
<h1 id="线程池-1"><a href="#线程池-1" class="headerlink" title="线程池"></a>线程池</h1><p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title class_">AbstractExecutorService</span> &#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,<span class="type">int</span> maximumPoolSize,<span class="type">long</span> keepAliveTime,TimeUnit unit,</span></span><br><span class="line"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,<span class="type">int</span> maximumPoolSize,<span class="type">long</span> keepAliveTime,TimeUnit unit,</span></span><br><span class="line"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,<span class="type">int</span> maximumPoolSize,<span class="type">long</span> keepAliveTime,TimeUnit unit,</span></span><br><span class="line"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,<span class="type">int</span> maximumPoolSize,<span class="type">long</span> keepAliveTime,TimeUnit unit,</span></span><br><span class="line"><span class="params">        BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="corePoolSize："><a href="#corePoolSize：" class="headerlink" title="corePoolSize："></a>corePoolSize：</h3><p>核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；</p>
<h3 id="maximumPoolSize："><a href="#maximumPoolSize：" class="headerlink" title="maximumPoolSize："></a>maximumPoolSize：</h3><p>线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；</p>
<h3 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h3><p>表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；</p>
<h3 id="unit"><a href="#unit" class="headerlink" title="unit"></a>unit</h3><p>参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性：</p>
<ul>
<li><p>TimeUnit.DAYS;               &#x2F;&#x2F;天</p>
</li>
<li><p>TimeUnit.HOURS;             &#x2F;&#x2F;小时</p>
</li>
<li><p>TimeUnit.MINUTES;           &#x2F;&#x2F;分钟</p>
</li>
<li><p>TimeUnit.SECONDS;           &#x2F;&#x2F;秒</p>
</li>
<li><p>TimeUnit.MILLISECONDS;      &#x2F;&#x2F;毫秒</p>
</li>
<li><p>TimeUnit.MICROSECONDS;      &#x2F;&#x2F;微妙</p>
</li>
<li><p>TimeUnit.NANOSECONDS;       &#x2F;&#x2F;纳秒</p>
<h3 id="workQueue"><a href="#workQueue" class="headerlink" title="workQueue"></a>workQueue</h3><p>一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：</p>
</li>
<li><p>ArrayBlockingQueue;</p>
</li>
<li><p>LinkedBlockingQueue;</p>
</li>
<li><p>SynchronousQueue;</p>
</li>
</ul>
<blockquote>
<p>ArrayBlockingQueue和PriorityBlockingQueue使用较少，一般使用LinkedBlockingQueue和Synchronous。线程池的排队策略与BlockingQueue有关。</p>
</blockquote>
<h3 id="threadFactory"><a href="#threadFactory" class="headerlink" title="threadFactory"></a>threadFactory</h3><p>线程工厂，主要用来创建线程；</p>
<h3 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h3><p>表示当拒绝处理任务时的策略，有以下四种取值</p>
<ul>
<li><p>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 </p>
</li>
<li><p>ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 </p>
</li>
<li><p>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</p>
</li>
<li><p>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 </p>
</li>
<li><p>execute()方法实际上是Executor中声明的方法，在ThreadPoolExecutor进行了具体的实现，这个方法是ThreadPoolExecutor的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。</p>
</li>
<li><p>submit()方法是在ExecutorService中声明的方法，在AbstractExecutorService就已经有了具体的实现，在ThreadPoolExecutor中并没有对其进行重写，这个方法也是用来向线程池提交任务的，但是它和execute()方法不同，它能够返回任务执行的结果，去看-submit()方法的实现，会发现它实际上还是调用的execute()方法，只不过它利用了Future来获取任务执行结果（Future相关内容将在下一篇讲述）。</p>
</li>
<li><p>shutdown()和shutdownNow()是用来关闭线程池的。</p>
</li>
</ul>
<p>还有很多其他的方法：<br>比如：getQueue() 、getPoolSize() 、getActiveCount()、getCompletedTaskCount()等获取与线程池相关属性的方法，有兴趣的朋友可以自行查阅API。</p>
<h2 id="深入剖析线程池实现原理"><a href="#深入剖析线程池实现原理" class="headerlink" title="深入剖析线程池实现原理"></a>深入剖析线程池实现原理</h2><h3 id="1线程池状态"><a href="#1线程池状态" class="headerlink" title="1线程池状态"></a>1线程池状态</h3><p>在ThreadPoolExecutor中定义了一个volatile变量，另外定义了几个static final变量表示线程池的各个状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> runState;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>下面的几个static final变量表示runState可能的几个取值。<br>当创建线程池后，初始时，线程池处于RUNNING状态；<br>如果调用了shutdown()方法，则线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；<br>如果调用了shutdownNow()方法，则线程池处于STOP状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；<br>当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态。</p>
<h3 id="2任务的执行"><a href="#2任务的执行" class="headerlink" title="2任务的执行"></a>2任务的执行</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/AndroidAlvin/article/details/103161673">引入</a></p>
<h3 id="3线程池中的线程初始化"><a href="#3线程池中的线程初始化" class="headerlink" title="3线程池中的线程初始化"></a>3线程池中的线程初始化</h3><p>默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。</p>
<p>在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到：</p>
<p>prestartCoreThread()：初始化一个核心线程；<br>prestartAllCoreThreads()：初始化所有核心线程<br>　　下面是这2个方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">prestartCoreThread</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addIfUnderCorePoolSize(<span class="literal">null</span>); <span class="comment">//注意传进去的参数是null</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">prestartAllCoreThreads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (addIfUnderCorePoolSize(<span class="literal">null</span>))<span class="comment">//注意传进去的参数是null</span></span><br><span class="line">        ++n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意上面传进去的参数是null，根据第2小节的分析可知如果传进去的参数为null，则最后执行线程会阻塞在getTask方法中的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = workQueue.take();</span><br></pre></td></tr></table></figure>
<p>即等待任务队列中有任务。</p>
<h3 id="4任务缓存队列及排队策略"><a href="#4任务缓存队列及排队策略" class="headerlink" title="4任务缓存队列及排队策略"></a>4任务缓存队列及排队策略</h3><p>在前面我们多次提到了任务缓存队列，即workQueue，它用来存放等待执行的任务。<br>workQueue的类型为BlockingQueue<Runnable>，通常可以取下面三种类型：<br>1）ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小；<br>2）LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；<br>3）synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。</p>
<h3 id="5任务拒绝策略"><a href="#5任务拒绝策略" class="headerlink" title="5任务拒绝策略"></a>5任务拒绝策略</h3><p>当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略：<br>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。<br>ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。<br>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）<br>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</p>
<h3 id="6线程池的关闭"><a href="#6线程池的关闭" class="headerlink" title="6线程池的关闭"></a>6线程池的关闭</h3><p>ThreadPoolExecutor提供了两个方法，用于线程池的关闭，分别是shutdown()和shutdownNow()，其中：<br>shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务<br>shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务</p>
<h3 id="7线程池容量的动态调整"><a href="#7线程池容量的动态调整" class="headerlink" title="7线程池容量的动态调整"></a>7线程池容量的动态调整</h3><p>ThreadPoolExecutor提供了动态调整线程池容量大小的方法：setCorePoolSize()和setMaximumPoolSize()，</p>
<ul>
<li>setCorePoolSize：设置核心池大小</li>
<li>setMaximumPoolSize：设置线程池最大能创建的线程数目大小<br>当上述参数从小变大时，ThreadPoolExecutor进行线程赋值，还可能立即创建新的线程来执行任务。</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从它们的具体实现来看，它们实际上也是调用了ThreadPoolExecutor，只不过参数都已配置好了。</p>
<p>newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的LinkedBlockingQueue；</p>
<p>newSingleThreadExecutor将corePoolSize和maximumPoolSize都设置为1，也使用的LinkedBlockingQueue；</p>
<p>newCachedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE，使用的SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。</p>
<p>实际中，如果Executors提供的三个静态方法能满足要求，就尽量使用它提供的三个方法，因为自己去手动配置ThreadPoolExecutor的参数有点麻烦，要根据实际任务的类型和数量来进行配置。</p>
<p>另外，如果ThreadPoolExecutor达不到要求，可以自己继承ThreadPoolExecutor类进行重写。</p>
<h2 id="如何合理配置线程池的大小"><a href="#如何合理配置线程池的大小" class="headerlink" title="如何合理配置线程池的大小"></a>如何合理配置线程池的大小</h2><p>本节来讨论一个比较重要的话题：如何合理配置线程池大小，仅供参考。</p>
<p>一般需要根据任务的类型来配置线程池大小：</p>
<p>如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 NCPU+1</p>
<p>如果是IO密集型任务，参考值可以设置为2*NCPU</p>
<p>当然，这只是一个参考值，具体的设置还需要根据实际情况进行调整，比如可以先将线程池大小设置为参考值，再观察任务运行情况和系统负载、资源利用率来进行适当调整。</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>王水泥</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://king-of-cement.gitee.io/blog/post/java/[java][%E8%BF%9B%E7%A8%8B+%E7%BA%BF%E7%A8%8B]%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/">http://king-of-cement.gitee.io/blog/post/java/[java][%E8%BF%9B%E7%A8%8B+%E7%BA%BF%E7%A8%8B]%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/blog/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/blog/post/%E5%85%B6%E4%BB%96/hexo%E6%90%AD%E5%BB%BA%E9%85%8D%E7%BD%AE/">hexo搭建配置</a>
            
            
            <a class="next" rel="next" href="/blog/post/java/inner_class/">inner_class</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 王水泥 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>
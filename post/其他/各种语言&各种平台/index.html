<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="王水泥">


    <meta name="subtitle" content="技术，etc">


    <meta name="description" content="不要传播">



<title>各种语言&amp;各种平台 | 王水泥个人博客</title>



    <link rel="icon" href="/blog/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/blog/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/blog/js/script.js"></script>
    
    <script src="/blog/js/tocbot.min.js"></script>
    




<meta name="generator" content="Hexo 5.4.2"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/blog/">王水泥的博客</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/blog/archives">Posts</a>
                
                    <a class="menu-item" href="/blog/category">Categories</a>
                
                    <a class="menu-item" href="/blog/tag">Tags</a>
                
                    <a class="menu-item" href="/blog/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/blog/">王水泥的博客</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/blog/archives">Posts</a>
                
                    <a class="menu-item" href="/blog/category">Categories</a>
                
                    <a class="menu-item" href="/blog/tag">Tags</a>
                
                    <a class="menu-item" href="/blog/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">各种语言&amp;各种平台</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">王水泥</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">十一月 1, 2022&nbsp;&nbsp;16:23:33</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/blog/categories/%E5%85%B6%E4%BB%96/">其他</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="各种语言-amp-各种平台"><a href="#各种语言-amp-各种平台" class="headerlink" title="各种语言&amp;各种平台"></a>各种语言&amp;各种平台</h1><p>@(其他语言&#x2F;平台)</p>
<p>[toc]</p>
<h1 id="kotlin"><a href="#kotlin" class="headerlink" title="kotlin"></a>kotlin</h1><ul>
<li>1 可以用中文命名变量，包名，类名</li>
<li>2 Float和Double的最小值为 -xx.Max_Value</li>
<li>3 长包名可以处理为 import xx.xx.xx.xx as xx</li>
<li>4 as? 安全转换 否则返回null</li>
<li>5 有变量接受的函数可以没有名字</li>
<li>6 lambda就是匿名函数</li>
<li>7 （）等于 .invoke()</li>
<li>8 入参，返回值，与形参一致就可以用函数引用-&gt;	::println</li>
<li>9 运算符重载</li>
<li>10 中缀表达式 infix</li>
<li>11 kotlin和java的 break return</li>
<li>12 导出可执行程序</li>
<li>charArray.joinToString()</li>
<li>vararg 变长参数</li>
<li>*array 只支持边长参数，和数组</li>
<li>by 接口代理  do.do() 属性代理<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">abstruct A&#123;</span><br><span class="line">	<span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">x</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">x</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">C</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">x</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>():A(),B,C&#123;</span><br><span class="line">	<span class="keyword">var</span> m=xxx</span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">x</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span>	<span class="keyword">when</span>(m)&#123;</span><br><span class="line">			-&gt;m</span><br><span class="line">			-&gt;<span class="keyword">super</span>&lt;B&gt;.x()</span><br><span class="line">			-&gt;<span class="keyword">super</span>&lt;C&gt;.x()</span><br><span class="line">			<span class="keyword">else</span>-&gt;<span class="keyword">super</span>&lt;A&gt;.x()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Country</span>(<span class="keyword">val</span> id:<span class="built_in">Int</span>,<span class="keyword">val</span> name:String)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> china=Country(<span class="number">0</span>,<span class="string">&quot;中国&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> (id,name)=china</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>((index,value) <span class="keyword">in</span> args.withIndex())&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>componentN方法</li>
<li>allOpen 和 noArg插件</li>
<li>唯一强制写分号的地方 枚举中</li>
<li>sealed class （密封类）只能在当前文件内（1.1后）初始化，子类可数</li>
<li>list.reduce</li>
<li>fold</li>
<li>takeWhile() 遇到不符合条件的则停止</li>
<li>T.use{} 用来close()</li>
<li>tailrec 让编译器优化尾递归 不会出现 stackOverflow<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//闭包的概念</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">makeFun</span><span class="params">()</span></span>:()-&gt;<span class="built_in">Unit</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count =<span class="number">0</span></span><br><span class="line">    println(<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span>  <span class="function"><span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;bbb&quot;</span>)</span><br><span class="line">        println(++count)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> x= makeFun()</span><br><span class="line">    x()</span><br><span class="line">    x()</span><br><span class="line">    x()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line"><span class="number">1</span></span><br><span class="line">bbb</span><br><span class="line"><span class="number">2</span></span><br><span class="line">bbb</span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> addx=add(<span class="number">5</span>)</span><br><span class="line">println(addx(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(x:<span class="type">Int</span>)</span></span>=<span class="function"><span class="title">fun</span><span class="params">(y:<span class="type">Int</span>)</span></span>=x+y</span><br><span class="line"><span class="comment">//等于</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(x:<span class="type">Int</span>)</span></span>:(<span class="built_in">Int</span>)-&gt;<span class="built_in">Int</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="title">fun</span> <span class="params">(y:<span class="type">Int</span>)</span></span>:<span class="built_in">Int</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x+y</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>infix 符合函数 video5  14:31</li>
<li>curried 拓展方法</li>
<li>偏函数 传入部分参数得到的新函数</li>
<li>groupBy<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABCABA -groupBy-&gt;&#123;A,A,A&#125;,&#123;B,B&#125;,&#123;C&#125;</span><br></pre></td></tr></table></figure></li>
<li>DSL kotlin大秀 video6</li>
<li>anko 官方包</li>
<li>lambda 其实是一个方法，只有在使用的时候才会生成地址，使用多次就会生成多次</li>
<li>typealias 类型别名 特殊用法可以方便kotlin video8 13:15</li>
<li>“””XXX””” 叫做RAW string (这里 和java 的raw类型没关系)</li>
<li>注意避免因为 装箱类型而遇到的问题（创造java中间类解决）</li>
</ul>
<p>##协程<br>线程是抢占式的，协程是协同工作<br>异步代码写出来后像同步代码一样直观<br>简化异步代码异常处理<br>轻量级的并发方案</p>
<p>协程不会切换线程，需要手动操作</p>
<p>createCoroutine 创建协程<br>startCoroutine 启动协程<br>suspendCoroutine 挂起协程</p>
<p>Continuation接口 运行控制类，负责结果和异常的返回<br>CoroutineContext 接口 运行上下文，资源持有，运行调度</p>
<p>ContinuationInterceptor 接口  协程控制拦截器，可用来处理协程调度</p>
<p>序列生成器 buildSequence</p>
<h1 id="C-x2F-C"><a href="#C-x2F-C" class="headerlink" title="C&#x2F;C++"></a>C&#x2F;C++</h1><p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/c">查阅</a></p>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><blockquote>
<p>c中的const是个伪命题，可以通过指针改变</p>
</blockquote>
<p>常量指针<br>指针常量</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>变量相当于拿到的是一个值<br>引用相当于拿到的是一个空间</p>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="vector-容器"><a href="#vector-容器" class="headerlink" title="vector 容器"></a>vector 容器</h3><h4 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h4><p>向量大小： vec.size();<br>向量真实大小： vec.capacity();<br>向量判空： vec.empty();</p>
<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p>末尾添加元素： vec.push_back();<br>末尾删除元素： vec.pop_back();<br>任意位置插入元素： vec.insert();<br>任意位置删除元素： vec.erase();<br>清空向量元素： vec.clear();</p>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>开始指针：vec.begin();<br>末尾指针：vec.end(); &#x2F;&#x2F;指向最后一个元素的下一个位置<br>指向常量的末尾指针： vec.cend();</p>
<h4 id="元素的访问"><a href="#元素的访问" class="headerlink" title="元素的访问"></a>元素的访问</h4><p>下标访问： vec[1]; &#x2F;&#x2F;并不会检查是否越界<br>at方法访问： vec.at(1); &#x2F;&#x2F;以上两者的区别就是at会检查是否越界，是则抛出out of range异常<br>访问第一个元素： vec.front();<br>访问最后一个元素： vec.back();</p>
<h3 id="stack-容器"><a href="#stack-容器" class="headerlink" title="stack 容器"></a>stack 容器</h3><p>stack.push()<br>stack.top()<br>stack.pop()</p>
<h3 id="queue-容器"><a href="#queue-容器" class="headerlink" title="queue 容器"></a>queue 容器</h3><h3 id="list-容器"><a href="#list-容器" class="headerlink" title="list 容器"></a>list 容器</h3><blockquote>
<p>链表结构，不能通过角标访问</p>
</blockquote>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>list.push_front(x)<br>list.push_back(x)<br>list.insert(x,x)</p>
<h4 id="修改-1"><a href="#修改-1" class="headerlink" title="修改"></a>修改</h4><p>list.back()&#x3D;<br>list.front()&#x3D;</p>
<h4 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h4><p>list.erase(x)<br>list.pop_front()<br>list.pop_back()</p>
<h3 id="set-容器"><a href="#set-容器" class="headerlink" title="set 容器"></a>set 容器</h3><p><code>#include&lt;functional&gt;</code><br>set.insert()</p>
<h3 id="multiset容器"><a href="#multiset容器" class="headerlink" title="multiset容器"></a>multiset容器</h3><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><blockquote>
<p>map会对key排序，二叉树的算法</p>
</blockquote>
<p>map.insert(pair&lt;x,x&gt;(x,x))<br>map.insert(make_pair(x,x))<br>map.insert(map&lt;x,x&gt;::value_type(x,x))<br>map[x]&#x3D;x</p>
<h3 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h3><p>key可以重复</p>
<h2 id="java和c-中容器的对比"><a href="#java和c-中容器的对比" class="headerlink" title="java和c++中容器的对比"></a>java和c++中容器的对比</h2><p>java中把对象添加到了集合<br>c++中会调用对象的拷贝构造函数，存进去的是另一个对象</p>
<h2 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h2><p>和函数非常类似<br>##谓词<br>谓词（函数谓词）：按照特定的规则所编写的函数谓词</p>
<h2 id="预定义函数对象和函数适配器"><a href="#预定义函数对象和函数适配器" class="headerlink" title="预定义函数对象和函数适配器"></a>预定义函数对象和函数适配器</h2><p>plus 链接字符串<br>greater<br>find_if 判断是不是包含<br>equal_to<br>bind2nd<br>count_if </p>
<h2 id="算法分类：遍历，查找，排序，拷贝，替换"><a href="#算法分类：遍历，查找，排序，拷贝，替换" class="headerlink" title="算法分类：遍历，查找，排序，拷贝，替换"></a>算法分类：遍历，查找，排序，拷贝，替换</h2><p>foreach<br>transform<br>find<br>find_if<br>count<br>count_if<br>megre<br>sort<br>random_shuffle<br>copy<br>replace</p>
<h2 id="inline-内联函数"><a href="#inline-内联函数" class="headerlink" title="inline 内联函数"></a>inline 内联函数</h2><p>背景：define 宏定义好处：宏替换（编译时去去替换） ，宏函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a,b) a&gt;b ? a:b</span></span><br><span class="line"><span class="comment">// inline 内联函数，类似于 define 函数，做到编译时替换</span></span><br><span class="line"><span class="comment">// 区别：define 并没有严格的检测</span></span><br><span class="line"><span class="comment">// inline 使用场景：不涉及过于复杂的函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JNI-NDK"><a href="#JNI-NDK" class="headerlink" title="JNI+NDK"></a>JNI+NDK</h2><p>“xxx.h”引入自己工程的头文件<br>&lt;xxx.h&gt;引入系统的头文件</p>
<h1 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h1><h2 id="终端与Shell"><a href="#终端与Shell" class="headerlink" title="终端与Shell"></a>终端与Shell</h2><p>mac 终端怎么登陆：ssh <a href="mailto:&#x75;&#x62;&#x75;&#x6e;&#116;&#117;&#64;&#49;&#x34;&#x38;&#x2e;&#55;&#x30;&#46;&#57;&#x36;&#46;&#50;&#51;&#48;">&#x75;&#x62;&#x75;&#x6e;&#116;&#117;&#64;&#49;&#x34;&#x38;&#x2e;&#55;&#x30;&#46;&#57;&#x36;&#46;&#50;&#51;&#48;</a><br>window 怎么登陆：xshell ，根据公网的 ip<br>终端是一切输入输出设备的总称，显示器，键盘，鼠标<br>终端和shell ：就是一个命令解析器，内嵌了 shell 解析器</p>
<h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><h4 id="shell-脚本创建与执行"><a href="#shell-脚本创建与执行" class="headerlink" title="shell 脚本创建与执行"></a>shell 脚本创建与执行</h4><h4 id="自定义变量与环境变量"><a href="#自定义变量与环境变量" class="headerlink" title="自定义变量与环境变量"></a>自定义变量与环境变量</h4><h4 id="位置参数变量与预定义变量"><a href="#位置参数变量与预定义变量" class="headerlink" title="位置参数变量与预定义变量"></a>位置参数变量与预定义变量</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 获取参数 </span></span><br><span class="line"><span class="comment"># $n 来获取参数,$0 代表程序本身，$1-$9代表第一个参数到第九个参数，十以上的参数要用大括号 $&#123;10&#125;</span></span><br><span class="line"><span class="comment"># $* 代表的是命令中的所有参数，但是会把参数看成一个整体 &quot;$0,$1,$2,$3,$4...$n&quot;</span></span><br><span class="line"><span class="comment"># $@ 代表命令中的所有参数，但是会把参数区分对待 &quot;$0&quot;,&quot;$1&quot;,&quot;$2&quot;...&quot;$n&quot;</span></span><br><span class="line"><span class="comment"># $# 代表参数中的个数</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$0</span>=<span class="variable">$0</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;\<span class="variable">$1</span>=<span class="variable">$1</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;\<span class="variable">$2</span>=&quot;</span><span class="variable">$2</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;\<span class="variable">$</span>*=&quot;</span><span class="variable">$</span>*</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;\<span class="variable">$</span>@=&quot;</span><span class="variable">$</span><span class="selector-tag">@</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;\<span class="variable">$</span>#=&quot;</span><span class="variable">$</span><span class="comment">#</span></span><br><span class="line">shift</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;\<span class="variable">$1</span>=<span class="variable">$1</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;\<span class="variable">$</span>#=&quot;</span><span class="variable">$</span><span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>预定义变量：是 bash 中已经定义好的，我们可以直接拿过来用，变量的作用都是固定</p>
<p>$?:返回的是上一个执行命令的返回值，执行成功返回 0 ，执行失败返回非0<br>$$:获取当前角本的进程号<br>$!:获取最后一个后台执行的进程号</p>
<h4 id="条件判断（测试命令）"><a href="#条件判断（测试命令）" class="headerlink" title="条件判断（测试命令）"></a>条件判断（测试命令）</h4><p>[ str ] 测试字符串是否不为空<br>test -n str 测试字符串是否不为空<br>test -z str 测试字符串是否为空<br>[ str1 &#x3D; str2 ] 是否相等<br>数字：<br>[ num1 -eq num2 ] 测试是否相等<br>[ num1 -ne num2 ] 不等<br>[ num1 -ge num2 ] &gt;&#x3D;<br>[ num1 -gt num2 ] &gt;<br>[ num1 -le num2 ] &lt;&#x3D;<br>[ num1 -lt num2 ] &lt;</p>
<p>文件：<br>test -d file  目录<br>test -f file   普通文件<br>test -e file  存在<br>test -L file  链接<br>test -r file   可读<br>test -w file  可写<br>test -x file   可执行</p>
<h4 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h4><h4 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h4><h4 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h4><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><p>table 补齐<br>ctrl + a : 光标移动到最前<br>ctrl + e：光标移动到最后<br>ctrl + u：清空<br>上，下键：切换命令</p>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>cd xxx：进入到某个目录<br>cd ..：回退到上一级目录<br>ls : 当前文件夹下面的所有文件<br>.&#x2F;date ：执行当前目录下的可执行文件</p>
<p>linux 系统中所见即文件（驱动）  , bin 目录一些执行文件，home 目录用户， lib 目录常用的 so ，opt 和 proc 是与进程相关的<br>mkdir xxx：创建文件夹<br>touch xxx.xxx： 创建文件<br>ls -l : 打印详细信息<br>-rw-rw-r– 1 ubuntu ubuntu 0 Apr 14 20:37 hello.c</p>
<p>文件权限，硬链接计数，所有者，所属组，大小，时间，文件名<br>ls -R ：递归文件夹输出</p>
<p>-rw-rw-r–：- 文件类型，rw- 所有者可读可写可执行，rw- 同一组用户可读可写可执行，r– 其他人可读可写可执行</p>
<p>linux 系统文件类型：</p>
<p>普通文件：-<br>目录文件：d<br>软连接：l<br>字符设备文件：c<br>块设备文件：b<br>管道文件：p<br>套接字：s</p>
<p>rmdir file : 只能清空空目录文件夹<br>rm -r file：递归清空目录<br>rm hello.c：删除文件<br>cp a.c file ： 拷贝文件</p>
<p>文件读取：<br>cat xxx.xxx ：查看文件内容<br>tac a.c ： 倒着查看文件<br>more a.c : 每次只查看一页，回车查看下一页<br>less a.c：与 more 不同地方是, 回车是下一行，空格翻一页，没有百分百，退出 ctrl + c 不行，ESC之后  :q<br>head -n a.c：查看前面n行</p>
<p>tail -20 a.c ： 查看后面20行</p>
<p>硬链接软件接：相当于 windows 的快捷图标</p>
<h2 id="用户与用户组"><a href="#用户与用户组" class="headerlink" title="用户与用户组"></a>用户与用户组</h2><p>sudo su root ：切换用户</p>
<p>exit : 退出 root 用户<br>whoami：查看当前用户</p>
<ol>
<li>修改用户文件权限<br>新建的文件默认是不能执行的，我们需要修改用户文件权限<br>1.1 文字设定法<br>chmod 用户的标识 +&#x2F;- 权限 文件名：chmod u+x hello.sh<br>用户的标识：u(当前用户) ，g(同组)，o(other)，a(all)<br>1.2 数字设定法<br>chmod nnn 文件名<br>n &#x3D; 4+2+1 &#x3D; r+w+x </li>
<li>创建修改用户和用户组<br>sudo adduser darren： 创建了一个用户<br>sudo chown darren hello.sh ：修改文件的所属用户<br>sudo chgrp darren hello.sh ：修改文件的所属组<br>sudo chown ubuntu:ubuntu hello.sh：同时修改文件所属组：所属用户</li>
</ol>
<h2 id="搜索查找"><a href="#搜索查找" class="headerlink" title="搜索查找"></a>搜索查找</h2><p>find 命令找文件<br>find .&#x2F; type 文件类型（递归）<br>find .&#x2F; -name ‘*.so’ ： 根据文件类型去查找</p>
<p>-maxdepth 1 ：递归的层级</p>
<p>size,time 有需要自己百度搜索一下</p>
<p>grep 命令找内容<br>grep -r ‘darren’ ： 找文件内容</p>
<p>ps aux 类似于任务管理器<br>ps aux | grep ubuntu : 找到了所有的任务，交给 grep 去执行搜索 ， | ： 管道 （进程间的通信），如果只有一个代表没有找到，两个以上才算有</p>
<h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><p>命令行安装：</p>
<ol>
<li>指定国内的服务器（界面操作） </li>
<li>更新服务器的下载配置<br>sudo apt-get update</li>
<li>敲安装命令<br>sudo apt install tree<br>sudo apt-get remove tree：软件的卸载<br>压缩包安装：deb<br>源码安装：</li>
</ol>
<h2 id="压缩与解压缩"><a href="#压缩与解压缩" class="headerlink" title="压缩与解压缩"></a>压缩与解压缩</h2><p>tar -zcvf test.tar.zip a.c file</p>
<p>tar 的内部就是 gzip 命令，zip 只能压缩一个文件, gzip 文件<br>gunzip a.c.gz：解压文件</p>
<p>tar -zxvf test.tar.zip ： 解压缩 x:解压<br>-zcvf  z:gzip , c: crate f: file v:显示过程<br>tar -jcvf test.tar.zip a.c file : j-&gt; 用 bizp2 方式</p>
<p>rar 和 zip<br>rar a -r test.rar ：rar 压缩<br>unrar x test.rar：rar 解压缩<br>zip -r test.zip a.c file ：zip 压缩<br>unzip test.zip：zip解压缩</p>
<h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><h3 id="vim-工作模式"><a href="#vim-工作模式" class="headerlink" title="vim 工作模式"></a>vim 工作模式</h3><p>gcc a.c -o a : 编译成可执行文件<br>.&#x2F;a : 运行可执行文件<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/%E5%90%84%E7%A7%8D%E8%AF%AD%E8%A8%80%26%E5%90%84%E7%A7%8D%E5%B9%B3%E5%8F%B0/.vim%E4%B8%89%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F.png" alt="Alt text"></p>
<h3 id="vim-常用快捷键"><a href="#vim-常用快捷键" class="headerlink" title="vim 常用快捷键"></a>vim 常用快捷键</h3><p>i: 输入,光标前面<br>I: 输入,光标前面<br>a: 输入,光标会逻动一个位置<br>A:输入,光标会逻动到最后<br>o:输入,光标会逻动到下一行<br>O:输入,光标会逻动到上一行<br>s:输入,会删除光标所在字符<br>S: 输入,会删除光标所在行</p>
<h4 id="跳转和删除"><a href="#跳转和删除" class="headerlink" title="跳转和删除"></a>跳转和删除</h4><p>h: 左<br>j:下<br>k:上<br>l:右<br>5G: 跳转到多上行<br>5+回车：跳转到多上行，末行模式<br>gg:  跳转到行首<br>G:  跳转到末尾<br>$：跳转到行尾巴<br>0：跳转到行首<br>gg &#x3D; G : 格式化代码<br>dw：删除单词，需要注意光标要在单词的开始<br>x：删除某个字母<br>d0：删除光标至行首<br>v + h&#x2F;j&#x2F;k&#x2F;l : 删除选中区域<br>dd:删除整行<br>3dd: 删除3行</p>
<h4 id="赋值粘贴查找替换"><a href="#赋值粘贴查找替换" class="headerlink" title="赋值粘贴查找替换"></a>赋值粘贴查找替换</h4><p>yy: 赋值<br>p: 粘贴，下一行<br>P:粘贴，本行<br>dd: 其实是删除并且赋值，剪切<br>3yy: 赋值3行</p>
<p>*：跳转到下一个<br>&#x2F; + define + 回车 ： 查找 , n 跳转到下一个， N 是查看上一个<br>r + i : 把当前光标字符替换成 i<br>s &#x2F;printf&#x2F;println&#x2F; : 末行模式下，printf替换成println ，光标所在行，而且是前一个<br>%s &#x2F;printf&#x2F;println ：每一行都替换，而且是前一个</p>
<p>%s &#x2F;printf&#x2F;println&#x2F;g : 替换所有</p>
<p>1,3s &#x2F;print&#x2F;println&#x2F;g  ：1-3行替换</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>u：撤销<br>ctrl+r：反撤销<br>vsp：分屏<br>ctrl + ww : 切换分屏<br>q: 退出当前<br>wqall：保存退出全部</p>
<h3 id="gcc-编译四步骤"><a href="#gcc-编译四步骤" class="headerlink" title="gcc 编译四步骤"></a>gcc 编译四步骤</h3><p>so 怎么来的？ .c 文件 -&gt; 可执行文件，四个步骤<br>gcc -E -o hello.i hello.c<br>3.1 预处理阶段：<br>宏定义展开，宏定义替换，展开 include 的文件。<br>3.2 预编译阶段：</p>
<p>在这个阶段，GCC 才会去检测你代码的规范性，语法是否有错误，gcc 会把代码翻译成汇编<br>gcc -S -o hello.s hello.i</p>
<p>3.3 汇编阶段：<br>把 .s 文件翻译成二进制.o文件（机器的指令）,文本打开的是乱码<br>gcc -c -o hello.o hello.s<br>3.4 链接阶段：<br>计算逻辑地址，合并数据段，有些函数是在另外一个 so 库文件中的。<br>gcc -o hello hello.o</p>
<h3 id="动态库和静态库"><a href="#动态库和静态库" class="headerlink" title="动态库和静态库"></a>动态库和静态库</h3><p><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/%E5%90%84%E7%A7%8D%E8%AF%AD%E8%A8%80%26%E5%90%84%E7%A7%8D%E5%B9%B3%E5%8F%B0/.%E5%8A%A8%E6%80%81%E5%BA%93.png" alt="Alt text"></p>
<p>人脸识别，github 下载编译好的 android 的 so , 会有一些 .a ，会有一些 .so </p>
<h4 id="静态库和动态库的区别"><a href="#静态库和动态库的区别" class="headerlink" title="静态库和动态库的区别"></a>静态库和动态库的区别</h4><p>静态库：其实是内容的拷贝(代码)，运行阶段没有 .a 文件了也是可以执行的。<br>动态库：不会拷贝内容，运行阶段起的作用（加载），生成 so 的时候要生成与位置无关的代码，没有 so 不能运行。</p>
<h4 id="静态库与动态库生成：-不是重点"><a href="#静态库与动态库生成：-不是重点" class="headerlink" title="静态库与动态库生成：(不是重点)"></a>静态库与动态库生成：(不是重点)</h4><p>4.2.1 静态库生成<br>4.2.1.1 将 c 生成 .o<br>gcc -c add.c -o add.o<br>4.2.1.2 使用 ar 工具制作静态库</p>
<p>ar rcs libmath.a add.o xxx.o<br>4.2.1.3 编译静态库到可执行文件</p>
<p>gcc a.c libmath.a -o hello</p>
<p>4.2.2 动态库生成</p>
<p>4.2.2.1 将 c 生成 .o （要生成与位置无关的代码）</p>
<p>gcc -c add.c -o add.o -fPIC</p>
<p>4.2.2.2 使用 gcc -shared 制作动态库</p>
<p>gcc -shared -o libmath.so add.o xxx.o<br>4.2.1.3 编译动态库到可执行文件，需要指定动态库的名称 -l , 指定库路径 -L<br>gcc a.c -o a -l名称 -L.&#x2F;</p>
<h3 id="虚拟内存与物理内存"><a href="#虚拟内存与物理内存" class="headerlink" title="虚拟内存与物理内存"></a>虚拟内存与物理内存</h3><p><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/%E5%90%84%E7%A7%8D%E8%AF%AD%E8%A8%80%26%E5%90%84%E7%A7%8D%E5%B9%B3%E5%8F%B0/.%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%9B%BE.png" alt="Alt text"></p>
<h2 id="文件IO与文件描述符"><a href="#文件IO与文件描述符" class="headerlink" title="文件IO与文件描述符"></a>文件IO与文件描述符</h2><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>3-4G 是系统的空间，这部分是由操作系统来管理，那么如果我们要操作这部分数据，只能借助系统提供的一些函数（系统函数），用户调用这些函数就称之为系统调用。</p>
<h3 id="普通函数与内核函数"><a href="#普通函数与内核函数" class="headerlink" title="普通函数与内核函数"></a>普通函数与内核函数</h3><p><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/%E5%90%84%E7%A7%8D%E8%AF%AD%E8%A8%80%26%E5%90%84%E7%A7%8D%E5%B9%B3%E5%8F%B0/.%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0.png" alt="Alt text"></p>
<p>open , close , write , read<br>int open(const char *pathname, int flags, mode_t mode);</p>
<p>pathname : 文件的路径</p>
<p>flags : O_APPEND 追加，O_CREAT 没有的时候会创建，O_TRUNC 会截断（清空文件）</p>
<p>mode：就是创建时的文件权限 ， 只是当前用户可读可写，S_IRUSR|S_IWUSR</p>
<p>返回的是一个文件句柄 fd , 我们直接通过 fd 去做操作</p>
<p>int close(int fd); 关闭文件</p>
<p>ssize_t read(int fd, void *buf, size_t count);</p>
<p>fd：文件句柄<br>void *buf：读入的缓冲区<br>count：每次读多少字节数<br>ssize_t ：返回的是读到真实个数</p>
<p>ssize_t write(int fd, const void *buf, size_t count);</p>
<p>fd：文件句柄<br>void *buf：写入的缓冲区<br>count：每次写入的字节数<br>ssize_t ：返回的是写入真实个数</p>
<p>利用系统函数去完成一个文件拷贝</p>
<p>文件操作的错误怎么提示？会有一个宏定义 errno  , 通过 strerror(errno) 获取错误信息，需要打印错误快捷的方式 perror<br>void perror(const char *s); s 代表的是错误信息的描述 s: strerror(errno)</p>
<p>拷贝文件：</p>
<ol>
<li>系统函数 open， close ，read，write</li>
<li>普通函数 fopen，fclose ， fread&#x2F;fputc ，fwrite&#x2F;fgetc<br>思考一下：<br>fputc 和 fgetc 内部是封装了 read , wirte , 如果每次只读一个字节，用上面两种不同的方案去实现，哪一种会更快？<br>系统函数大概三四秒。<br>普通函数感知不到。</li>
</ol>
<p>为什么 Java write 数据，需要 flush ， close 刷新 </p>
<h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/%E5%90%84%E7%A7%8D%E8%AF%AD%E8%A8%80%26%E5%90%84%E7%A7%8D%E5%B9%B3%E5%8F%B0/.%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6.png" alt="Alt text"></p>
<h3 id="lseek-与-fseek"><a href="#lseek-与-fseek" class="headerlink" title="lseek 与 fseek"></a>lseek 与 fseek</h3><p>用来获取偏移量 SEEK_SET , SEEK_END, SEEK_CUR<br>lseek 他的偏移量，读和写是同一个</p>
<h3 id="stat-和-lstat"><a href="#stat-和-lstat" class="headerlink" title="stat 和 lstat"></a>stat 和 lstat</h3><p>Inode: 370887 ， 文件的权限，盘符的位置。</p>
<p>硬链接计数就充分的利用了 inode<br>软连接：文件快捷键<br>软连接：类似于文件的快捷键，但是你操作任何一个都会被改变</p>
<p>int stat(const char *pathname, struct stat *buf);<br>pathname：文件路径</p>
<p>struct stat *buf：stat 结构体指针</p>
<p>作业：stat 获取文件的属性，获取文件的大小就可以<br>stat 和 lstat 有什么区别？stat 是会穿透的，lstat 不会穿透，穿透软连接<br>ln -s f_read_write f_read_write.soft ： 创建软连接</p>
<h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><p>递归目录<br>传入参数：直接传给方法<br>传出参数：在方法里面赋值<br>传入传出参数：既要直接传给方法，又要在方法里赋值（返回值）</p>
<p>Mac 电脑，编程真好，虚拟机 windows </p>
<h2 id="进程创建与管理"><a href="#进程创建与管理" class="headerlink" title="进程创建与管理"></a>进程创建与管理</h2><h3 id="pcb-进程控制块"><a href="#pcb-进程控制块" class="headerlink" title="pcb 进程控制块"></a>pcb 进程控制块</h3><p>pcb 的本质就是一个结构体：struct task_struct {<br>结构体的路径：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">task_struct</span> &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        进程 id</span><br><span class="line">        文件描述符</span><br><span class="line">        进程的状态：初始态，就绪态，运行态，挂起态，终止态</span><br><span class="line">        进程工作目录</span><br><span class="line">        信号相关信息资源</span><br><span class="line">        用户id组id</span><br><span class="line">        进程工作目录</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单道程序，多道程序</p>
<h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><p><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/%E5%90%84%E7%A7%8D%E8%AF%AD%E8%A8%80%26%E5%90%84%E7%A7%8D%E5%B9%B3%E5%8F%B0/.%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84.png" alt="Alt text"></p>
<p>用户空间映射时，会映射到不同的区域，内核空间映射时，会映射到同一区域的不同地方（没有隔离）<br>有一些小的瑕疵，也有可能与操作系统源码有出入，大致意思是这样。</p>
<h3 id="fork-创建子进程"><a href="#fork-创建子进程" class="headerlink" title="fork 创建子进程"></a>fork 创建子进程</h3><p><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/%E5%90%84%E7%A7%8D%E8%AF%AD%E8%A8%80%26%E5%90%84%E7%A7%8D%E5%B9%B3%E5%8F%B0/.fork%E5%87%BD%E6%95%B0.png" alt="Alt text"></p>
<p>getpid:  获取当前进程的 pid<br>getppid ： 获取父进程的 pid</p>
<h3 id="父子进程共享"><a href="#父子进程共享" class="headerlink" title="父子进程共享"></a>父子进程共享</h3><p>4.1 父子进程相同：<br>刚 fork 后，data 段，text 段，堆，栈，环境变量，全局变量，进程工作目录，信号处理方式。（0-3G 部分是共享的）<br>4.2 父子进程不同的：<br>进程 id ，返回值，各自的父进程，进程创建时间，闹钟，未决信号集<br>4.3 父子进程共享：<br>map 映射区，读时共享，写时复制。</p>
<h3 id="进程回收"><a href="#进程回收" class="headerlink" title="进程回收"></a>进程回收</h3><p>孤儿进程：父进程先于子进程结束，则子进程会成为孤儿进程，子进程的父进程成为 init 进程，有 init 进程（进程孤儿院）来回收进程。<br>僵尸进程：子进程结束，父进程尚未回收，该子进程会变成僵尸进程<br>进程回收：回收的就是残留在内核中的 3-4G 的数据（pcb 进程控制块）</p>
<p>wait, waitpid<br>wait功能：</p>
<ol>
<li>阻塞等待子线程退出</li>
<li>回收子进程残留的资源</li>
<li>获取子进程退出的状态（怎么死掉的）</li>
</ol>
<p>如果要回收多个子进程，需要 while 循环</p>
<h3 id="监听-APP-应用被卸载"><a href="#监听-APP-应用被卸载" class="headerlink" title="监听 APP 应用被卸载"></a>监听 APP 应用被卸载</h3><p>5.0 以前是可以的，想办法去实现一个应用被卸载的监听，应用被杀死了拉活？</p>
<ol>
<li>fork 一个子进程</li>
<li>监听文件是否被删除了，data&#x2F;data&#x2F;xxx包名</li>
<li>exec 函数族去执行某些命令（打开浏览器收集用户反馈）</li>
</ol>
<p>可以执行自己写好的程序，path 是路径，arg 是可变参数<br>int execl(const char *path, const char <em>arg, …<br>                       &#x2F;</em> (char  *) NULL *&#x2F;);</p>
<p>可以执行系统的命令程序，file 是命令的名称，arg 是可变参数</p>
<p>int execlp(const char *file, const char <em>arg, …<br>                       &#x2F;</em> (char  *) NULL *&#x2F;);</p>
<p>与之前讲的有什么不同？不会走原来的 fork 之后的 text 代码段，而是会去执行 exec 函数族的命令或者程序。</p>
<h2 id="IPC进程间的通信"><a href="#IPC进程间的通信" class="headerlink" title="IPC进程间的通信"></a>IPC进程间的通信</h2><h3 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h3><p>文件，管道，信号量，信号， 共享映射区（共享内存），消息队列，管道，套接字（socket）<br>进程间通信的本质：自己补充<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/%E5%90%84%E7%A7%8D%E8%AF%AD%E8%A8%80%26%E5%90%84%E7%A7%8D%E5%B9%B3%E5%8F%B0/.%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.png" alt="Alt text"></p>
<p>1.1 管道（使用简单）<br>1.2 信号（开销比较小）<br>1.3 共享映射区<br>1.4 套接字 （低速稳定）</p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/%E5%90%84%E7%A7%8D%E8%AF%AD%E8%A8%80%26%E5%90%84%E7%A7%8D%E5%B9%B3%E5%8F%B0/.%E7%AE%A1%E9%81%93.png" alt="Alt text"><br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/%E5%90%84%E7%A7%8D%E8%AF%AD%E8%A8%80%26%E5%90%84%E7%A7%8D%E5%B9%B3%E5%8F%B0/.%E7%AE%A1%E9%81%93%E7%9A%84%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6.png" alt="Alt text"></p>
<ol>
<li>无名管道，半双工的通信方式</li>
<li>管道大家可以简单的理解为一种特殊的文件形式，我们可以用文件的读写方法，不是一种简单的文件，只会占用内存。</li>
<li>管道只能是有血缘关系的进程间通信</li>
<li>数据不能自己写自己读</li>
<li>数据一旦读走，不能再次读</li>
</ol>
<p>非法操作：</p>
<ol>
<li>读管道：<br> 1.1 管道中有数据，read 返回实际读到的数据<br> 1.2 管道中无数据：<br> 1.2.1 管道写端被关闭，read 返回 0<br> 1.2.2 管道写端如果没有被关闭，会阻塞等待</li>
<li>写管道：<br> 2.1 读端被关闭，异常终止（信号导致）<br> 2.2 读端未关闭：<br> 1.2.1 管道数据已满，阻塞等待写入数据（其他人读走）<br> 1.2.2 管道未满，直接将数据写入</li>
</ol>
<h3 id="共享映射区"><a href="#共享映射区" class="headerlink" title="共享映射区"></a>共享映射区</h3><p>binder 驱动，腾讯 MMKV，xlog （日志库）<br>自己要学会打日志，比如你觉得有坑的地方，打一打<br>mmap 函数<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a807b782baf8">https://www.jianshu.com/p/a807b782baf8</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8e44625c3945">https://www.jianshu.com/p/8e44625c3945</a><br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/%E5%90%84%E7%A7%8D%E8%AF%AD%E8%A8%80%26%E5%90%84%E7%A7%8D%E5%B9%B3%E5%8F%B0/.mmap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt="Alt text"></p>
<p>mmap 注意事项</p>
<ol>
<li>指定映射区的大小，必须要小于文件大小</li>
<li>映射区大小必须要大于 0 ，否则会异常</li>
<li>创建映射区需要 read 权限，mmap 的读写权限应该 &lt;&#x3D; 文件的权限</li>
<li>文件可以先关闭</li>
<li>偏移量必须是 4k 的整数倍</li>
<li>MAP_PRIVATE 只会对内存进行修改，不会反应到磁盘上</li>
</ol>
<p>mmap 万能调用方法：<br>open(O_RDWR);<br>mmap(NULL, 有效大小，PROT_READ|PROT_WRITE,MAP_SHARED,fd,0)</p>
<p>gdb：调试工具（查一些资料）</p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>进程间通信的机制，内核自带的，信号不能携带大量的数据，一般就是一个数字，只有在特定场景下才调用。<br>怎样才会产生信号：</p>
<ol>
<li>按键产生: ctrl + c, ctrl+z</li>
<li>系统调用 kill ， raise， abort</li>
<li>软件条件产生， alarm</li>
<li>硬件异常产生，非法访问内存，除 0 ，内存对齐等等</li>
<li>命令产生</li>
</ol>
<p>信号的处理方式：</p>
<ol>
<li>忽略此信号</li>
<li>执行系统默认动作</li>
<li>捕捉用户希望动作</li>
</ol>
<p>信号处理的原理：<br>信号屏蔽字: 用于屏蔽x信号，内部实现就是一个集合，当 x 信号屏蔽后，再收到该信号，信号处理将推后<br>未决信号集: 信号抵达 x 信号位反转为 1 ， 当信号被处理后重新置为 0 </p>
<p>Signal     Value     Action   Comment<br>名称        编号       事件      默认执行动作</p>
<p>Term ： 终止进程<br>Ign ： 忽略<br>Core：终止进程，生成 Core 文件（可以帮助开发者检测）<br>Stop：停止进程<br>Cont：继续运行</p>
<p>Process.killProcess(Process.myPid());kill（发送信号） : 第一个参数，pid ， &gt; 0 往 pid 进程发个信号，&lt; 0 往 |pid| 发个信息，0 杀死进程组，不要穿 -1 binder 驱动的原理</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程的本质"><a href="#线程的本质" class="headerlink" title="线程的本质"></a>线程的本质</h3><p>线程与进程的区别：线程大家可以简单理解为一个轻量级的进程，线程共享了栈和堆（变量），没有复制 0-3 G 的进程空间，<br>但线程会有自己的工作空间，会有自己的 pcb 块。跟 Java 是类似的。</p>
<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, thread_run, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<h3 id="退出线程"><a href="#退出线程" class="headerlink" title="退出线程"></a>退出线程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 退出线程pthread_exit(-1);</span></span><br></pre></td></tr></table></figure>
<h3 id="回收线程"><a href="#回收线程" class="headerlink" title="回收线程"></a>回收线程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pthread_join</span>(tid,(<span class="type">void</span>**)&amp;retval);</span><br></pre></td></tr></table></figure>
<p>一般情况下需要回收线程，retval 用来接收线程的返回值，tid 是线程的id，该方法会阻塞等待<br>什么情况下不需要回收呢？除非调用了分离线程</p>
<h3 id="杀死（取消）线程"><a href="#杀死（取消）线程" class="headerlink" title="杀死（取消）线程"></a>杀死（取消）线程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pthread_cancel</span>(tid);<span class="comment">// 返回值是 -1，表示被干掉取消需要有函数进内核。</span></span><br></pre></td></tr></table></figure>
<h3 id="分离线程"><a href="#分离线程" class="headerlink" title="分离线程"></a>分离线程</h3><p>分离线程之后是不会等待回收，会自动回收，也就是说线程需要回收，有两种方式一种是 join 一种是 detach 分离。</p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><h1 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h1><h2 id="makefile、cmake-与-shell-之间的联系"><a href="#makefile、cmake-与-shell-之间的联系" class="headerlink" title="makefile、cmake 与 shell 之间的联系"></a>makefile、cmake 与 shell 之间的联系</h2><p>makefile ： 帮助我们管理编译项目<br>cmake ： CMake 是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的 Makefile 或者 project 文件，CMake 并不直接建构出最终的软件，而是产生标准的建构档（如 Makefile 或 projects）。<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/528eeb266f83">https://www.jianshu.com/p/528eeb266f83</a><br>shell 脚本：一系列命令和语法</p>
<h2 id="makefile-自动编译和链接"><a href="#makefile-自动编译和链接" class="headerlink" title="makefile 自动编译和链接"></a>makefile 自动编译和链接</h2><p>Android.mk  Application.mk<br>gcc hello.cpp div.cpp sub.cpp add.cpp -o hellogcc 四步骤：生成 .o 文件比较耗时（汇编阶段）<br>上面的编译步骤其实就是省略了编译四步骤，假设现在我改了一个文件，需要重新编译，那么每次都会重新生成 .o 文件，因此需要把上面的步骤进行拆分<br>gcc -c sub.cpp -o sub.ogcc -c add.cpp -o add.ogcc -c div.cpp -o div.ogcc -c hello.cpp -o hello.ogcc add.o sub.o div.o hello.o -o hello怎么写？<br>2.1 一个规则<br>目标：依赖条件<br>（一个tab缩进） 命令</p>
<ol>
<li>若想要生成目标文件，会检查规则中的依赖是否存在，如果不存在，则寻找是否有完整的规则来生成该依赖条件</li>
<li>会检查规则中的目标是否需要更新，必须先检查它所有依赖项，依赖中任一个被更改，则目标必须更新 （原理就是检测更新时间）</li>
</ol>
<p>a.out : a.c<br>    gcc a.c -o a.out</p>
<p>2.2 两个函数<br>src &#x3D; $(wildcard *.cpp)<br>找到当前目录下所有后缀为 .cpp 的文件，然后赋值给 src<br>obj &#x3D; $(patsubst %cpp,%o,$(src))<br>就是把src变量里的所有后缀为 .cpp 的文件替换成 .o 文件</p>
<p>make clean -n 注意加上 -n 预执行</p>
<p>make clean 执行 clean 命令</p>
<p>2.3 三个自动变量<br>$@：表示规则中的目标<br>$^  ：表示规则中所有的依赖条件，组成一个列表，以空格隔开，如果这个列表有重复项则消除重复<br>$&lt;  ： 表示规则中的第一个依赖条件，如果运行在模式套用中，相当于依次取出依赖条件套用该模式规则</p>
<p>作业：把 div.cpp sub.cpp mul.cpp add.cpp 生成一个 libmath.so 库文件，然后在其他项目中使用</p>
<h2 id="cmake-简介与安装"><a href="#cmake-简介与安装" class="headerlink" title="cmake 简介与安装"></a>cmake 简介与安装</h2><p>写 CMakeLists.txt 里面用 CMake 语法写，会帮我们生成 Makefile 用于编译管理项目<br>大家自己用命令的方式去尝试安装，这里带大家用 jar 包的方式安装</p>
<ol>
<li><p>CMake 安装问题补充<br><a target="_blank" rel="noopener" href="https://cmake.org/cmake-tutorial/">https://cmake.org/cmake-tutorial/</a></p>
</li>
<li><p>上传 cmake 资源部，然后解压</p>
</li>
<li><p>运行 .&#x2F;bootstrap </p>
</li>
<li><p>运行 make</p>
</li>
<li><p>任意目录运行 cmake –version 看是否正常</p>
</li>
<li><p>配置环境变量 vim &#x2F;etc&#x2F;profile</p>
</li>
<li><p>source &#x2F;etc&#x2F;profile 让环境变量生效</p>
</li>
</ol>
<h2 id="初试-CMake-的-HelloWorld"><a href="#初试-CMake-的-HelloWorld" class="headerlink" title="初试 CMake 的 HelloWorld"></a>初试 CMake 的 HelloWorld</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给工程取一个名字</span></span><br><span class="line"><span class="keyword">PROJECT</span> (HELLO)</span><br><span class="line"><span class="comment"># 定义一个变量</span></span><br><span class="line"><span class="keyword">SET</span>(SRC_LIST hello.cpp)</span><br><span class="line"><span class="comment"># 打印</span></span><br><span class="line"><span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;this is BINARY dir &quot;</span><span class="variable">$&#123;HELLO_BINARY_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;this is SOURCE dir &quot;</span><span class="variable">$&#123;HELLO_SOURCE_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;this is PROJECT_SOURCE dir &quot;</span><span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>)</span><br><span class="line"><span class="comment"># 生成可执行文件</span></span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(hello.out <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="构建生成-so-动态库"><a href="#构建生成-so-动态库" class="headerlink" title="构建生成 .so 动态库"></a>构建生成 .so 动态库</h2><p>把 src 里的源文件，生成 .so 动态库，libmath.so 最终生成在 lib 目录下</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定 CMake 的最低编译版本</span></span><br><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class="number">3.14</span>)</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="keyword">PROJECT</span> (<span class="keyword">MATH</span>)</span><br><span class="line"><span class="comment"># 搜集 src 目录下的所有 .cpp 文件(源文件)</span></span><br><span class="line"><span class="comment"># SRC_LIST 代表 src 目录下的所有源文件 </span></span><br><span class="line"><span class="comment"># AUX_SOURCE_DIRECTORY ($&#123;PROJECT_SOURCE_DIR&#125;/src SRC_LIST)</span></span><br><span class="line"><span class="keyword">FILE</span>(GLOB SRC_LIST_CPP <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br><span class="line"><span class="keyword">FILE</span>(GLOB SRC_LIST_C <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/src/*.c&quot;</span>)</span><br><span class="line"><span class="comment"># 指定头文件在哪个目录</span></span><br><span class="line"><span class="keyword">INCLUDE_DIRECTORIES</span> (<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># 指定 so 的生成目录 lib</span></span><br><span class="line"><span class="keyword">SET</span> (LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># MESSAGE (STATUS &quot;src_list : &quot;$&#123;SRC_LIST&#125;)</span></span><br><span class="line"><span class="comment"># 指定生成动态库 .so  math -&gt; libmath.so  默认生成的是静态库 </span></span><br><span class="line"><span class="keyword">ADD_LIBRARY</span> (<span class="keyword">math</span> SHARED <span class="variable">$&#123;SRC_LIST_CPP&#125;</span> <span class="variable">$&#123;SRC_LIST_C&#125;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="链接外部动态库与头文件"><a href="#链接外部动态库与头文件" class="headerlink" title="链接外部动态库与头文件"></a>链接外部动态库与头文件</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定 CMake 的最低编译版本</span></span><br><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class="number">3.14</span>)</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="keyword">PROJECT</span> (HELLO)</span><br><span class="line"><span class="comment"># 指定头文件在哪个目录</span></span><br><span class="line"><span class="keyword">INCLUDE_DIRECTORIES</span> (<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># 编译是需要链接 lib 目录下的 libmath.so</span></span><br><span class="line"><span class="comment"># 指定 so 在哪个目录下</span></span><br><span class="line"><span class="keyword">LINK_DIRECTORIES</span> (<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># 生成可执行文件</span></span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span> (hello hello.cpp)</span><br><span class="line"><span class="comment"># 为 hello 添加编译链接库</span></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span> (hello <span class="keyword">math</span>)</span><br></pre></td></tr></table></figure>
<h2 id="编写基于-FFmpeg-开发的-CmakeLists-txt"><a href="#编写基于-FFmpeg-开发的-CmakeLists-txt" class="headerlink" title="编写基于 FFmpeg 开发的 CmakeLists.txt"></a>编写基于 FFmpeg 开发的 CmakeLists.txt</h2><p>第三次课的内容下载下来</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定最低版本名称</span></span><br><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class="number">3.4</span>.<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 指定引入头文件目录INCLUDE_DIRECTORIES($&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs/include)</span></span><br><span class="line"><span class="keyword">INCLUDE_DIRECTORIES</span>(<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/src/main/jniLibs/other)</span><br><span class="line"><span class="comment"># 指定共享库的库目录</span></span><br><span class="line"><span class="keyword">LINK_DIRECTORIES</span>(<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/src/main/jniLibs/armeabi)</span><br><span class="line"><span class="comment"># 指定源文件的目录</span></span><br><span class="line"><span class="keyword">AUX_SOURCE_DIRECTORY</span>(<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/src/main/cpp SRC_LIST)</span><br><span class="line"><span class="comment"># 生成 native-lib</span></span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(native-lib SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="comment"># 为 native-lib 添加 ffmpeg 编译链接库</span></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span>(native-lib  avcodec-<span class="number">56</span></span><br><span class="line">avdevice-<span class="number">56</span></span><br><span class="line">avfilter-<span class="number">5</span></span><br><span class="line">avformat-<span class="number">56</span></span><br><span class="line">avutil-<span class="number">54</span></span><br><span class="line">postproc-<span class="number">53</span></span><br><span class="line">swresample-<span class="number">1</span></span><br><span class="line">swscale-<span class="number">3</span></span><br><span class="line">-landroid</span><br><span class="line">-llog)</span><br></pre></td></tr></table></figure>
<h2 id="交叉编译生成-Android-平台的-so"><a href="#交叉编译生成-Android-平台的-so" class="headerlink" title="交叉编译生成 Android 平台的 .so"></a>交叉编译生成 Android 平台的 .so</h2><p>找一些资料，然后编译成 android 平台的，运行的 AS 项目中</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>王水泥</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://king-of-cement.gitee.io/blog/post/%E5%85%B6%E4%BB%96/%E5%90%84%E7%A7%8D%E8%AF%AD%E8%A8%80&%E5%90%84%E7%A7%8D%E5%B9%B3%E5%8F%B0/">http://king-of-cement.gitee.io/blog/post/%E5%85%B6%E4%BB%96/%E5%90%84%E7%A7%8D%E8%AF%AD%E8%A8%80&%E5%90%84%E7%A7%8D%E5%B9%B3%E5%8F%B0/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/blog/tags/%E8%AF%AD%E8%A8%80/"># 语言</a>
                    
                        <a href="/blog/tags/%E5%B7%A5%E5%85%B7/"># 工具</a>
                    
                        <a href="/blog/tags/%E5%B9%B3%E5%8F%B0/"># 平台</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/blog/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/blog/post/Android/Android%20%E8%BF%9B%E7%A8%8B%20or%20%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/">Android 进程\线程间的通信</a>
            
            
            <a class="next" rel="next" href="/blog/post/Android/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%A1%86%E6%9E%B6/">图片加载框架</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 王水泥 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>
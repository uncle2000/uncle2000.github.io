<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="王水泥">


    <meta name="subtitle" content="技术，etc">


    <meta name="description" content="不要传播">



<title>网络通信 | 王水泥个人博客</title>



    <link rel="icon" href="/blog/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/blog/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/blog/js/script.js"></script>
    
    <script src="/blog/js/tocbot.min.js"></script>
    




<meta name="generator" content="Hexo 5.4.2"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/blog/">王水泥的博客</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/blog/archives">Posts</a>
                
                    <a class="menu-item" href="/blog/category">Categories</a>
                
                    <a class="menu-item" href="/blog/tag">Tags</a>
                
                    <a class="menu-item" href="/blog/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/blog/">王水泥的博客</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/blog/archives">Posts</a>
                
                    <a class="menu-item" href="/blog/category">Categories</a>
                
                    <a class="menu-item" href="/blog/tag">Tags</a>
                
                    <a class="menu-item" href="/blog/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">网络通信</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">王水泥</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">十一月 1, 2022&nbsp;&nbsp;16:23:33</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/blog/categories/%E7%BD%91%E7%BB%9C/">网络</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h1><p>[toc]</p>
<h2 id="Restful-URL"><a href="#Restful-URL" class="headerlink" title="Restful URL"></a>Restful URL</h2><p>中文名称：表现层状态转化。用 URL 表示要操作的资源，用不同的 HTTP 请求（GET，POST，PUT，DELETE）描述对资源的操作，通过 HTTP 的状态码来判断此次对资源操作的结果，这就是 Restful风格。</p>
<p>其实 Restful 风格是对请求的一次解耦，提高了 url 的重用性。</p>
<p>状态转化：客户端通过 http 协议访问服务端资源,通过 http 协议里面定义好的四个动词：GET POST PUT DELETE 来讲资源进行状态转化。<br>GET 用来获取资源<br>POST 用来新增资源<br>PUT 用来更新资源<br>DELETE 用来删除资源<br>put和delete虽然是http协议的规范 ,但是遗憾的是,所有的无论是html4还是h5都不支持,所以我们在实际开开发过程当中要模拟这两种状态。</p>
<p>普通的URL开发方式 ：<a target="_blank" rel="noopener" href="http://qujianlei.com/getUserList">http://qujianlei.com/getUserList</a> addUser deleteUser updateUser</p>
<p>Restful风格的URL：</p>
<p><a target="_blank" rel="noopener" href="http://qujianlei.com/users/">http://qujianlei.com/users/</a> method &#x3D; “get” 获取用户列表<br><a target="_blank" rel="noopener" href="http://qujianlei.com/user">http://qujianlei.com/user</a> method &#x3D; “post” 更新用户<br><a target="_blank" rel="noopener" href="http://qujianlei.com/user">http://qujianlei.com/user</a> method&#x3D;“delete” 删除用户<br><a target="_blank" rel="noopener" href="http://qujianlei.com/user">http://qujianlei.com/user</a> method &#x3D; “put” 新增用户</p>
<h2 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a>Http协议</h2><p>所谓协议，就是指双方遵循的规范。http协议，就是浏览器和服务器之间进行“沟通”的一种规范。<br>笔者一直听说http是属于“应用层的协议”，而且是基于TCP&#x2F;IP协议的。这个不难理解，如果你上大学时候学过“计算机网络”的课程，就一定知 道OSI七层参考协议（我当时是死记硬背的）。如果你接触过socket网络编程，就应该明白TCP和UDP这两种使用广泛的通信协议（建立连接、三次握 手等等，当然，这不是本文讨论的重点）。如图：<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/%E7%BD%91%E7%BB%9C/.1606907482381.png" alt="Alt text"><br>既然TCP&#x2F;UDP是广泛使用的网络通信协议，那为啥有多出个http协议来呢？<br>笔者曾自己动手写过一个简单的web服务器处理软件，根据我的推断（不一定准确)。UDP协议具有不可靠性和不安全性，显然这很难满足web应用的需要。</p>
<p>而TCP协议是基于连接和三次握手的，虽然具有可靠性，但人具有一定的缺陷。但试想一下，普通的C&#x2F;S架构软件，顶多上千个Client同时连接，而B&#x2F;S架构的网站，十万人同时在线也是很平常的事儿。如果十万个客户端和服务器一直保持连接状态，那服务器如何满足承载呢？</p>
<p>这就衍生出了http协议。基于TCP的可靠性连接。通俗点说，就是在请求之后，服务器端立即关闭连接、释放资源。这样既保证了资源可用，也吸取了TCP的可靠性的优点。</p>
<p>正因为这点，所以大家通常说http协议是“无状态”的，也就是“服务器不知道你客户端干了啥”，其实很大程度上是基于性能考虑的。以至于后来有了session之类的玩意。</p>
<p>实战准备工作：</p>
<p>在监视网络方面，windows平台上有一款叫做Sniffer的优秀软件，这也是很多“黑客”经常使用的嗅探工具。 在研究http协议时，推荐大家使用一款</p>
<p>叫作httpwatch的工具。（遗憾的是，该工具是收费的。该咋办就咋办，你懂的）。安装完成后，可以在IE浏览器的tools中直接打开（目前也支持firefox）。如图所示：<br>学习http协议，主要需要了解http的请求和响应（当然，还有get、post等请求方式，状态码、URI、MIME等）<br>首先看看http请求消息（就是浏览器丢给服务器的）：</p>
<p>一个http请求代表客户端浏览器向服务器发送的数据。一个完整的http请求消息，包含一个请求行，若干个消息头（请求头），换行，实体内容</p>
<p>请求行：描述客户端的请求方式、请求资源的名称、http协议的版本号。 例如： GET&#x2F;BOOK&#x2F;JAVA.HTML HTTP&#x2F;1.1</p>
<p>请求头（消息头）包含（客户机请求的服务器主机名，客户机的环境信息等）：<br>Accept：用于告诉服务器，客户机支持的数据类型 （例如：Accept:text&#x2F;html,image&#x2F;*）<br>Accept-Charset：用于告诉服务器，客户机采用的编码格式<br>Accept-Encoding：用于告诉服务器，客户机支持的数据压缩格式<br>Accept-Language：客户机语言环境<br>Host:客户机通过这个服务器，想访问的主机名<br>If-Modified-Since：客户机通过这个头告诉服务器，资源的缓存时间<br>Referer：客户机通过这个头告诉服务器，它（客户端）是从哪个资源来访问服务器的（防盗链）<br>User-Agent：客户机通过这个头告诉服务器，客户机的软件环境（操作系统，浏览器版本等）<br>Cookie：客户机通过这个头，将Coockie信息带给服务器<br>Connection：告诉服务器，请求完成后，是否保持连接<br>Date：告诉服务器，当前请求的时间</p>
<p>（换行）<br>实体内容：<br>就是指浏览器端通过http协议发送给服务器的实体数据。例如：name&#x3D;dylan&amp;id&#x3D;110<br>（get请求时，通过url传给服务器的值。post请求时，通过表单发送给服务器的值）</p>
<p>再看看HTTP响应消息（服务器返回给浏览器的）：</p>
<p>一个http响应代表服务器端向客户端回送的数据，它包括：<br>一个状态行，若干个消息头，以及实体内容</p>
<p>响应头(消息头)包含:<br>Location：这个头配合302状态吗，用于告诉客户端找谁<br>Server：服务器通过这个头，告诉浏览器服务器的类型<br>Content-Encoding：告诉浏览器，服务器的数据压缩格式<br>Content-Length：告诉浏览器，回送数据的长度<br>Content-Type：告诉浏览器，回送数据的类型<br>Last-Modified：告诉浏览器当前资源缓存时间<br>Refresh：告诉浏览器，隔多长时间刷新<br>Content-Disposition：告诉浏览器以下载的方式打开数据。例如： context.Response.AddHeader(“Content-Disposition”,”attachment:filename&#x3D;aa.jpg”); context.Response.WriteFile(“aa.jpg”);<br>Transfer-Encoding：告诉浏览器，传送数据的编码格式<br>ETag：缓存相关的头（可以做到实时更新）<br>Expries：告诉浏览器回送的资源缓存多长时间。如果是-1或者0，表示不缓存<br>Cache-Control：控制浏览器不要缓存数据 no-cache<br>Pragma：控制浏览器不要缓存数据 no-cache</p>
<p>Connection：响应完成后，是否断开连接。 close&#x2F;Keep-Alive<br>Date：告诉浏览器，服务器响应时间</p>
<p>状态行： 例如： HTTP&#x2F;1.1 200 OK （协议的版本号是1.1 响应状态码为200 响应结果为 OK）</p>
<p>实体内容（实体头）：响应包含浏览器能够解析的静态内容，例如：html，纯文本，图片等等信息</p>
<p>理解了以上的http请求消息和响应消息，相信你对于http协议已经理解得足够深刻了。关于http协议的更多具体细节，可以参照http RFC文档。</p>
<p>大致步骤就是：浏览器先向服务器发送请求，服务器接收到请求后，做相应的处理，然后封装好响应报文，再回送给浏览器。浏览器拿到响应报文后，再通过 浏览器引擎去渲染网页，解析DOM树，javascript引擎解析并执行脚本操作，插件去干插件该干的事儿…关于浏览器渲染、解析的原理，可以参考<a target="_blank" rel="noopener" href="http://kb.cnblogs.com/page/129756/">http://kb.cnblogs.com/page/129756/</a></p>
<p>说白了，所谓web的本质，无非是：请求&#x2F;处理&#x2F;响应 ，任何的web服务器，任何的服务端编程语言，都没法脱离这个本质。 而浏览器端解析html、图片等静态内容，呈现给用户，脚本引擎执行脚本代码，完成脚本代码要做的事儿（例如dom操作，css属性更改，发送ajax请 求等等）。</p>
<h2 id="TCP-x2F-IP协议详解"><a href="#TCP-x2F-IP协议详解" class="headerlink" title="TCP&#x2F;IP协议详解"></a>TCP&#x2F;IP协议详解</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>简单来说，协议就是计算机之间通过网络实现通信时事先达成的一种“约定”；这种“约定”使那些由不同厂商的设备，不同CPU及不同操作系统组成的计算机之间，只要遵循相同的协议就可以实现通信。TCP&#x2F;IP通常被认为是一个四层协议，如图：</p>
<p><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/%E7%BD%91%E7%BB%9C/.1606907773360.png" alt="Alt text"></p>
<ul>
<li>链路层:数据链路层或网络接口层，包括设备驱动程序和网络接口卡，它们一起处理与电缆的物理接口细节。</li>
<li>网络层:处理分组在网络中的活动，如分组的选路；网络层的协议包括IP协议、ICMP协议（Internet互联网控制报文协议）、IGMP协议（Internet组管理协议）。</li>
<li>传输层:主要为两台主机上的应用程序提供端到端的通信，包括TCP（传输控制协议）和UDP（用户数据报协议）。</li>
<li>应用层:处理特定的应用程序细节。<br> <img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/%E7%BD%91%E7%BB%9C/.1606907932547.png" alt="Alt text"><br>链路层的三个主要作用：<br>1)为IP模块发送和接受IP数据；<br>2)为ARP模块发送ARP请求和接受ARP应答；<br>3)为RARP发送RARP请求和接受RARP应答。<blockquote>
<p>TCP创建过程和链接折除过程是由TCP&#x2F;IP协议栈自动创建的，所以开发者并不需要理解得十分透彻，只需要对TCP底层运作机制有一个大致理解即可，这一块有些复杂，先做个笔记，以后有需要，再做详细扩展</p>
</blockquote>
</li>
</ul>
<p>拓展：检测网络是否联通的命令——Ping<br>Ping的目的是为了测试另一台主机是否可达，该命令会发送一份ICMP回显请求报文给主机，并等待返回ICMP回显应答。<br>Ping程序还能测出到这台主机的往返时间，大多数的TCP&#x2F;IP实现都在内核中直接支持Ping服务，这种服务器不是一个用户进程。Ping程序通过在ICMP报文数据中存放请求的时间值来计算往返时间。当应答返回时，用当前时间减去存放在ICMP报文中的时间值，既是往返时间。<br>什么是传输包？<br>将需要传输的数据分割为一个个小的单位进行传输的方法<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/%E7%BD%91%E7%BB%9C/.1606908127954.png" alt="Alt text"><br>通信过程中，每一个分组中都会附加上源主机地址和目标主机地址送给通信线路，这些发送端地址、接收端地址以及分组序号写入的部分就是“报文首部”；如果数据较大，分组过多，那么就有必要将分组序号写入包中，接收端会根据序号，分组按序重新装配为原始数据。(理解丢包就需要知道什么是包)</p>
<h3 id="什么是“三次握手，四次挥手”？"><a href="#什么是“三次握手，四次挥手”？" class="headerlink" title="什么是“三次握手，四次挥手”？"></a>什么是“三次握手，四次挥手”？</h3><p>TCP是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。该“连接”就是客户端和服务器的内存里保存的关于ip地址、端口号等对方的信息。TCP可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。</p>
<p>TCP提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接，采用4次挥手来关闭一个连接。</p>
<h3 id="为什么要“三次握手，四次挥手”？"><a href="#为什么要“三次握手，四次挥手”？" class="headerlink" title="为什么要“三次握手，四次挥手”？"></a>为什么要“三次握手，四次挥手”？</h3><p>1）所谓三次握手(Three-way Handshake)，是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。三次握手的目的是连接服务器指定端口，建立TCP连接,并同步连接双方的序列号和确认号并交换 TCP 窗口大小信息。在socket编程中，客户端执行connect()时，将触发三次握手：即客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力正常。<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/%E7%BD%91%E7%BB%9C/.1606909585006.png" alt="Alt text"><br>第一次握手：客户端发送网络包，服务端收到。服务端得出结论：客户端发送能力、服务端接收能力正常。</p>
<p>第二次握手：服务端发包，客户端收到。客户端得出结论：服务端接收、发送能力正常，客户端接收、发送能力正常。</p>
<p>第三次握手：客户端发包，服务端收到。服务端得出结论：客户端接收、发送能力正常，服务端发送、接收能力正常。<br>所以第一、二次握手，只是为了验证彼此的接收发送能力是否正常。经历上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的，就可以正常通信了。</p>
<p>2）所谓四次挥手(four-way handshake)，就是指TCP的连接的拆除过程需要发送四个包，客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/%E7%BD%91%E7%BB%9C/.1606909599754.png" alt="Alt text"><br>TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。客户端或者服务端皆可以主动发送指令告诉对方，我要关闭连接了，比如：<br>客户端：我要关闭连接了（客户端发起Close）<br>服务端：好，你关吧（服务端收到关闭指令，回了一个ACK）【此时客户端不可以向服务端传输数据，但是服务端仍然可以向客户端传输数据】<br>服务端：我传完所有数据啦（发送一个FIN段来关闭向客户端传输方向上的连接）<br>客户端：哦，好的，知道（发送ACK确认关闭连接）</p>
<p>注意：接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，因为结束数据传输的“指令”是上层应用层给出的，它只负责“搬运”。</p>
<h2 id="SSL握手"><a href="#SSL握手" class="headerlink" title="SSL握手"></a>SSL握手</h2><h3 id="1、客户端发出加密通信请求ClientHello"><a href="#1、客户端发出加密通信请求ClientHello" class="headerlink" title="1、客户端发出加密通信请求ClientHello"></a>1、客户端发出加密通信请求ClientHello</h3><p>提供：<br>1，协议版本（如TSL1.0）<br>2，随机数1（用于生成对话密钥）<br>3，支持的加密方法（如RSA公钥加密）<br>4，支持的压缩方法</p>
<h3 id="2、服务器回应SeverHello"><a href="#2、服务器回应SeverHello" class="headerlink" title="2、服务器回应SeverHello"></a>2、服务器回应SeverHello</h3><p>回应内容：<br>1，确认使用的加密通信协议版本（TSL1.0）<br>2，随机数2（用于生成对话密钥）<br>3，确认加密方法（RSA）<br>4，服务器证书（包含非对称加密的公钥）<br>5，（可选）要求客户端提供证书的请求</p>
<h3 id="3、客户端验证证书"><a href="#3、客户端验证证书" class="headerlink" title="3、客户端验证证书"></a>3、客户端验证证书</h3><p>如果证书不是可信机构颁布，或证书域名与实际域名不符，或者证书已经过期，就会向访问者显示一个警告，是否继续通信</p>
<h3 id="4-、客户端回应"><a href="#4-、客户端回应" class="headerlink" title="4 、客户端回应"></a>4 、客户端回应</h3><p>证书没有问题，就会取出证书中的服务器公钥<br>然后发送：<br>1，随机数3（pre-master key，此随机数用服务器公钥加密，防止被窃听）<br>2，编码改变通知（表示随后的信息都将用双方商定的方法和密钥发送）<br>3，客户端握手结束通知</p>
<h3 id="5、双方生成会话密钥"><a href="#5、双方生成会话密钥" class="headerlink" title="5、双方生成会话密钥"></a>5、双方生成会话密钥</h3><p>双方同时有了三个随机数，接着就用事先商定的加密方法，各自生成同一把“会话密钥”<br>服务器端用自己的私钥（非对称加密的）获取第三个随机数，会计算生成本次所用的会话密钥（对称加密的密钥），如果前一步要求客户端证书，会在这一步验证</p>
<h3 id="6、服务器最后响应"><a href="#6、服务器最后响应" class="headerlink" title="6、服务器最后响应"></a>6、服务器最后响应</h3><p>服务器生成会话密钥后，向客户端发送：<br>1，编码改变通知（后面的信息都用双方的加密方法和密钥来发送）<br>2，服务器握手结束通知</p>
<p>至此，握手阶段全部结束，接下来客户端与服务器进入加密通信，用会话密钥加密内容</p>
<h2 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h2><p>网络中的大部分通讯都是基于TCP&#x2F;IP协议的，而TCP&#x2F;IP协议中有个很重要的协议——IP协议，它是基于IP地址的。我们无法记住大量的IP地址，所以就需要DNS服务器能把域名翻译成IP地址。</p>
<h3 id="什么是DNS"><a href="#什么是DNS" class="headerlink" title="什么是DNS?"></a>什么是DNS?</h3><p>它所提供的服务是用来将主机名和域名转换为IP地址的工作。我们知道域名和IP地址是一一对应的关系，但是多个域名可以对应同一个IP地址。<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/%E7%BD%91%E7%BB%9C/.1606909924862.png" alt="Alt text"></p>
<h3 id="DNS查询过程"><a href="#DNS查询过程" class="headerlink" title="DNS查询过程"></a>DNS查询过程</h3><ul>
<li>递归：DNS服务器可使用其自身的资源记录信息缓存来应答查询，也可代表请求客户机来查询或联系其他DNS服务器，以完全解析该名称，并随后将应答返回至客户机。</li>
<li>迭代：客户机自己也可尝试l联系其他的DNS服务器来解析名称。如果客户机这么做，它会使用基于服务器应答的独立和附加的查询。</li>
</ul>
<p>1、在浏览器中输入域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系。<br>2、如果hosts里没有映射关系，查找本地DNS解析器缓存。<br>3、如果还是没有，首先会找TCP&#x2F;IP参数中设置的首选DNS服务器。<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/%E7%BD%91%E7%BB%9C/.1606910090709.png" alt="Alt text"></p>
<h2 id="SOCKS代理"><a href="#SOCKS代理" class="headerlink" title="SOCKS代理"></a>SOCKS代理</h2><p>全能代理，就像有很多跳线的转接板，它只是简单地将一端的系统连接到另外一端。支持多种协议，包括http、ftp请求及其它类型的请求。它分socks 4 和socks 5两种类型，socks 4只支持TCP协议而socks 5支持TCP&#x2F;UDP协议，还支持各种身份验证机制等协议。其标准端口为1080。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>socks代理相应的采用socks协议的代理服务器就是SOCKS服务器，是一种通用的代理服务器。Socks是个电路级的底层网关，是DavidKoblas在1990年开发的，此后就一直作为Internet RFC标准的开放标准。Socks不要求应用程序遵循特定的操作系统平台，Socks 代理与应用层代理、 HTTP 层代理不同，Socks代理只是简单地传递数据包，而不必关心是何种应用协议（比如FTP、HTTP和NNTP请求）。所以，Socks代理比其他应用层代理要快得多。它通常绑定在代理服务器的1080端口上。如果您在企业网或校园网上，需要透过防火墙或通过代理服务器访问Internet就可能需要使用SOCKS。一般情况下，对于拨号上网用户都不需要使用它。注意，浏览网页时常用的代理服务器通常是专门的http代理，它和SOCKS是不同的。因此，您能浏览网页不等于您一定可以通过SOCKS访问Internet。 常用的防火墙，或代理软件都支持SOCKS，但需要其管理员打开这一功能。如果您不确信您是否需要SOCKS或是否有SOCKS可用，请与您的网络管理员联系。为了使用socks，您需要了解一下内容：</p>
<p>① SOCKS服务器的IP地址<br>② SOCKS服务所在的端口<br>③ 这个SOCKS服务是否需要用户认证？如果需要，您要向您的网络管理员申请一个用户和口令</p>
<p>知道了上述信息，您就可以把这些信息填入“网络配置”中，或者在第一次登记时填入，您就可以使用socks代理了。</p>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>在实际应用中SOCKS代理可以用作为：电子邮件、新闻组软件、网络传呼ICQ、网络聊天MIRC和使用代理服务器打游戏等等各种应用软件当中。</p>
<h2 id="HTTP普通代理-amp-隧道代理"><a href="#HTTP普通代理-amp-隧道代理" class="headerlink" title="HTTP普通代理&amp;隧道代理"></a>HTTP普通代理&amp;隧道代理</h2><h3 id="普通代理"><a href="#普通代理" class="headerlink" title="普通代理"></a>普通代理</h3><p> HTTP 客户端向代理发送请求报文，代理服务器需要正确地处理请求和连接（例如正确处理 Connection: keep-alive），同时向服务器发送请求，并将收到的响应转发给客户端。</p>
<p>下面这张图片来自于《HTTP 权威指南》，直观地展示了上述行为：<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/%E7%BD%91%E7%BB%9C/.1606910497239.png" alt="Alt text"><br>假如我通过代理访问 A 网站，对于 A 来说，它会把代理当做客户端，完全察觉不到真正客户端的存在，这实现了隐藏客户端 IP 的目的。当然代理也可以修改 HTTP 请求头部，通过 X-Forwarded-IP 这样的自定义头部告诉服务端真正的客户端 IP。但服务器无法验证这个自定义头部真的是由代理添加，还是客户端修改了请求头，所以从 HTTP 头部字段获取 IP 时，需要格外小心。这部分内容可以参考我之前的《 HTTP 请求头中的 X-Forwarded-For》这篇文章。<br>给浏览器显式的指定代理，需要手动修改浏览器或操作系统相关设置，或者指定 PAC（Proxy Auto-Configuration，自动配置代理）文件自动设置，还有些浏览器支持 WPAD（Web Proxy Autodiscovery Protocol，Web 代理自动发现协议）。显式指定浏览器代理这种方式一般称之为正向代理，浏览器启用正向代理后，会对 HTTP 请求报文做一些修改，来规避老旧代理服务器的一些问题，这部分内容可以参考我之前的《Http 请求头中的 Proxy-Connection》这篇文章。</p>
<p>还有一种情况是访问 A 网站时，实际上访问的是代理，代理收到请求报文后，再向真正提供服务的服务器发起请求，并将响应转发给浏览器。这种情况一般被称之为反向代理，它可以用来隐藏服务器 IP 及端口。一般使用反向代理后，需要通过修改 DNS 让域名解析到代理服务器 IP，这时浏览器无法察觉到真正服务器的存在，当然也就不需要修改配置了。反向代理是 Web 系统最为常见的一种部署方式，例如本博客就是使用 Nginx 的 proxy_pass 功能将浏览器请求转发到背后的 Node.js 服务。</p>
<p>了解完第一种代理的基本原理后，我们用 Node.js 实现一下它。只包含核心逻辑的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">http</span> <span class="operator">=</span> require(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">net</span> <span class="operator">=</span> require(<span class="string">&#x27;net&#x27;</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">url</span> <span class="operator">=</span> require(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">function <span class="title function_">request</span><span class="params">(cReq, cRes)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">u</span> <span class="operator">=</span> url.parse(cReq.url);</span><br><span class="line"> </span><br><span class="line">    <span class="type">var</span> <span class="variable">options</span> <span class="operator">=</span> &#123;</span><br><span class="line">        hostname : u.hostname, </span><br><span class="line">        port     : u.port || <span class="number">80</span>,</span><br><span class="line">        path     : u.path,       </span><br><span class="line">        method     : cReq.method,</span><br><span class="line">        headers     : cReq.headers</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="type">var</span> <span class="variable">pReq</span> <span class="operator">=</span> http.request(options, function(pRes) &#123;</span><br><span class="line">        cRes.writeHead(pRes.statusCode, pRes.headers);</span><br><span class="line">        pRes.pipe(cRes);</span><br><span class="line">    &#125;).on(<span class="string">&#x27;error&#x27;</span>, function(e) &#123;</span><br><span class="line">        cRes.end();</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    cReq.pipe(pReq);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">http.createServer().on(<span class="string">&#x27;request&#x27;</span>, request).listen(<span class="number">8888</span>, <span class="string">&#x27;0.0.0.0&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>以上代码运行后，会在本地 8888 端口开启 HTTP 代理服务，这个服务从请求报文中解析出请求 URL 和其他必要参数，新建到服务端的请求，并把代理收到的请求转发给新建的请求，最后再把服务端响应返回给浏览器。修改浏览器的 HTTP 代理为 127.0.0.1:8888 后再访问 HTTP 网站，代理可以正常工作。</p>
<p>但是，使用我们这个代理服务后，HTTPS 网站完全无法访问，这是为什么呢？答案很简单，这个代理提供的是 HTTP 服务，根本没办法承载 HTTPS 服务。那么是否把这个代理改为 HTTPS 就可以了呢？显然也不可以，因为这种代理的本质是中间人，而 HTTPS 网站的证书认证机制是中间人劫持的克星。普通的 HTTPS 服务中，服务端不验证客户端的证书，中间人可以作为客户端与服务端成功完成 TLS 握手；但是中间人没有证书私钥，无论如何也无法伪造成服务端跟客户端建立 TLS 连接。当然如果你拥有证书私钥，代理证书对应的 HTTPS 网站当然就没问题了。</p>
<p>HTTP 抓包神器 Fiddler 的工作原理也是在本地开启 HTTP 代理服务，通过让浏览器流量走这个代理，从而实现显示和修改 HTTP 包的功能。如果要让 Fiddler 解密 HTTPS 包的内容，需要先将它自带的根证书导入到系统受信任的根证书列表中。一旦完成这一步，浏览器就会信任 Fiddler 后续的「伪造证书」，从而在浏览器和 Fiddler、Fiddler 和服务端之间都能成功建立 TLS 连接。而对于 Fiddler 这个节点来说，两端的 TLS 流量都是可以解密的。</p>
<p>如果我们不导入根证书，Fiddler 的 HTTP 代理还能代理 HTTPS 流量么？实践证明，不导入根证书，Fiddler 只是无法解密 HTTPS 流量，HTTPS 网站还是可以正常访问。这是如何做到的，这些 HTTPS 流量是否安全呢？这些问题将在下一节揭晓。</p>
<h3 id="隧道代理"><a href="#隧道代理" class="headerlink" title="隧道代理"></a>隧道代理</h3><blockquote>
<p>HTTP 客户端通过 CONNECT 方法请求隧道代理创建一条到达任意目的服务器和端口的 TCP 连接，并对客户端和服务器之间的后继数据进行盲转发。<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/%E7%BD%91%E7%BB%9C/.1606911093242.png" alt="Alt text"><br>假如我通过代理访问 A 网站，浏览器首先通过 CONNECT 请求，让代理创建一条到 A 网站的 TCP 连接；一旦 TCP 连接建好，代理无脑转发后续流量即可。所以这种代理，理论上适用于任意基于 TCP 的应用层协议，HTTPS 网站使用的 TLS 协议当然也可以。这也是这种代理为什么被称为隧道的原因。对于 HTTPS 来说，客户端透过代理直接跟服务端进行 TLS 握手协商密钥，所以依然是安全的，下图中的抓包信息显示了这种场景：<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/%E7%BD%91%E7%BB%9C/.1606911160504.png" alt="Alt text"><br>可以看到，浏览器与代理进行 TCP 握手之后，发起了 CONNECT 请求，报文起始行如下：<br>CONNECT imququ.com:443 HTTP&#x2F;1.1<br>对于 CONNECT 请求来说，只是用来让代理创建 TCP 连接，所以只需要提供服务器域名及端口即可，并不需要具体的资源路径。代理收到这样的请求后，需要与服务端建立 TCP 连接，并响应给浏览器这样一个 HTTP 报文：</p>
</blockquote>
<p>HTTP&#x2F;1.1 200 Connection Established<br>浏览器收到了这个响应报文，就可以认为到服务端的 TCP 连接已经打通，后续直接往这个 TCP 连接写协议数据即可。通过 Wireshark 的 Follow TCP Steam 功能，可以清楚地看到浏览器和代理之间的数据传递：<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/%E7%BD%91%E7%BB%9C/.1606911249339.png" alt="Alt text"><br>可以看到，浏览器建立到服务端 TCP 连接产生的 HTTP 往返，完全是明文，这也是为什么 CONNECT 请求只需要提供域名和端口：如果发送了完整 URL、Cookie 等信息，会被中间人一览无余，降低了 HTTPS 的安全性。HTTP 代理承载的 HTTPS 流量，应用数据要等到 TLS 握手成功之后通过 Application Data 协议传输，中间节点无法得知用于流量加密的 master-secret，无法解密数据。而 CONNECT 暴露的域名和端口，对于普通的 HTTPS 请求来说，中间人一样可以拿到（IP 和端口很容易拿到，请求的域名可以通过 DNS Query 或者 TLS Client Hello 中的 Server Name Indication 拿到），所以这种方式并没有增加不安全性。</p>
<p>了解完原理后，再用 Node.js 实现一个支持 CONNECT 的代理也很简单。核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">http</span> <span class="operator">=</span> require(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">net</span> <span class="operator">=</span> require(<span class="string">&#x27;net&#x27;</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">url</span> <span class="operator">=</span> require(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">function <span class="title function_">connect</span><span class="params">(cReq, cSock)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">u</span> <span class="operator">=</span> url.parse(<span class="string">&#x27;http://&#x27;</span> + cReq.url);</span><br><span class="line"> </span><br><span class="line">    <span class="type">var</span> <span class="variable">pSock</span> <span class="operator">=</span> net.connect(u.port, u.hostname, function() &#123;</span><br><span class="line">        cSock.write(<span class="string">&#x27;HTTP/1.1 200 Connection Established\r\n\r\n&#x27;</span>);</span><br><span class="line">        pSock.pipe(cSock);</span><br><span class="line">    &#125;).on(<span class="string">&#x27;error&#x27;</span>, function(e) &#123;</span><br><span class="line">        cSock.end();</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    cSock.pipe(pSock);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">http.createServer().on(<span class="string">&#x27;connect&#x27;</span>, connect).listen(<span class="number">8888</span>, <span class="string">&#x27;0.0.0.0&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>以上代码运行后，会在本地 8888 端口开启 HTTP 代理服务，这个服务从 CONNECT 请求报文中解析出域名和端口，创建到服务端的 TCP 连接，并和 CONNECT 请求中的 TCP 连接串起来，最后再响应一个 Connection Established 响应。修改浏览器的 HTTP 代理为 127.0.0.1:8888 后再访问 HTTPS 网站，代理可以正常工作。</p>
<p>最后，将两种代理的实现代码合二为一，就可以得到全功能的 Proxy 程序了，全部代码在 50 行以内（当然异常什么的基本没考虑，这是我博客代码的一贯风格）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">http</span> <span class="operator">=</span> require(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">net</span> <span class="operator">=</span> require(<span class="string">&#x27;net&#x27;</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">url</span> <span class="operator">=</span> require(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">function <span class="title function_">request</span><span class="params">(cReq, cRes)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">u</span> <span class="operator">=</span> url.parse(cReq.url);</span><br><span class="line"> </span><br><span class="line">    <span class="type">var</span> <span class="variable">options</span> <span class="operator">=</span> &#123;</span><br><span class="line">        hostname : u.hostname, </span><br><span class="line">        port     : u.port || <span class="number">80</span>,</span><br><span class="line">        path     : u.path,       </span><br><span class="line">        method     : cReq.method,</span><br><span class="line">        headers     : cReq.headers</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="type">var</span> <span class="variable">pReq</span> <span class="operator">=</span> http.request(options, function(pRes) &#123;</span><br><span class="line">        cRes.writeHead(pRes.statusCode, pRes.headers);</span><br><span class="line">        pRes.pipe(cRes);</span><br><span class="line">    &#125;).on(<span class="string">&#x27;error&#x27;</span>, function(e) &#123;</span><br><span class="line">        cRes.end();</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    cReq.pipe(pReq);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function <span class="title function_">connect</span><span class="params">(cReq, cSock)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">u</span> <span class="operator">=</span> url.parse(<span class="string">&#x27;http://&#x27;</span> + cReq.url);</span><br><span class="line"> </span><br><span class="line">    <span class="type">var</span> <span class="variable">pSock</span> <span class="operator">=</span> net.connect(u.port, u.hostname, function() &#123;</span><br><span class="line">        cSock.write(<span class="string">&#x27;HTTP/1.1 200 Connection Established\r\n\r\n&#x27;</span>);</span><br><span class="line">        pSock.pipe(cSock);</span><br><span class="line">    &#125;).on(<span class="string">&#x27;error&#x27;</span>, function(e) &#123;</span><br><span class="line">        cSock.end();</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    cSock.pipe(pSock);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">http.createServer()</span><br><span class="line">    .on(<span class="string">&#x27;request&#x27;</span>, request)</span><br><span class="line">    .on(<span class="string">&#x27;connect&#x27;</span>, connect)</span><br><span class="line">    .listen(<span class="number">8888</span>, <span class="string">&#x27;0.0.0.0&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>需要注意的是，大部分浏览器显式配置了代理之后，只会让 HTTPS 网站走隧道代理，这是因为建立隧道需要耗费一次往返，能不用就尽量不用。但这并不代表 HTTP 请求不能走隧道代理，我们用 Node.js 写段程序验证下（先运行前面的代理服务）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">http</span> <span class="operator">=</span> require(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="type">var</span> <span class="variable">options</span> <span class="operator">=</span> &#123;</span><br><span class="line">    hostname : <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">    port     : <span class="number">8888</span>,</span><br><span class="line">    path     : <span class="string">&#x27;imququ.com:80&#x27;</span>,</span><br><span class="line">    method     : <span class="string">&#x27;CONNECT&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">var</span> <span class="variable">req</span> <span class="operator">=</span> http.request(options);</span><br><span class="line"> </span><br><span class="line">req.on(<span class="string">&#x27;connect&#x27;</span>, function(res, socket) &#123;</span><br><span class="line">    socket.write(<span class="string">&#x27;GET / HTTP/1.1\r\n&#x27;</span> +</span><br><span class="line">                 <span class="string">&#x27;Host: imququ.com\r\n&#x27;</span> +</span><br><span class="line">                 <span class="string">&#x27;Connection: Close\r\n&#x27;</span> +</span><br><span class="line">                 <span class="string">&#x27;\r\n&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">    socket.on(<span class="string">&#x27;data&#x27;</span>, function(chunk) &#123;</span><br><span class="line">        console.log(chunk.toString());</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    socket.on(<span class="string">&#x27;end&#x27;</span>, function() &#123;</span><br><span class="line">        console.log(<span class="string">&#x27;socket end.&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">req.end();</span><br></pre></td></tr></table></figure>
<p>这段代码运行完，结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">301</span> Moved Permanently</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Thu, <span class="number">19</span> Nov <span class="number">2015</span> <span class="number">15</span>:<span class="number">57</span>:<span class="number">47</span> GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: <span class="number">178</span></span><br><span class="line">Connection: close</span><br><span class="line">Location: https:<span class="comment">//imququ.com/</span></span><br><span class="line"> </span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;<span class="number">301</span> Moved Permanently&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body bgcolor=<span class="string">&quot;white&quot;</span>&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;<span class="number">301</span> Moved Permanently&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"> </span><br><span class="line">socket end.</span><br></pre></td></tr></table></figure>
<p>可以看到，通过 CONNECT 让代理打开到目标服务器的 TCP 连接，用来承载 HTTP 流量也是完全没问题的。</p>
<p>最后，HTTP 的认证机制可以跟代理配合使用，使得必须输入正确的用户名和密码才能使用代理，这部分内容比较简单，这里略过。</p>
<h1 id="OkHttp3"><a href="#OkHttp3" class="headerlink" title="OkHttp3"></a>OkHttp3</h1><h3 id="OkHttp-大致内容-Okio，Socket，拦截器"><a href="#OkHttp-大致内容-Okio，Socket，拦截器" class="headerlink" title="OkHttp 大致内容 Okio，Socket，拦截器"></a>OkHttp 大致内容 Okio，Socket，拦截器</h3><blockquote>
<p>okio：原生的JavaIO + 自定义封装 ，其实就是对于 io 的封装<br>Socket 连接<br>提高网络性能优化，很重要的一点就是降低延迟和提升响应速度。</p>
</blockquote>
<p>通常我们在浏览器中发起请求的时候header部分往往是这样的<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/%E7%BD%91%E7%BB%9C/.1606911647216.png" alt="Alt text"><br>keep-alive 就是浏览器和服务端之间保持长连接，这个连接是可以复用的。在HTTP1.1中是默认开启的。<br>连接的复用为什么会提高性能呢？<br>通常我们在发起http请求的时候首先要完成tcp的三次握手，然后传输数据，最后再释放连接。三次握手的过程可以参考这里 TCP三次握手详解及释放连接过程</p>
<p>一次响应的过程<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/%E7%BD%91%E7%BB%9C/.1606911652273.png" alt="Alt text"><br>在高并发的请求连接情况下或者同个客户端多次频繁的请求操作，无限制的创建会导致性能低下。</p>
<p>如果使用keep-alive<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/%E7%BD%91%E7%BB%9C/.1606911657005.png" alt="Alt text"><br>在timeout空闲时间内，连接不会关闭，相同重复的request将复用原先的connection，减少握手的次数，大幅提高效率。<br>并非keep-alive的timeout设置时间越长，就越能提升性能。长久不关闭会造成过多的僵尸连接和泄露连接出现。<br>那么okttp在客户端是如果类似于客户端做到的keep-alive的机制。<br>##连接池的使用<br>连接池的类位于okhttp3.ConnectionPool。我们的主旨是了解到如何在timeout时间内复用connection，并且有效的对其进行回收清理操作。</p>
<p>其成员变量代码片</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Background threads are used to cleanup expired connections. There will be at most a single</span></span><br><span class="line"><span class="comment"> * thread running per connection pool. The thread pool executor permits the pool itself to be</span></span><br><span class="line"><span class="comment"> * garbage collected.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span> <span class="comment">/* corePoolSize */</span>,</span><br><span class="line">      Integer.MAX_VALUE <span class="comment">/* maximumPoolSize */</span>, <span class="number">60L</span> <span class="comment">/* keepAliveTime */</span>, TimeUnit.SECONDS,</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;(), Util.threadFactory(<span class="string">&quot;OkHttp ConnectionPool&quot;</span>, <span class="literal">true</span>));</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/** The maximum number of idle connections for each address. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maxIdleConnections;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealConnection&gt; connections = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">final</span> <span class="type">RouteDatabase</span> <span class="variable">routeDatabase</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RouteDatabase</span>();</span><br><span class="line">  <span class="type">boolean</span> cleanupRunning;</span><br></pre></td></tr></table></figure>
<p>excutor : 线程池，用来检测闲置socket并对其进行清理。<br>connections : connection缓存池。Deque是一个双端列表，支持在头尾插入元素，这里用作LIFO（后进先出）堆栈，多用于缓存数据。<br>routeDatabase ：用来记录连接失败router<br>缓存操作<br>ConnectionPool提供对Deque<RealConnection>进行操作的方法分别为put、get、connectionBecameIdle、evictAll几个操作。分别对应放入连接、获取连接、移除连接、移除所有连接操作。</p>
<p>put操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">put</span><span class="params">(RealConnection connection)</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> (Thread.holdsLock(<span class="built_in">this</span>));</span><br><span class="line">    <span class="keyword">if</span> (!cleanupRunning) &#123;</span><br><span class="line">      cleanupRunning = <span class="literal">true</span>;</span><br><span class="line">      executor.execute(cleanupRunnable);</span><br><span class="line">    &#125;</span><br><span class="line">    connections.add(connection);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在新的connection 放进列表之前执行清理闲置连接的线程。</p>
<p>既然是复用，那么看下他获取连接的方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Returns a recycled connection to &#123;<span class="doctag">@code</span> address&#125;, or null if no such connection exists. */</span></span><br><span class="line">RealConnection <span class="title function_">get</span><span class="params">(Address address, StreamAllocation streamAllocation)</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> (Thread.holdsLock(<span class="built_in">this</span>));</span><br><span class="line">    <span class="keyword">for</span> (RealConnection connection : connections) &#123;</span><br><span class="line">      <span class="keyword">if</span> (connection.allocations.size() &lt; connection.allocationLimit</span><br><span class="line">          &amp;&amp; address.equals(connection.route().address)</span><br><span class="line">          &amp;&amp; !connection.noNewStreams) &#123;</span><br><span class="line">        streamAllocation.acquire(connection);</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>遍历connections缓存列表，当某个连接计数的次数小于限制的大小以及request的地址和缓存列表中此连接的地址完全匹配。则直接复用缓存列表中的connection作为request的连接。</p>
<p>streamAllocation.allocations是个对象计数器，其本质是一个 List&lt;Reference<StreamAllocation>&gt; 存放在RealConnection连接对象中用于记录Connection的活跃情况。</p>
<p>连接池中Connection的缓存比较简单，就是利用一个双端列表，配合CRD等操作。那么connection在timeout时间类是如果失效的呢，并且如果做到有效的对连接进行清除操作以确保性能和内存空间的充足。</p>
<h3 id="连接池的清理和回收"><a href="#连接池的清理和回收" class="headerlink" title="连接池的清理和回收"></a>连接池的清理和回收</h3><p>在看ConnectionPool的成员变量的时候我们了解到一个Executor的线程池是用来清理闲置的连接的。注释中是这么解释的：</p>
<p>Background threads are used to cleanup expired connections</p>
<p>我们在put新连接到队列的时候会先执行清理闲置连接的线程。调用的正是 executor.execute(cleanupRunnable); 方法。观察cleanupRunnable</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">cleanupRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">waitNanos</span> <span class="operator">=</span> cleanup(System.nanoTime());</span><br><span class="line">        <span class="keyword">if</span> (waitNanos == -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (waitNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="type">long</span> <span class="variable">waitMillis</span> <span class="operator">=</span> waitNanos / <span class="number">1000000L</span>;</span><br><span class="line">          waitNanos -= (waitMillis * <span class="number">1000000L</span>);</span><br><span class="line">          <span class="keyword">synchronized</span> (ConnectionPool.<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              ConnectionPool.<span class="built_in">this</span>.wait(waitMillis, (<span class="type">int</span>) waitNanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>线程中不停调用Cleanup 清理的动作并立即返回下次清理的间隔时间。继而进入wait 等待之后释放锁，继续执行下一次的清理。所以可能理解成他是个监测时间并释放连接的后台线程。</p>
<p>了解cleanup动作的过程。这里就是如何清理所谓闲置连接的和行了。怎么找到闲置的连接是主要解决的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">cleanup</span><span class="params">(<span class="type">long</span> now)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">inUseConnectionCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">idleConnectionCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">RealConnection</span> <span class="variable">longestIdleConnection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">longestIdleDurationNs</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Find either a connection to evict, or the time that the next eviction is due.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">        <span class="type">RealConnection</span> <span class="variable">connection</span> <span class="operator">=</span> i.next();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// If the connection is in use, keep searching.</span></span><br><span class="line">        <span class="keyword">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          inUseConnectionCount++;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        idleConnectionCount++;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// If the connection is ready to be evicted, we&#x27;re done.</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">idleDurationNs</span> <span class="operator">=</span> now - connection.idleAtNanos;</span><br><span class="line">        <span class="keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;</span><br><span class="line">          longestIdleDurationNs = idleDurationNs;</span><br><span class="line">          longestIdleConnection = connection;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">if</span> (longestIdleDurationNs &gt;= <span class="built_in">this</span>.keepAliveDurationNs</span><br><span class="line">          || idleConnectionCount &gt; <span class="built_in">this</span>.maxIdleConnections) &#123;</span><br><span class="line">        <span class="comment">// We&#x27;ve found a connection to evict. Remove it from the list, then close it below (outside</span></span><br><span class="line">        <span class="comment">// of the synchronized block).</span></span><br><span class="line">        connections.remove(longestIdleConnection);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idleConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// A connection will be ready to evict soon.</span></span><br><span class="line">        <span class="keyword">return</span> keepAliveDurationNs - longestIdleDurationNs;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inUseConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// All connections are in use. It&#x27;ll be at least the keep alive duration &#x27;til we run again.</span></span><br><span class="line">        <span class="keyword">return</span> keepAliveDurationNs;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No connections, idle or in use.</span></span><br><span class="line">        cleanupRunning = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    closeQuietly(longestIdleConnection.socket());</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Cleanup again immediately.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在遍历缓存列表的过程中，使用连接数目inUseConnectionCount 和闲置连接数目idleConnectionCount 的计数累加值都是通过pruneAndGetAllocationCount() 是否大于0来控制的。那么很显然pruneAndGetAllocationCount() 方法就是用来识别对应连接是否闲置的。&gt;0则不闲置。否则就是闲置的连接。</p>
<p>进去观察</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">pruneAndGetAllocationCount</span><span class="params">(RealConnection connection, <span class="type">long</span> now)</span> &#123;</span><br><span class="line">    List&lt;Reference&lt;StreamAllocation&gt;&gt; references = connection.allocations;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; references.size(); ) &#123;</span><br><span class="line">      Reference&lt;StreamAllocation&gt; reference = references.get(i);</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">if</span> (reference.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// We&#x27;ve discovered a leaked allocation. This is an application bug.</span></span><br><span class="line">      Platform.get().log(WARN, <span class="string">&quot;A connection to &quot;</span> + connection.route().address().url()</span><br><span class="line">          + <span class="string">&quot; was leaked. Did you forget to close a response body?&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">      references.remove(i);</span><br><span class="line">      connection.noNewStreams = <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// If this was the last allocation, the connection is eligible for immediate eviction.</span></span><br><span class="line">      <span class="keyword">if</span> (references.isEmpty()) &#123;</span><br><span class="line">        connection.idleAtNanos = now - keepAliveDurationNs;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> references.size();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，原先存放在RealConnection 中的allocations 派上用场了。遍历StreamAllocation 弱引用链表，移除为空的引用，遍历结束后返回链表中弱引用的数量。所以可以看出List&lt;Reference<StreamAllocation>&gt; 就是一个记录connection活跃情况的 &gt;0表示活跃 &#x3D;0 表示空闲。StreamAllocation 在列表中的数量就是就是物理socket被引用的次数</p>
<p>解释：StreamAllocation被高层反复执行aquire与release。这两个函数在执行过程中其实是在一直在改变Connection中的 List&lt;WeakReference<StreamAllocation>&gt;大小。</p>
<p>搞定了查找闲置的connection操作，我们回到cleanup 的操作。计算了inUseConnectionCount和idleConnectionCount 之后程序又根据闲置时间对connection进行了一个选择排序，选择排序的核心是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the connection is ready to be evicted, we&#x27;re done.</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">idleDurationNs</span> <span class="operator">=</span> now - connection.idleAtNanos;</span><br><span class="line">        <span class="keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;</span><br><span class="line">          longestIdleDurationNs = idleDurationNs;</span><br><span class="line">          longestIdleConnection = connection;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure>
<p>通过对比最大闲置时间选择排序可以方便的查找出闲置时间最长的一个connection。如此一来我们就可以移除这个没用的connection了！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (longestIdleDurationNs &gt;= <span class="built_in">this</span>.keepAliveDurationNs</span><br><span class="line">          || idleConnectionCount &gt; <span class="built_in">this</span>.maxIdleConnections) &#123;</span><br><span class="line">        <span class="comment">// We&#x27;ve found a connection to evict. Remove it from the list, then close it below (outside</span></span><br><span class="line">        <span class="comment">// of the synchronized block).</span></span><br><span class="line">        connections.remove(longestIdleConnection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：清理闲置连接的核心主要是引用计数器List&lt;Reference<StreamAllocation>&gt; 和 选择排序的算法以及excutor的清理线程池。</p>
<h2 id="HTTP重定向"><a href="#HTTP重定向" class="headerlink" title="HTTP重定向"></a>HTTP重定向</h2><blockquote>
<p>重定向(Redirect)就是通过各种方法将各种网络请求重新定个方向转到其它位置（如：网页重定向、域名的重定向、路由选择的变化也是对数据报文经由路径的一种重定向）。 —-百度百科<br>在 HTTP 协议中，重定向操作由服务器通过发送特殊的响应（即 redirects）而触发。HTTP 协议的重定向响应的状态码为 3xx 。浏览器在接收到重定向响应的时候，会采用该响应提供的新的 URL ，并立即进行加载；大多数情况下，除了会有一小部分性能损失之外，重定向操作对于用户来说是不可见的。<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/%E7%BD%91%E7%BB%9C/.1606914975148.png" alt="Alt text"><br>不同类型的重定向映射可以划分为三个类别：永久重定向、临时重定向和特殊重定向。</p>
</blockquote>
<h3 id="永久重定向"><a href="#永久重定向" class="headerlink" title="永久重定向"></a>永久重定向</h3><p>这种重定向操作是永久性的。它表示原 URL 不应再被使用，而应该优先选用新的 URL。搜索引擎机器人会在遇到该状态码时触发更新操作，在其索引库中修改与该资源相关的 URL 。<br>注意了：浏览器自动重定向，不管代码怎么写都会自动重定向到第一次你永久重定向的URL，没办法，这时候你只能清楚浏览器缓存</p>
<table>
<thead>
<tr>
<th align="center">编码</th>
<th align="center">含义</th>
<th align="center">处理方法</th>
<th align="center">典型应用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">301</td>
<td align="center">Moved Permanently</td>
<td align="center">GET 方法不会发生变更，其他方法有可能会变更为 GET 方法。</td>
<td align="center">网站重构。</td>
</tr>
<tr>
<td align="center">308</td>
<td align="center">Permanent Redirect</td>
<td align="center">方法和消息主体都不发生变化。</td>
<td align="center">网站重构。with non-GET links&#x2F;operations(?)</td>
</tr>
</tbody></table>
<h3 id="临时重定向"><a href="#临时重定向" class="headerlink" title="临时重定向"></a>临时重定向</h3><p>有时候请求的资源无法从其标准地址访问，但是却可以从另外的地方访问。在这种情况下可以使用临时重定向。搜索引擎不会记录该新的、临时的链接。在创建、更新或者删除资源的时候，临时重定向也可以用于显示临时性的进度页面。<br>那么临时重定向就是解决自己傻乎乎的用永久重定向的问题。</p>
<table>
<thead>
<tr>
<th align="center">编码</th>
<th align="center">含义</th>
<th align="center">处理方法</th>
<th align="center">典型应用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">302</td>
<td align="center">Found</td>
<td align="center">GET 方法不会发生变更，其他方法有可能会变更为 GET 方法。</td>
<td align="center">由于不可预见的原因该页面暂不可用。在这种情况下，搜索引擎不会更新它们的链接。</td>
</tr>
<tr>
<td align="center">303</td>
<td align="center">See Other</td>
<td align="center">GET 方法不会发生变更，其他方法会变更为 GET 方法（消息主体会丢失）。</td>
<td align="center">用于PUT 或 POST 请求完成之后进行页面跳转来防止由于页面刷新导致的操作的重复触发。</td>
</tr>
<tr>
<td align="center">307</td>
<td align="center">Temporary</td>
<td align="center">Redirect	方法和消息主体都不发生变化。</td>
<td align="center">由于不可预见的原因该页面暂不可用。在这种情况下，搜索引擎不会更新它们的链接。当站点支持非 GET 方法的链接或操作的时候，该状态码优于 302 状态码。</td>
</tr>
</tbody></table>
<h3 id="特殊重定向"><a href="#特殊重定向" class="headerlink" title="特殊重定向"></a>特殊重定向</h3><p>除了上述两种常见的重定向之外，还有两种特殊的重定向。304 （Not Modified，资源未被修改）会使页面跳转到本地缓存的版本当中（该缓存已过期(?)），而 300 （Multiple Choice，多项选择） 则是一种手工重定向：以 Web 页面形式呈现在浏览器中的消息主体包含了一个可能的重定向链接的列表，用户可以从中进行选择。</p>
<table>
<thead>
<tr>
<th align="center">编码</th>
<th align="center">含义</th>
<th align="center">典型应用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">300</td>
<td align="center">Multiple Choice</td>
<td align="center">不会太多：所有的选项在消息主体的 HTML 页面中列出。也可以返回 200 OK 状态码。</td>
</tr>
<tr>
<td align="center">304</td>
<td align="center">Not Modified</td>
<td align="center">缓存刷新：该状态码表示缓存值依然有效，可以使用。</td>
</tr>
</tbody></table>
<h2 id="缓存处理"><a href="#缓存处理" class="headerlink" title="缓存处理"></a>缓存处理</h2><h3 id="缓存的优势"><a href="#缓存的优势" class="headerlink" title="缓存的优势"></a>缓存的优势</h3><p>缓存的使用场景很多，通过它可以将数据通过一定的规则存储起来，再次请求数据的时候就可以快速从缓存中读取了，缓存有以下优势。</p>
<ul>
<li>减少向服务器请求的次数，减轻服务器的负载。</li>
<li>加快了本地的响应速度，直接从缓存中取数据比从网络读取要快很多。</li>
<li>提供无网模式下的浏览体验，没有网络的情况下也能显示内容。</li>
</ul>
<h3 id="HTTP的缓存机制"><a href="#HTTP的缓存机制" class="headerlink" title="HTTP的缓存机制"></a>HTTP的缓存机制</h3><p>HTTP本身提供了一套缓存相关的机制。这套机制定义了相关的字段和规则，用来客户端和服务端进行缓存相关的协商，如响应的数据是否需要缓存，缓存有效期，缓存是否有效，服务器端给出指示，而客户端则根据服务端的指示做具体的缓存更新和读取缓存工作。http缓存可以分为两类：</p>
<h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><p>强制缓存，是直接向缓存数据库请求数据，如果找到了对应的缓存数据，并且是有效的，就直接返回缓存数据。如果没有找到或失效了，则向服务器请求数据，返回数据和缓存规则，同时将数据和缓存规则保存到缓存数据库中。</p>
<h4 id="对比缓存"><a href="#对比缓存" class="headerlink" title="对比缓存"></a>对比缓存</h4><p>对比缓存，是先向缓存数据库获取缓存数据的标识，然后用该标识去服务器请求该标识对应的数据是否失效，如果没有失效，服务器会返回304未失效响应，则客户端使用该标识对应的缓存。如果失效了，服务器会返回最新的数据和缓存规则，客户端使用返回的最新数据，同时将数据和缓存规则保存到缓存数据库中。</p>
<p>强制缓存<br>强制缓存，在缓存数据未失效的情况下，可以直接使用缓存数据，有两个字段Expires和Cache-Control用于标明失效规则。</p>
<h5 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h5><p>表示过期时间，由服务端返回。那么下次请求数据时，判断这个Expires过期时间是否已经过了，如果还没有到过期时间，则使用缓存，如果过了过期时间，则重新请求服务器的数据。Expires格式如下：</p>
<ul>
<li>Expires: Sat, 11 Nov 2017 10:30:01 GMT<blockquote>
<p>表示到期时间是2017年11月11日10点30分，在这个时间之前可以使用缓存，过了这个时间就要重新请求服务器数据了。</p>
</blockquote>
</li>
</ul>
<p>不过因为服务器和客户端的时间并不是同步的，用一个绝对时间作为过期的标记并不是很明智，所以HTTP1.1之后更多的是Cache-Control，它的控制更加灵活。</p>
<h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h5><p>表示缓存的控制，有服务端返回。它有以下几个取值：</p>
<ul>
<li>public表示数据内容都可以被储存起来，就连有密码保护的网页也储存，安全性很低</li>
<li>private表示数据内容只能被储存到私有的cache，仅对某个用户有效，不能共享</li>
<li>no-cache表示可以缓存，但是只有在跟WEB服务器验证了其有效后，才能返回给客户端，触发对比缓存</li>
<li>no-store表示请求和响应都禁止被缓存，强制缓存，对比缓存都不会触发</li>
<li>max-age表示返回数据的过期时间</li>
</ul>
<p>默认情况下是private，也就是不能共享的。Cache-Control格式如下：</p>
<ul>
<li>Cache-Control:public, max-age&#x3D;31536000<blockquote>
<p>表示可以被公共缓存，有效时间是1年，也就是说一年时间内，请求该数据时，直接使用缓存，而不用请求服务器了。</p>
</blockquote>
</li>
</ul>
<p>对比缓存<br>对比缓存，表示需要和服务端进行相关信息的对比，由服务器决定是使用缓存还是最新内容，如果服务器判定使用缓存，返回响应吗304，判定使用最新内容，则返回响应码200和最新数据。对比缓存的判定字段有两组：</p>
<h5 id="ETag和If-None-Match"><a href="#ETag和If-None-Match" class="headerlink" title="ETag和If-None-Match"></a>ETag和If-None-Match</h5><p>ETag表示资源的一种标识信息，用于标识某个资源，由服务端返回，优先级更高。格式如下：</p>
<ul>
<li>Etag:”AFY10-6MddXmSerSiXP1ZTiU65VS”<blockquote>
<p>表示该资源的标识是AFY10-6MddXmSerSiXP1ZTiU65VS<br>然后客户端再次请求时，加入字段If-None-Match，格式如下：</p>
</blockquote>
</li>
<li>If-None-Match:”AFY10-6MddXmSerSiXP1ZTiU65VS”<blockquote>
<p>服务端收到请求的该字段时（之前的Etag值），和资源的唯一标识进行对比，如果相同，说明没有改动，则返回状态码304，如果不同，说明资源被改过了，则返回状态码200和整个内容数据。</p>
</blockquote>
</li>
</ul>
<h5 id="Last-Modified和If-Modified-Since"><a href="#Last-Modified和If-Modified-Since" class="headerlink" title="Last-Modified和If-Modified-Since"></a>Last-Modified和If-Modified-Since</h5><p>Last-Modified表示资源的最近修改时间，由服务端返回，优先级更低。格式如下：</p>
<ul>
<li>Last-Modified: Sat, 11 Nov 2017 10:30:01 GMT<blockquote>
<p>表示上次修改时间是2017年11月11日10点30分。</p>
</blockquote>
</li>
<li>If-Modified-Since: Sat, 11 Nov 2017 10:30:01 GMT<blockquote>
<p>客户端请求，表示我指定的这个2017年11月11日10点30分是不是你服务器最新的修改时间。</p>
</blockquote>
</li>
</ul>
<p>Last-Modified<br>由服务器返回，表示响应的数据最近修改的时间。</p>
<p>If-Modified-Since<br>由客户端请求，表示询问服务器这个时间是不是上次修改的时间。如果服务端该资源的修改时间小于等于If-Modified-Since指定的时间，说明资源没有改动，返回响应状态码304，可以使用缓存。如果服务端该资源的修改时间大于If-Modified-Since指定的时间，说明资源又有改动了，则返回响应状态码200和最新数据给客户端，客户端使用响应返回的最新数据。</p>
<p>Last-Modified字段的值（服务端返回的资源上次修改时间），常常被用于客户端下次请求时的If-Modified-Since字段中。</p>
<h4 id="两种缓存的区别"><a href="#两种缓存的区别" class="headerlink" title="两种缓存的区别"></a>两种缓存的区别</h4><p>强制缓存的情况下，如果缓存是有效的，则直接使用缓存，而对比缓存不管缓存是否有效，都需要先去和服务器对比是否有新的数据，没有新的数据才使用缓存数据。</p>
<h4 id="两种缓存的使用情景"><a href="#两种缓存的使用情景" class="headerlink" title="两种缓存的使用情景"></a>两种缓存的使用情景</h4><p>对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行对比缓存策略。</p>
<p>对于对比缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。</p>
<h4 id="HTTP的缓存规则总结"><a href="#HTTP的缓存规则总结" class="headerlink" title="HTTP的缓存规则总结"></a>HTTP的缓存规则总结</h4><p>HTTP的缓存规则是优先考虑强制缓存，然后考虑对比缓存。</p>
<ul>
<li>首先判断强制缓存中的数据的是否在有效期内。如果在有效期，则直接使用缓存。如果过了有效期，则进入对比缓存。</li>
<li>在对比缓存过程中，判断ETag是否有变动，如果服务端返回没有变动，说明资源未改变，使用缓存。如果有变动，判断Last-Modified。</li>
<li>判断Last-Modified，如果服务端对比资源的上次修改时间没有变化，则使用缓存，否则重新请求服务端的数据，并作缓存工作。<br> <img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/%E7%BD%91%E7%BB%9C/.1606915768972.png" alt="Alt text"></li>
</ul>
<h2 id="Okhttp缓存相关类"><a href="#Okhttp缓存相关类" class="headerlink" title="Okhttp缓存相关类"></a>Okhttp缓存相关类</h2><p>Okhttp缓存相关的类有如下：</p>
<h3 id="CacheControl（HTTP中的Cache-Control和Pragma缓存控制）"><a href="#CacheControl（HTTP中的Cache-Control和Pragma缓存控制）" class="headerlink" title="CacheControl（HTTP中的Cache-Control和Pragma缓存控制）"></a>CacheControl（HTTP中的Cache-Control和Pragma缓存控制）</h3><p>CacheControl是用于描述HTTP的Cache-Control和Pragma字段的类，用于指定缓存的规则。</p>
<h3 id="CacheStrategy（缓存策略类）"><a href="#CacheStrategy（缓存策略类）" class="headerlink" title="CacheStrategy（缓存策略类）"></a>CacheStrategy（缓存策略类）</h3><p>CacheStrategy是用于判定使用缓存数据还是网络请求的决策类。</p>
<h3 id="Cache（缓存类）"><a href="#Cache（缓存类）" class="headerlink" title="Cache（缓存类）"></a>Cache（缓存类）</h3><p>对外开放的缓存类，提供了缓存的增删改查接口。</p>
<h3 id="InternalCache（内部缓存类）"><a href="#InternalCache（内部缓存类）" class="headerlink" title="InternalCache（内部缓存类）"></a>InternalCache（内部缓存类）</h3><p>对内使用的缓存类接口，没有具体实现，只是封装了Cache的使用。</p>
<h3 id="DiskLruCache（文件化的LRU缓存类）"><a href="#DiskLruCache（文件化的LRU缓存类）" class="headerlink" title="DiskLruCache（文件化的LRU缓存类）"></a>DiskLruCache（文件化的LRU缓存类）</h3><p>这是真正实现缓存功能的类，将数据存储在文件中，并使用LRU规则（由LinkedHashMap实现），控制对缓存文件的增删改查。</p>
<h2 id="Okhttp缓存的启用"><a href="#Okhttp缓存的启用" class="headerlink" title="Okhttp缓存的启用"></a>Okhttp缓存的启用</h2><p>要开启使用Okhttp的缓存其实很简单，只需要给OkHttpClient对象设置一个Cache对象即可，创建一个Cache时指定缓存保存的目录和缓存最大的大小即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新建一个cache，指定目录为外部目录下的okhttp_cache目录，大小为100M</span></span><br><span class="line"><span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cache</span>(<span class="keyword">new</span> <span class="title class_">File</span>(Environment.getExternalStorageDirectory() + <span class="string">&quot;/okhttp_cache/&quot;</span>), <span class="number">100</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">将cache设置到OkHttpClient中，这样缓存就开始生效了。</span><br><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder().cache(cache).build();</span><br></pre></td></tr></table></figure>
<h2 id="Okhttp的缓存流程"><a href="#Okhttp的缓存流程" class="headerlink" title="Okhttp的缓存流程"></a>Okhttp的缓存流程</h2><p>Okhttp的缓存流程分为读取缓存和存储缓存两个过程，我们分别分析。</p>
<h3 id="Okhttp读取缓存流程"><a href="#Okhttp读取缓存流程" class="headerlink" title="Okhttp读取缓存流程"></a>Okhttp读取缓存流程</h3><p>读取使用缓存的流程从HttpEngine的sendRequest发送请求开始。</p>
<ol>
<li>首先获取OkHttpClient的Cache缓存对象，就是之前创建OkHttpClient时设置的Cache。</li>
<li>然后传入Request请求到Cache的get方法去查找缓存响应数据Response。</li>
<li>构造一个缓存策略，传入Request请求和缓存响应Response，然后调用它的get方法去决策使用网络请求还是缓存响应。</li>
<li>策略判定之后，如果是使用缓存，则它的cacheResponse不为空，networkRequest为空，如果使用请求，则相反。然后再将策略给出的这两个值，继续处理。</li>
<li>如果使用请求，但是之前又找到了缓存响应，则要关闭缓存响应资源。</li>
<li>如果策略得出缓存响应为空，网络请求也为空，则返回请求不合理的响应。（比如强制使用缓存，但是找不到缓存的情况下）</li>
<li>如果请求为空，缓存不为空，也就是使用缓存的情况，则使用缓存响应来构造返回的响应数据。</li>
<li>最后就是只使用网络请求的情况，走网络请求路线。<br>总的来说就是，先查找是否有可用的Cache，然后通过Cache找到请求对应的缓存，然后将请求和缓存交给缓存策略去判断使用请求还是缓存，得出结果后，自己再判断使用缓存还是请求，如果使用缓存，用缓存构造响应直接返回，如果使用请求，那么开始网络请求流程。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HttpEngine</span> &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//发送请求</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendRequest</span><span class="params">()</span> <span class="keyword">throws</span> RequestException, RouteException, IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (cacheStrategy != <span class="literal">null</span>) <span class="keyword">return</span>; <span class="comment">// Already sent.</span></span><br><span class="line">    <span class="keyword">if</span> (httpStream != <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">    <span class="comment">//根据用户请求得到实际的网络请求</span></span><br><span class="line">    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> networkRequest(userRequest);</span><br><span class="line">    <span class="comment">//这里InternalCache就是对Cache的封装，它的实现在Cache的internalCache中。</span></span><br><span class="line">    <span class="type">InternalCache</span> <span class="variable">responseCache</span> <span class="operator">=</span> Internal.instance.internalCache(client);</span><br><span class="line">    <span class="comment">//通过Cache的get方法查找缓存响应</span></span><br><span class="line">    <span class="type">Response</span> <span class="variable">cacheCandidate</span> <span class="operator">=</span> responseCache != <span class="literal">null</span></span><br><span class="line">        ? responseCache.get(request)</span><br><span class="line">        : <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//构造缓存策略，然后进行策略判断</span></span><br><span class="line">    cacheStrategy = <span class="keyword">new</span> <span class="title class_">CacheStrategy</span>.Factory(now, request, cacheCandidate).get();</span><br><span class="line">    <span class="comment">//策略判定后的网络请求和缓存响应</span></span><br><span class="line">    networkRequest = cacheStrategy.networkRequest;</span><br><span class="line">    cacheResponse = cacheStrategy.cacheResponse;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (responseCache != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//使用缓存响应的话，记录一下使用记录</span></span><br><span class="line">      responseCache.trackResponse(cacheStrategy);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (cacheCandidate != <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//使用网络请求，但是之前又有缓存的话，要关闭缓存，释放资源</span></span><br><span class="line">      closeQuietly(cacheCandidate.body()); <span class="comment">// The cache candidate wasn&#x27;t applicable. Close it.</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// If we&#x27;re forbidden from using the network and the cache is insufficient, fail.</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//强制使用缓存，又找不到缓存，就报不合理请求响应了</span></span><br><span class="line">      userResponse = <span class="keyword">new</span> <span class="title class_">Response</span>.Builder()</span><br><span class="line">          .request(userRequest)</span><br><span class="line">          .priorResponse(stripBody(priorResponse))</span><br><span class="line">          .protocol(Protocol.HTTP_1_1)</span><br><span class="line">          .code(<span class="number">504</span>)</span><br><span class="line">          .message(<span class="string">&quot;Unsatisfiable Request (only-if-cached)&quot;</span>)</span><br><span class="line">          .body(EMPTY_BODY)</span><br><span class="line">          .build();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//上面情况处理之后，就是使用缓存返回，还是网络请求的情况了</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// If we don&#x27;t need the network, we&#x27;re done.</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//使用缓存返回响应</span></span><br><span class="line">      userResponse = cacheResponse.newBuilder()</span><br><span class="line">          .request(userRequest)</span><br><span class="line">          .priorResponse(stripBody(priorResponse))</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .build();</span><br><span class="line">      userResponse = unzip(userResponse);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//使用网络请求</span></span><br><span class="line">    <span class="comment">//下面就是网络请求流程了，略</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Cache获取缓存"><a href="#Cache获取缓存" class="headerlink" title="Cache获取缓存"></a>Cache获取缓存</h3><p>从Cache的get方法开始。它按以下步骤进行。</p>
<ol>
<li>计算request对应的key值，md5加密请求url得到。</li>
<li>根据key值去DiskLruCache查找是否存在缓存内容。</li>
<li>存在缓存的话，创建缓存Entry实体。ENTRY_METADATA代表响应头信息，ENTRY_BODY代表响应体信息。</li>
<li>然后根据缓存Entry实体得到响应，其中包含了缓存的响应头和响应体信息。</li>
<li>匹配这个缓存响应和请求的信息是否匹配，不匹配的话要关闭资源，匹配的话返回。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Cache</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span>, Flushable &#123;</span><br><span class="line">  <span class="comment">//获取缓存</span></span><br><span class="line">  Response <span class="title function_">get</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">    <span class="comment">//计算请求对应的key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> urlToKey(request);</span><br><span class="line">    DiskLruCache.Snapshot snapshot;</span><br><span class="line">    Entry entry;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//这里从DiskLruCache中读取缓存信息</span></span><br><span class="line">      snapshot = cache.get(key);</span><br><span class="line">      <span class="keyword">if</span> (snapshot == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="comment">// Give up because the cache cannot be read.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//这里读取缓存的响应头信息</span></span><br><span class="line">      entry = <span class="keyword">new</span> <span class="title class_">Entry</span>(snapshot.getSource(ENTRY_METADATA));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      Util.closeQuietly(snapshot);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//然后得到响应信息，包含了缓存响应头和响应体信息</span></span><br><span class="line">    <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> entry.response(snapshot);</span><br><span class="line">    <span class="comment">//判断缓存响应和请求是否匹配，匹配url,method,和其他响应头信息</span></span><br><span class="line">    <span class="keyword">if</span> (!entry.matches(request, response)) &#123;</span><br><span class="line">      <span class="comment">//不匹配的话，关闭响应体</span></span><br><span class="line">      Util.closeQuietly(response.body());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//返回缓存响应</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//这里md5加密url得到key值</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">urlToKey</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Util.md5Hex(request.url().toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>如果存在缓存的话，在指定的缓存目录中，会有两个文件“****.0”和“****.1”，分别存储某个请求缓存的响应头和响应体信息。（“****”是url的md5加密值）对应的ENTRY_METADATA响应头和ENTRY_BODY响应体。缓存的读取其实是由DiskLruCache来读取的，DiskLruCache是支持Lru（最近最少访问）规则的用于磁盘存储的类，对应LruCache内存存储。它在存储的内容超过指定值之后，就会根据最近最少访问的规则，把最近最少访问的数据移除，以达到总大小不超过限制的目的。</p>
<p>接下来我们分析CacheStrategy缓存策略是怎么判定的。</p>
<h3 id="CacheStrategy缓存策略"><a href="#CacheStrategy缓存策略" class="headerlink" title="CacheStrategy缓存策略"></a>CacheStrategy缓存策略</h3><p>直接看CacheStrategy的get方法。缓存策略是由请求和缓存响应共同决定的。</p>
<ul>
<li>如果缓存响应为空，则缓存策略为不使用缓存。</li>
<li>如果请求是https但是缓存响应没有握手信息，同上不使用缓存。</li>
<li>如果请求和缓存响应都是不可缓存的，同上不使用缓存。</li>
<li>如果请求是noCache，并且又包含If-Modified-Since或If-None-Match，同上不使用缓存。</li>
<li>然后计算请求有效时间是否符合响应的过期时间，如果响应在有效范围内，则缓存策略使用缓存。</li>
<li>否则创建一个新的有条件的请求，返回有条件的缓存策略。</li>
<li>如果判定的缓存策略的网络请求不为空，但是只使用缓存，则返回两者都为空的缓存策略。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CacheStrategy</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Factory</span><span class="params">(<span class="type">long</span> nowMillis, Request request, Response cacheResponse)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.nowMillis = nowMillis;</span><br><span class="line">      <span class="comment">//网络请求和缓存响应</span></span><br><span class="line">      <span class="built_in">this</span>.request = request;</span><br><span class="line">      <span class="built_in">this</span>.cacheResponse = cacheResponse;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//找到缓存响应的响应头信息</span></span><br><span class="line">        <span class="type">Headers</span> <span class="variable">headers</span> <span class="operator">=</span> cacheResponse.headers();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, size = headers.size(); i &lt; size; i++) &#123;</span><br><span class="line">          <span class="comment">//查看响应头信息中是否有以下字段信息</span></span><br><span class="line">          <span class="type">String</span> <span class="variable">fieldName</span> <span class="operator">=</span> headers.name(i);</span><br><span class="line">          <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> headers.value(i);</span><br><span class="line">          <span class="keyword">if</span> (<span class="string">&quot;Date&quot;</span>.equalsIgnoreCase(fieldName)) &#123;</span><br><span class="line">            servedDate = HttpDate.parse(value);</span><br><span class="line">            servedDateString = value;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;Expires&quot;</span>.equalsIgnoreCase(fieldName)) &#123;</span><br><span class="line">            expires = HttpDate.parse(value);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;Last-Modified&quot;</span>.equalsIgnoreCase(fieldName)) &#123;</span><br><span class="line">            lastModified = HttpDate.parse(value);</span><br><span class="line">            lastModifiedString = value;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;ETag&quot;</span>.equalsIgnoreCase(fieldName)) &#123;</span><br><span class="line">            etag = value;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;Age&quot;</span>.equalsIgnoreCase(fieldName)) &#123;</span><br><span class="line">            ageSeconds = HeaderParser.parseSeconds(value, -<span class="number">1</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (OkHeaders.SENT_MILLIS.equalsIgnoreCase(fieldName)) &#123;</span><br><span class="line">            sentRequestMillis = Long.parseLong(value);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (OkHeaders.RECEIVED_MILLIS.equalsIgnoreCase(fieldName)) &#123;</span><br><span class="line">            receivedResponseMillis = Long.parseLong(value);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> CacheStrategy <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//获取判定的缓存策略</span></span><br><span class="line">      <span class="type">CacheStrategy</span> <span class="variable">candidate</span> <span class="operator">=</span> getCandidate();</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">if</span> (candidate.networkRequest != <span class="literal">null</span> &amp;&amp; request.cacheControl().onlyIfCached()) &#123;</span><br><span class="line">        <span class="comment">// 如果判定的缓存策略的网络请求不为空，但是只使用缓存，则返回两者都为空的缓存策略。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CacheStrategy</span>(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** Returns a strategy to use assuming the request can use the network. */</span></span><br><span class="line">    <span class="keyword">private</span> CacheStrategy <span class="title function_">getCandidate</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// No cached response.</span></span><br><span class="line">      <span class="comment">//如果没有缓存响应，则返回没有缓存响应的策略</span></span><br><span class="line">      <span class="keyword">if</span> (cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CacheStrategy</span>(request, <span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// Drop the cached response if it&#x27;s missing a required handshake.</span></span><br><span class="line">      <span class="comment">//如果请求是https，而缓存响应的握手信息为空，则返回没有缓存响应的策略</span></span><br><span class="line">      <span class="keyword">if</span> (request.isHttps() &amp;&amp; cacheResponse.handshake() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CacheStrategy</span>(request, <span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// If this response shouldn&#x27;t have been stored, it should never be used</span></span><br><span class="line">      <span class="comment">// as a response source. This check should be redundant as long as the</span></span><br><span class="line">      <span class="comment">// persistence store is well-behaved and the rules are constant.</span></span><br><span class="line">      <span class="comment">//如果请求对应的响应不能被缓存，则返回没有缓存响应的策略</span></span><br><span class="line">      <span class="keyword">if</span> (!isCacheable(cacheResponse, request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CacheStrategy</span>(request, <span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取请求头中的CacheControl信息</span></span><br><span class="line">      <span class="type">CacheControl</span> <span class="variable">requestCaching</span> <span class="operator">=</span> request.cacheControl();</span><br><span class="line">      <span class="comment">//如果请求头中的CacheControl信息是不缓存的，则返回没有缓存响应的策略</span></span><br><span class="line">      <span class="keyword">if</span> (requestCaching.noCache() || hasConditions(request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CacheStrategy</span>(request, <span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取响应的年龄</span></span><br><span class="line">      <span class="type">long</span> <span class="variable">ageMillis</span> <span class="operator">=</span> cacheResponseAge();</span><br><span class="line">      <span class="comment">//计算上次响应刷新的时间</span></span><br><span class="line">      <span class="type">long</span> <span class="variable">freshMillis</span> <span class="operator">=</span> computeFreshnessLifetime();</span><br><span class="line">      <span class="comment">//如果请求里有最大持续时间要求，则取较小的值作为上次响应的刷新时间</span></span><br><span class="line">      <span class="keyword">if</span> (requestCaching.maxAgeSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//如果请求里有最短刷新时间要求，则用它来作为最短刷新时间</span></span><br><span class="line">      <span class="type">long</span> <span class="variable">minFreshMillis</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (requestCaching.minFreshSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//最大过期时间</span></span><br><span class="line">      <span class="type">long</span> <span class="variable">maxStaleMillis</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//获取缓存响应头中的CacheControl信息</span></span><br><span class="line">      <span class="type">CacheControl</span> <span class="variable">responseCaching</span> <span class="operator">=</span> cacheResponse.cacheControl();</span><br><span class="line">      <span class="comment">//如果缓存响应不是必须要再验证，并且请求有最大过期时间，则用请求的最大过期时间作为最大过期时间</span></span><br><span class="line">      <span class="keyword">if</span> (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//如果支持缓存，并且持续时间+最短刷新时间&lt;上次刷新时间+最大验证时间 则可以缓存</span></span><br><span class="line">      <span class="keyword">if</span> (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;</span><br><span class="line">        Response.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> cacheResponse.newBuilder();</span><br><span class="line">        <span class="keyword">if</span> (ageMillis + minFreshMillis &gt;= freshMillis) &#123;</span><br><span class="line">          builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;110 HttpURLConnection \&quot;Response is stale\&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">oneDayMillis</span> <span class="operator">=</span> <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>;</span><br><span class="line">        <span class="keyword">if</span> (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;</span><br><span class="line">          builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;113 HttpURLConnection \&quot;Heuristic expiration\&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回响应缓存</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CacheStrategy</span>(<span class="literal">null</span>, builder.build());</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//构造一个新的有条件的Request，添加If-None-Match，If-Modified-Since等信息</span></span><br><span class="line">      Request.<span class="type">Builder</span> <span class="variable">conditionalRequestBuilder</span> <span class="operator">=</span> request.newBuilder();</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">if</span> (etag != <span class="literal">null</span>) &#123;</span><br><span class="line">        conditionalRequestBuilder.header(<span class="string">&quot;If-None-Match&quot;</span>, etag);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastModified != <span class="literal">null</span>) &#123;</span><br><span class="line">        conditionalRequestBuilder.header(<span class="string">&quot;If-Modified-Since&quot;</span>, lastModifiedString);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (servedDate != <span class="literal">null</span>) &#123;</span><br><span class="line">        conditionalRequestBuilder.header(<span class="string">&quot;If-Modified-Since&quot;</span>, servedDateString);</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="type">Request</span> <span class="variable">conditionalRequest</span> <span class="operator">=</span> conditionalRequestBuilder.build();</span><br><span class="line">      <span class="comment">//根据是否有If-None-Match，If-Modified-Since信息，返回不同的缓存策略</span></span><br><span class="line">      <span class="keyword">return</span> hasConditions(conditionalRequest)</span><br><span class="line">          ? <span class="keyword">new</span> <span class="title class_">CacheStrategy</span>(conditionalRequest, cacheResponse)</span><br><span class="line">          : <span class="keyword">new</span> <span class="title class_">CacheStrategy</span>(conditionalRequest, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns true if the request contains conditions that save the server from sending a response</span></span><br><span class="line"><span class="comment">     * that the client has locally. When a request is enqueued with its own conditions, the built-in</span></span><br><span class="line"><span class="comment">     * response cache won&#x27;t be used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">hasConditions</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> request.header(<span class="string">&quot;If-Modified-Since&quot;</span>) != <span class="literal">null</span> || request.header(<span class="string">&quot;If-None-Match&quot;</span>) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="CacheControl"><a href="#CacheControl" class="headerlink" title="CacheControl"></a>CacheControl</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CacheControl</span> &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//表示这是一个优先使用网络验证，验证通过之后才可以使用缓存的缓存控制，设置了noCache</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">CacheControl</span> <span class="variable">FORCE_NETWORK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Builder</span>().noCache().build();</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//表示这是一个优先先使用缓存的缓存控制，设置了onlyIfCached和maxStale的最大值</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">CacheControl</span> <span class="variable">FORCE_CACHE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Builder</span>()</span><br><span class="line">      .onlyIfCached()</span><br><span class="line">      .maxStale(Integer.MAX_VALUE, TimeUnit.SECONDS)</span><br><span class="line">      .build();</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//以下的字段都是HTTP中Cache-Control字段相关的值</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> noCache;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> noStore;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maxAgeSeconds;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> sMaxAgeSeconds;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> isPrivate;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> isPublic;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> mustRevalidate;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maxStaleSeconds;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> minFreshSeconds;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> onlyIfCached;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> noTransform;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//解析头文件中的相关字段，得到该缓存控制类</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> CacheControl <span class="title function_">parse</span><span class="params">(Headers headers)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>可以发现，它就是用于描述响应的缓存控制信息。</p>
<p>然后我们再看看Okhttp存储缓存是怎么进行的。</p>
<h3 id="Okhttp存储缓存流程"><a href="#Okhttp存储缓存流程" class="headerlink" title="Okhttp存储缓存流程"></a>Okhttp存储缓存流程</h3><p>存储缓存的流程从HttpEngine的readResponse发送请求开始的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HttpEngine</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Flushes the remaining request header and body, parses the HTTP response headers and starts</span></span><br><span class="line"><span class="comment">   * reading the HTTP response body if it exists.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readResponse</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//读取响应，略</span></span><br><span class="line">    ...</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 判断响应信息中包含响应体</span></span><br><span class="line">    <span class="keyword">if</span> (hasBody(userResponse)) &#123;</span><br><span class="line">      <span class="comment">// 如果缓存的话，缓存响应头信息</span></span><br><span class="line">      maybeCache();</span><br><span class="line">      <span class="comment">//缓存响应体信息，同时zip解压缩响应数据</span></span><br><span class="line">      userResponse = unzip(cacheWritingResponse(storeRequest, userResponse));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 如果缓存的话，缓存响应头信息</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">maybeCache</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">InternalCache</span> <span class="variable">responseCache</span> <span class="operator">=</span> Internal.instance.internalCache(client);</span><br><span class="line">    <span class="keyword">if</span> (responseCache == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Should we cache this response for this request?</span></span><br><span class="line">    <span class="keyword">if</span> (!CacheStrategy.isCacheable(userResponse, networkRequest)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          responseCache.remove(networkRequest);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">          <span class="comment">// The cache cannot be written.</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Offer this request to the cache.</span></span><br><span class="line">    <span class="comment">//这里将响应头信息缓存到缓存文件中，对应缓存文件“\*\*\*\*.0”</span></span><br><span class="line">    storeRequest = responseCache.put(stripBody(userResponse));</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns a new source that writes bytes to &#123;<span class="doctag">@code</span> cacheRequest&#125; as they are read by the source</span></span><br><span class="line"><span class="comment">   * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we</span></span><br><span class="line"><span class="comment">   * may never exhaust the source stream and therefore not complete the cached response.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">//缓存响应体信息</span></span><br><span class="line">  <span class="keyword">private</span> Response <span class="title function_">cacheWritingResponse</span><span class="params">(<span class="keyword">final</span> CacheRequest cacheRequest, Response response)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// Some apps return a null body; for compatibility we treat that like a null cache request.</span></span><br><span class="line">    <span class="keyword">if</span> (cacheRequest == <span class="literal">null</span>) <span class="keyword">return</span> response;</span><br><span class="line">    <span class="type">Sink</span> <span class="variable">cacheBodyUnbuffered</span> <span class="operator">=</span> cacheRequest.body();</span><br><span class="line">    <span class="keyword">if</span> (cacheBodyUnbuffered == <span class="literal">null</span>) <span class="keyword">return</span> response;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">final</span> <span class="type">BufferedSource</span> <span class="variable">source</span> <span class="operator">=</span> response.body().source();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">BufferedSink</span> <span class="variable">cacheBody</span> <span class="operator">=</span> Okio.buffer(cacheBodyUnbuffered);</span><br><span class="line"> </span><br><span class="line">    <span class="type">Source</span> <span class="variable">cacheWritingSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Source</span>() &#123;</span><br><span class="line">      <span class="type">boolean</span> cacheRequestClosed;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//这里就是从响应体体读取数据，保存到缓存文件中，对应缓存文件“\*\*\*\*.1”</span></span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">read</span><span class="params">(Buffer sink, <span class="type">long</span> byteCount)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">long</span> bytesRead;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          bytesRead = source.read(sink, byteCount);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!cacheRequestClosed) &#123;</span><br><span class="line">            cacheRequestClosed = <span class="literal">true</span>;</span><br><span class="line">            cacheRequest.abort(); <span class="comment">// Failed to write a complete cache response.</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (bytesRead == -<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!cacheRequestClosed) &#123;</span><br><span class="line">            cacheRequestClosed = <span class="literal">true</span>;</span><br><span class="line">            cacheBody.close(); <span class="comment">// The cache response is complete!</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        sink.copyTo(cacheBody.buffer(), sink.size() - bytesRead, bytesRead);</span><br><span class="line">        cacheBody.emitCompleteSegments();</span><br><span class="line">        <span class="keyword">return</span> bytesRead;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> Timeout <span class="title function_">timeout</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> source.timeout();</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cacheRequestClosed</span><br><span class="line">            &amp;&amp; !discard(<span class="built_in">this</span>, HttpStream.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) &#123;</span><br><span class="line">          cacheRequestClosed = <span class="literal">true</span>;</span><br><span class="line">          cacheRequest.abort();</span><br><span class="line">        &#125;</span><br><span class="line">        source.close();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> response.newBuilder()</span><br><span class="line">        .body(<span class="keyword">new</span> <span class="title class_">RealResponseBody</span>(response.headers(), Okio.buffer(cacheWritingSource)))</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>可以看到这里先通过maybeCache写入了响应头信息，再通过cacheWritingResponse写入了响应体信息。我们再进去看Cache的put方法实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> CacheRequest <span class="title function_">put</span><span class="params">(Response response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">requestMethod</span> <span class="operator">=</span> response.request().method();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 响应的请求方法不支持缓存，只有GET方法支持缓存</span></span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.invalidatesCache(response.request().method())) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        remove(response.request());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">        <span class="comment">// The cache cannot be written.</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同样，请求只支持GET方法的缓存</span></span><br><span class="line">    <span class="keyword">if</span> (!requestMethod.equals(<span class="string">&quot;GET&quot;</span>)) &#123;</span><br><span class="line">      <span class="comment">// Don&#x27;t cache non-GET responses. We&#x27;re technically allowed to cache</span></span><br><span class="line">      <span class="comment">// HEAD requests and some POST requests, but the complexity of doing</span></span><br><span class="line">      <span class="comment">// so is high and the benefit is low.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//缓存不支持通配符</span></span><br><span class="line">    <span class="keyword">if</span> (OkHeaders.hasVaryAll(response)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//开始缓存</span></span><br><span class="line">    <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Entry</span>(response);</span><br><span class="line">    DiskLruCache.<span class="type">Editor</span> <span class="variable">editor</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      editor = cache.edit(urlToKey(response.request()));</span><br><span class="line">      <span class="keyword">if</span> (editor == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      entry.writeTo(editor);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CacheRequestImpl</span>(editor);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      abortQuietly(editor);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>我们继续看Cache的writeTo方法，可以看到是写入一些响应头信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeTo</span><span class="params">(DiskLruCache.Editor editor)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      <span class="type">BufferedSink</span> <span class="variable">sink</span> <span class="operator">=</span> Okio.buffer(editor.newSink(ENTRY_METADATA));</span><br><span class="line"> </span><br><span class="line">      sink.writeUtf8(url);</span><br><span class="line">      sink.writeByte(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">      sink.writeUtf8(requestMethod);</span><br><span class="line">      sink.writeByte(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">      sink.writeDecimalLong(varyHeaders.size());</span><br><span class="line">      sink.writeByte(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, size = varyHeaders.size(); i &lt; size; i++) &#123;</span><br><span class="line">        sink.writeUtf8(varyHeaders.name(i));</span><br><span class="line">        sink.writeUtf8(<span class="string">&quot;: &quot;</span>);</span><br><span class="line">        sink.writeUtf8(varyHeaders.value(i));</span><br><span class="line">        sink.writeByte(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      sink.writeUtf8(<span class="keyword">new</span> <span class="title class_">StatusLine</span>(protocol, code, message).toString());</span><br><span class="line">      sink.writeByte(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">      sink.writeDecimalLong(responseHeaders.size());</span><br><span class="line">      sink.writeByte(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, size = responseHeaders.size(); i &lt; size; i++) &#123;</span><br><span class="line">        sink.writeUtf8(responseHeaders.name(i));</span><br><span class="line">        sink.writeUtf8(<span class="string">&quot;: &quot;</span>);</span><br><span class="line">        sink.writeUtf8(responseHeaders.value(i));</span><br><span class="line">        sink.writeByte(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">if</span> (isHttps()) &#123;</span><br><span class="line">        sink.writeByte(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        sink.writeUtf8(handshake.cipherSuite().javaName());</span><br><span class="line">        sink.writeByte(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        writeCertList(sink, handshake.peerCertificates());</span><br><span class="line">        writeCertList(sink, handshake.localCertificates());</span><br><span class="line">        <span class="comment">// The handshake’s TLS version is null on HttpsURLConnection and on older cached responses.</span></span><br><span class="line">        <span class="keyword">if</span> (handshake.tlsVersion() != <span class="literal">null</span>) &#123;</span><br><span class="line">          sink.writeUtf8(handshake.tlsVersion().javaName());</span><br><span class="line">          sink.writeByte(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      sink.close();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>到这里Okhttp缓存的读取和存储流程我们就清楚了。可以说，缓存的使用策略基本都是按照HTTP的缓存定义来实现的，所以对HTTP缓存相关字段的理解是很重要的。然后关于DiskLruCache是如何管理缓存文件的，这个其实也很好理解，首先的原则就是按照LRU这种最近最少使用删除的原则，当总的大小超过限定大小后，删除最近最少使用的缓存文件，它的LRU算法是使用LinkedHashMap进行维护的，这样来保证，保留的缓存文件都是更常使用的。具体实现大家可以分析DiskLruCache和LinkedHashMap的实现原理。</p>
<h2 id="Okhttp任务队列工作原理"><a href="#Okhttp任务队列工作原理" class="headerlink" title="Okhttp任务队列工作原理"></a>Okhttp任务队列工作原理</h2><p>android完成非阻塞式的异步请求的时候都是通过启动子线程的方式来解决，子线程执行完任务的之后通过handler的方式来和主线程来完成通信。无限制的创建线程，会给系统带来大量的开销。如果在高并发的任务下，启用个线程池，可以不断的复用里面不再使用和有效的管理线程的调度和数量的管理。就可以节省系统的成本，有效的提高执行效率。</p>
<h3 id="线程池ThreadPoolExecutor"><a href="#线程池ThreadPoolExecutor" class="headerlink" title="线程池ThreadPoolExecutor"></a>线程池ThreadPoolExecutor</h3><p>okhttp的线程池对象存在于Dispatcher类中。实例过程如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>  <span class="keyword">public</span>  <span class="keyword">synchronized</span>  ExecutorService <span class="title function_">executorService</span><span class="params">()</span>  &#123;</span><br><span class="line"><span class="number">2.</span>  <span class="keyword">if</span>  (executorService ==  <span class="literal">null</span>)  &#123;</span><br><span class="line"><span class="number">3.</span>  executorService =  ,  Integer.MAX_VALUE,  ,  TimeUnit.SECONDS,</span><br><span class="line"><span class="number">4.</span>  <span class="keyword">new</span>  <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;(),  Util.threadFactory(<span class="string">&quot;OkHttp Dispatcher&quot;</span>,  <span class="literal">false</span>));</span><br><span class="line"><span class="number">5.</span>  &#125;</span><br><span class="line"><span class="number">6.</span>  <span class="keyword">return</span> executorService;</span><br><span class="line"><span class="number">7.</span>  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Call对象"><a href="#Call对象" class="headerlink" title="Call对象"></a>Call对象</h4><p>了解源码或使用过okhttp的都知道。 okttp的操作元是Call对象。异步的实现是RealCall.AsyncCall。而 AsyncCall是实现的一个Runnable接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>  <span class="keyword">final</span>  <span class="keyword">class</span>  <span class="title class_">AsyncCall</span>  <span class="keyword">extends</span>  <span class="title class_">NamedRunnable</span>  &#123;&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>所以Call本质就是一个Runable线程操作元肯定是放进excutorService中直接启动的。</p>
<h4 id="线程池的复用和管理"><a href="#线程池的复用和管理" class="headerlink" title="线程池的复用和管理"></a>线程池的复用和管理</h4><p>为了完成调度和复用，定义了两个队列分别用作等待队列和执行任务的队列。这两个队列都是Dispatcher 成员变量。Dispatcher是一个控制执行，控制所有Call的分发和任务的调度、通信、清理等操作。这里只介绍异步调度任务。<br>在《okhttp连接池复用机制》文章中我们在缓存Connection连接的时候也是使用的Deque双端队列。这里同样的方式，可以方便在队列头添加元素，移除尾部的元素。<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/%E7%BD%91%E7%BB%9C/.1606916854526.png" alt="Alt text"><br>过程分析</p>
<p>Call代用equeue方法的时候</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>  <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(AsyncCall call)</span>  &#123;</span><br><span class="line"><span class="number">2.</span>  <span class="keyword">if</span>  (runningAsyncCalls.size()  &lt; maxRequests &amp;&amp; runningCallsForHost(call)  &lt; maxRequestsPerHost)  &#123;</span><br><span class="line"><span class="number">3.</span>  runningAsyncCalls.add(call);</span><br><span class="line"><span class="number">4.</span>  executorService().execute(call);</span><br><span class="line"><span class="number">5.</span>  &#125;  <span class="keyword">else</span>  &#123;</span><br><span class="line"><span class="number">6.</span>  readyAsyncCalls.add(call);</span><br><span class="line"><span class="number">7.</span>  &#125;</span><br><span class="line"><span class="number">8.</span>  &#125;</span><br></pre></td></tr></table></figure>
<p>方法中满足执行队列里面不足最大线程数maxRequests并且Call对应的host数目不超过maxRequestsPerHost 的时候直接把call对象直接推入到执行队列里，并启动线程任务（Call本质是一个Runnable）。否则，当前线程数过多，就把他推入到等待队列中。Call执行完肯定需要在runningAsyncCalls 队列中移除这个线程。那么readyAsyncCalls队列中的线程在什么时候才会被执行呢。</p>
<p>追溯下AsyncCall 线程的执行方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>  <span class="meta">@Override</span></span><br><span class="line"><span class="number">2.</span>  <span class="keyword">protected</span>  <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>  &#123;</span><br><span class="line"><span class="number">3.</span>  <span class="type">boolean</span> <span class="variable">signalledCallback</span> <span class="operator">=</span>  <span class="literal">false</span>;</span><br><span class="line"><span class="number">4.</span>  <span class="keyword">try</span>  &#123;</span><br><span class="line"><span class="number">5.</span>  <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> getResponseWithInterceptorChain(forWebSocket);</span><br><span class="line"><span class="number">6.</span>  <span class="keyword">if</span>  (canceled)  &#123;</span><br><span class="line"><span class="number">7.</span>  signalledCallback =  <span class="literal">true</span>;</span><br><span class="line"><span class="number">8.</span>  responseCallback.onFailure(RealCall.<span class="built_in">this</span>,  <span class="keyword">new</span>  <span class="title class_">IOException</span>(<span class="string">&quot;Canceled&quot;</span>));</span><br><span class="line"><span class="number">9.</span>  &#125;  <span class="keyword">else</span>  &#123;</span><br><span class="line"><span class="number">10.</span>  signalledCallback =  <span class="literal">true</span>;</span><br><span class="line"><span class="number">11.</span>  responseCallback.onResponse(RealCall.<span class="built_in">this</span>, response);</span><br><span class="line"><span class="number">12.</span>  &#125;</span><br><span class="line"><span class="number">13.</span>  &#125;  <span class="keyword">catch</span>  (IOException e)  &#123;</span><br><span class="line"><span class="number">14.</span>  <span class="keyword">if</span>  (signalledCallback)  &#123;</span><br><span class="line"><span class="number">15.</span>  <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line"><span class="number">16.</span>  Platform.get().log(INFO,  <span class="string">&quot;Callback failure for &quot;</span>  + toLoggableString(), e);</span><br><span class="line"><span class="number">17.</span>  &#125;  <span class="keyword">else</span>  &#123;</span><br><span class="line"><span class="number">18.</span>  responseCallback.onFailure(RealCall.<span class="built_in">this</span>, e);</span><br><span class="line"><span class="number">19.</span>  &#125;</span><br><span class="line"><span class="number">20.</span>  &#125;  <span class="keyword">finally</span>  &#123;</span><br><span class="line"><span class="number">21.</span>  client.dispatcher().finished(<span class="built_in">this</span>);</span><br><span class="line"><span class="number">22.</span>  &#125;</span><br><span class="line"><span class="number">23.</span>  &#125;</span><br><span class="line"><span class="number">24.</span>  &#125;</span><br></pre></td></tr></table></figure>
<p>这里做了核心request的动作，并把失败和回复数据的结果通过responseCallback 回调到Dispatcher。执行操作完毕了之后不管有无异常都会进入到dispactcher的finished方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>  <span class="keyword">private</span>  &lt;T&gt;  <span class="keyword">void</span> <span class="title function_">finished</span><span class="params">(Deque&lt;T&gt; calls, T call,  <span class="type">boolean</span> promoteCalls)</span>  &#123;</span><br><span class="line"><span class="number">2.</span>  <span class="type">int</span> runningCallsCount;</span><br><span class="line"><span class="number">3.</span>  Runnable idleCallback;</span><br><span class="line"><span class="number">4.</span>  <span class="keyword">synchronized</span>  (<span class="built_in">this</span>)  &#123;</span><br><span class="line"><span class="number">5.</span>  <span class="keyword">if</span>  (!calls.remove(call))  <span class="keyword">throw</span>  <span class="keyword">new</span>  <span class="title class_">AssertionError</span>(<span class="string">&quot;Call wasn&#x27;t in-flight!&quot;</span>);</span><br><span class="line"><span class="number">6.</span>  <span class="keyword">if</span>  (promoteCalls) promoteCalls();</span><br><span class="line"><span class="number">7.</span>  runningCallsCount = runningCallsCount();</span><br><span class="line"><span class="number">8.</span>  idleCallback =  <span class="built_in">this</span>.idleCallback;</span><br><span class="line"><span class="number">9.</span>  &#125;</span><br><span class="line"> </span><br><span class="line"><span class="number">11.</span>  &amp;&amp; idleCallback !=  <span class="literal">null</span>)  &#123;</span><br><span class="line"><span class="number">12.</span>  idleCallback.run();</span><br><span class="line"><span class="number">13.</span>  &#125;</span><br><span class="line"><span class="number">14.</span>  &#125;</span><br></pre></td></tr></table></figure>
<p>在这里call在runningAsyncCalls队列中被移除了，重新计算了目前正在执行的线程数量。并且调用了promoteCalls（） 看来是来调整任务队列的，跟进去看下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>  <span class="keyword">private</span>  <span class="keyword">void</span> <span class="title function_">promoteCalls</span><span class="params">()</span>  &#123;</span><br><span class="line"><span class="number">2.</span>  <span class="keyword">if</span>  (runningAsyncCalls.size()  &gt;= maxRequests)  <span class="keyword">return</span>;  <span class="comment">// Already running max capacity.</span></span><br><span class="line"><span class="number">3.</span>  <span class="keyword">if</span>  (readyAsyncCalls.isEmpty())  <span class="keyword">return</span>;  <span class="comment">// No ready calls to promote.</span></span><br><span class="line"> </span><br><span class="line"><span class="number">5.</span>  <span class="keyword">for</span>  (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext();  )  &#123;</span><br><span class="line"><span class="number">6.</span>  <span class="type">AsyncCall</span> <span class="variable">call</span> <span class="operator">=</span> i.next();</span><br><span class="line"> </span><br><span class="line"><span class="number">8.</span>  <span class="keyword">if</span>  (runningCallsForHost(call)  &lt; maxRequestsPerHost)  &#123;</span><br><span class="line"><span class="number">9.</span>  i.remove();</span><br><span class="line"><span class="number">10.</span>  runningAsyncCalls.add(call);</span><br><span class="line"><span class="number">11.</span>  executorService().execute(call);</span><br><span class="line"><span class="number">12.</span>  &#125;</span><br><span class="line"> </span><br><span class="line"><span class="number">14.</span>  <span class="keyword">if</span>  (runningAsyncCalls.size()  &gt;= maxRequests)  <span class="keyword">return</span>;  <span class="comment">// Reached max capacity.</span></span><br><span class="line"><span class="number">15.</span>  &#125;</span><br><span class="line"><span class="number">16.</span>  &#125;</span><br></pre></td></tr></table></figure>
<p>原来实在这里对readyAsyncCalls 进行调度的。最终会在readyAsyncCalls 中通过remove操作把元素迭代取出并移除之后加入到runningAsyncCalls的执行队列中执行操作。ArrayDeque 是非线程安全的所以finished在调用promoteCalls 的时候都在synchronized块中执行的。执行等待队列线程当然的前提是runningAsyncCalls 线程数没有超上线，而且等待队列里面有等待的任务。</p>
<p>以上完成了线程线程池的复用和线程的管理工作。<br>小结，Call在执行任务通过Dispatcher把单元任务优先推到执行队列里进行操作，如果操作完成再执行等待队列的任务。</p>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/%E7%BD%91%E7%BB%9C/.20200216133819685.png" alt="Alt text"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">override fun <span class="title function_">intercept</span><span class="params">(chain: Interceptor.Chain)</span>: Response &#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">request</span> <span class="operator">=</span> chain.request()</span><br><span class="line">        <span class="keyword">return</span> chain.proceed(request)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后一个 </span></span><br><span class="line"> override fun <span class="title function_">intercept</span><span class="params">(chain: Interceptor.Chain)</span>: Response? &#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">request</span> <span class="operator">=</span> chain.request()</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="type">val</span> <span class="variable">inputStream</span> <span class="operator">=</span> urlConnection.inputStream</span><br><span class="line">            <span class="type">val</span> <span class="variable">response</span> <span class="operator">=</span> Response(inputStream)</span><br><span class="line">            <span class="keyword">return</span> response</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//proceed</span></span><br><span class="line"> override fun <span class="title function_">proceed</span><span class="params">(request: Request)</span>: Response &#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">next</span> <span class="operator">=</span> RealInterceptorChain(interceptors, index + <span class="number">1</span>, request)</span><br><span class="line">        <span class="type">val</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors[index]</span><br><span class="line">        <span class="type">val</span> <span class="variable">response</span> <span class="operator">=</span> interceptor.intercept(next) as Response</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h3><blockquote>
<p>处理重试的一个拦截器，会去处理一些异常，只要不是致命的异常就会重新发起一次请求（把Request给下级），如果是致命的异常就会抛给上一级；<br>会处理一些重定向等等，比如 3XX 307、407 就会从头部中获取新的路径，生成一个新的请求交给下一级（重新发起一次请求）</p>
</blockquote>
<h3 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h3><blockquote>
<p>做一个简单的处理，设置一些通用的请求头，Content-Type Connection Content-Length Cookie<br>做一些返回的处理，如果返回的数据被压缩了采用 ZipSource , 保存 Cookie </p>
</blockquote>
<h3 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h3><blockquote>
<p>在缓存可用的情况下，读取本地的缓存的数据，如果没有直接去服务器，如果有首先判断有没有缓存策略，然后判断有没有过期，如果没有过期直接拿缓存，如果过期了需要添加一些之前头部信息如：If-Modified-Since ，这个时候后台有可能会给你返回 304 代表你还是可以拿本地缓存，每次读取到新的响应后做一次缓存。</p>
</blockquote>
<h3 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h3><blockquote>
<p>findHealthyConnection() 找一个连接，首先判断有没有健康的，没有就创建（建立Scoket,握手连接），连接缓存得到一条结论：OkHttp 是基于原生的 Socket + okio（原生IO的封装），封装 HttpCodec 里面封装了 okio 的 Source（输入） 和 Sink (输出)，我们通过 HttpCodec 就可以操作 Socket的输入输出，我们就可以像服务器写数据和读取返回数据</p>
</blockquote>
<h3 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h3><blockquote>
<p>写数据和读取数据<br>写头部信息，写body表单信息等等</p>
</blockquote>
<h2 id="连接三个核心类（连接复用）"><a href="#连接三个核心类（连接复用）" class="headerlink" title="连接三个核心类（连接复用）"></a>连接三个核心类（连接复用）</h2><p>RealConnection、ConnectionPool、StreamAllocation</p>
<blockquote>
<p>RealConnection: 建立连接的一个对象的封装<br>ConnectionPool：保存了连接<br>StreamAllocation: 找一些连接，做一下封装<br>##OkHttp3拦截器<br>首先构造一个简单的异步网络访问Demo:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>  <span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">OkHttpClient</span>();</span><br><span class="line"><span class="number">2.</span>  <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">Request</span>.Builder()</span><br><span class="line"><span class="number">3.</span>  .url(<span class="string">&quot;http://publicobject.com/helloworld.txt&quot;</span>)</span><br><span class="line"><span class="number">4.</span>  .build();</span><br><span class="line"> </span><br><span class="line"><span class="number">6.</span>  client.newCall(request).enqueue(<span class="keyword">new</span>  <span class="title class_">Callback</span>()  &#123;</span><br><span class="line"><span class="number">7.</span>  <span class="meta">@Override</span></span><br><span class="line"><span class="number">8.</span>  <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Call call,  IOException e)</span>  &#123;</span><br><span class="line"><span class="number">9.</span>  Log.d(<span class="string">&quot;OkHttp&quot;</span>,  <span class="string">&quot;Call Failed:&quot;</span>  + e.getMessage());</span><br><span class="line"><span class="number">10.</span>  &#125;</span><br><span class="line"> </span><br><span class="line"><span class="number">12.</span>  <span class="meta">@Override</span></span><br><span class="line"><span class="number">13.</span>  <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(Call call,  Response response)</span>  <span class="keyword">throws</span>  IOException  &#123;</span><br><span class="line"><span class="number">14.</span>  Log.d(<span class="string">&quot;OkHttp&quot;</span>,  <span class="string">&quot;Call succeeded:&quot;</span>  + response.message());</span><br><span class="line"><span class="number">15.</span>  &#125;</span><br><span class="line"><span class="number">16.</span>  &#125;);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>发起请求</li>
</ol>
<p>OkHttpClient.newCall实际是创建一个RealCall实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>  <span class="meta">@Override</span></span><br><span class="line"><span class="number">2.</span>  <span class="keyword">public</span>  Call <span class="title function_">newCall</span><span class="params">(Request request)</span>  &#123;</span><br><span class="line"><span class="number">3.</span>  <span class="keyword">return</span>  <span class="keyword">new</span>  <span class="title class_">RealCall</span>(<span class="built_in">this</span>, request,  <span class="literal">false</span>  <span class="comment">/* for web socket */</span>);</span><br><span class="line"><span class="number">4.</span>  &#125;</span><br><span class="line">RealCall.enqueue实际就是讲一个RealCall放入到任务队列中，等待合适的机会执行:</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>  <span class="meta">@Override</span></span><br><span class="line"><span class="number">2.</span>  <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Callback responseCallback)</span>  &#123;</span><br><span class="line"><span class="number">3.</span>  <span class="keyword">synchronized</span>  (<span class="built_in">this</span>)  &#123;</span><br><span class="line"><span class="number">4.</span>  <span class="keyword">if</span>  (executed)  <span class="keyword">throw</span>  <span class="keyword">new</span>  <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Already Executed&quot;</span>);</span><br><span class="line"><span class="number">5.</span>  executed =  <span class="literal">true</span>;</span><br><span class="line"><span class="number">6.</span>  &#125;</span><br><span class="line"><span class="number">7.</span>  captureCallStackTrace();</span><br><span class="line"><span class="number">8.</span>  client.dispatcher().enqueue(<span class="keyword">new</span>  <span class="title class_">AsyncCall</span>(responseCallback));</span><br><span class="line"><span class="number">9.</span>  &#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看到最终RealCall被转化成一个AsyncCall并被放入到任务队列中，任务队列中的分发逻辑这里先不说，相关实现会放在OkHttp源码分析——任务队列疑问进行介绍。这里只需要知道AsyncCall的excute方法最终将会被执行:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>  [RealCall.java]</span><br><span class="line"><span class="number">2.</span>  <span class="meta">@Override</span>  <span class="keyword">protected</span>  <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>  &#123;</span><br><span class="line"><span class="number">3.</span>  <span class="type">boolean</span> <span class="variable">signalledCallback</span> <span class="operator">=</span>  <span class="literal">false</span>;</span><br><span class="line"><span class="number">4.</span>  <span class="keyword">try</span>  &#123;</span><br><span class="line"><span class="number">5.</span>  <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> getResponseWithInterceptorChain();</span><br><span class="line"><span class="number">6.</span>  <span class="keyword">if</span>  (retryAndFollowUpInterceptor.isCanceled())  &#123;</span><br><span class="line"><span class="number">7.</span>  signalledCallback =  <span class="literal">true</span>;</span><br><span class="line"><span class="number">8.</span>  responseCallback.onFailure(RealCall.<span class="built_in">this</span>,  <span class="keyword">new</span>  <span class="title class_">IOException</span>(<span class="string">&quot;Canceled&quot;</span>));</span><br><span class="line"><span class="number">9.</span>  &#125;  <span class="keyword">else</span>  &#123;</span><br><span class="line"><span class="number">10.</span>  signalledCallback =  <span class="literal">true</span>;</span><br><span class="line"><span class="number">11.</span>  responseCallback.onResponse(RealCall.<span class="built_in">this</span>, response);</span><br><span class="line"><span class="number">12.</span>  &#125;</span><br><span class="line"><span class="number">13.</span>  &#125;  <span class="keyword">catch</span>  (IOException e)  &#123;</span><br><span class="line"><span class="number">14.</span>  <span class="keyword">if</span>  (signalledCallback)  &#123;</span><br><span class="line"><span class="number">15.</span>  <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line"><span class="number">16.</span>  Platform.get().log(INFO,  <span class="string">&quot;Callback failure for &quot;</span>  + toLoggableString(), e);</span><br><span class="line"><span class="number">17.</span>  &#125;  <span class="keyword">else</span>  &#123;</span><br><span class="line"><span class="number">18.</span>  responseCallback.onFailure(RealCall.<span class="built_in">this</span>, e);</span><br><span class="line"><span class="number">19.</span>  &#125;</span><br><span class="line"><span class="number">20.</span>  &#125;  <span class="keyword">finally</span>  &#123;</span><br><span class="line"><span class="number">21.</span>  client.dispatcher().finished(<span class="built_in">this</span>);</span><br><span class="line"><span class="number">22.</span>  &#125;</span><br><span class="line"><span class="number">23.</span>  &#125;</span><br><span class="line"><span class="number">24.</span>  &#125;</span><br></pre></td></tr></table></figure>
<p>execute方法的逻辑并不复杂，简单的说就是：</p>
<p>调用getResponseWithInterceptorChain获取服务器返回<br>通知任务分发器(client.dispatcher)该任务已结束<br>getResponseWithInterceptorChain构建了一个拦截器链，通过依次执行该拦截器链中的每一个拦截器最终得到服务器返回。</p>
<ol start="3">
<li>构建拦截器链<br>首先来看下getResponseWithInterceptorChain的实现：</li>
</ol>
<p>源码路径：okhttp3&#x2F;RealCall.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始执行整个请求</span></span><br><span class="line">Response <span class="title function_">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">  <span class="comment">// 拦截器栈</span></span><br><span class="line">  List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">// 前文说过的 普通拦截器</span></span><br><span class="line">  interceptors.addAll(client.interceptors());</span><br><span class="line">  <span class="comment">// 重试拦截器，网络错误、请求失败等</span></span><br><span class="line">  interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">  <span class="comment">// 桥接拦截器，主要是重构请求头即header</span></span><br><span class="line">  interceptors.add(<span class="keyword">new</span> <span class="title class_">BridgeInterceptor</span>(client.cookieJar()));</span><br><span class="line">  <span class="comment">// 缓存拦截器</span></span><br><span class="line">  interceptors.add(newCacheInterceptor(client.internalCache()));</span><br><span class="line">  <span class="comment">// 连接拦截器，连接服务器，https包装</span></span><br><span class="line">  interceptors.add(<span class="keyword">new</span> <span class="title class_">ConnectInterceptor</span>(client));</span><br><span class="line">  <span class="comment">// 网络拦截器，websockt不支持，同样是自定义</span></span><br><span class="line">  <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">    interceptors.addAll(client.networkInterceptors());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 服务拦截器，主要是发送（write、input）、读取（read、output）数据</span></span><br><span class="line">  interceptors.add(<span class="keyword">new</span> <span class="title class_">CallServerInterceptor</span>(forWebSocket));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开启调用链</span></span><br><span class="line">  Interceptor.<span class="type">Chain</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealInterceptorChain</span>(</span><br><span class="line">      interceptors, , originalRequest);</span><br><span class="line">  <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其逻辑大致分为两部分：</p>
<p>创建一系列拦截器，并将其放入一个拦截器数组中。这部分拦截器即包括用户自定义的拦截器也包括框架内部拦截器<br>创建一个拦截器链RealInterceptorChain,并执行拦截器链的proceed方法<br>接下来看下RealInterceptorChain的实现逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">RealInterceptorChain</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span>.Chain &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> StreamAllocation streamAllocation;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HttpCodec httpCodec;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> RealConnection connection;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> index;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Request request;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> calls;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">RealInterceptorChain</span><span class="params">(List&lt;Interceptor&gt; interceptors, StreamAllocation streamAllocation,</span></span><br><span class="line"><span class="params">                              HttpCodec httpCodec, RealConnection connection, <span class="type">int</span> index, Request request)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.interceptors = interceptors;</span><br><span class="line">    <span class="built_in">this</span>.connection = connection;</span><br><span class="line">    <span class="built_in">this</span>.streamAllocation = streamAllocation;</span><br><span class="line">    <span class="built_in">this</span>.httpCodec = httpCodec;</span><br><span class="line">    <span class="built_in">this</span>.index = index;</span><br><span class="line">    <span class="built_in">this</span>.request = request;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> Connection <span class="title function_">connection</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> connection;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> StreamAllocation <span class="title function_">streamAllocation</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> streamAllocation;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> HttpCodec <span class="title function_">httpStream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> httpCodec;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> Request <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> request;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> Response <span class="title function_">proceed</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Response <span class="title function_">proceed</span><span class="params">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span></span><br><span class="line"><span class="params">      RealConnection connection)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// Call the next interceptor in the chain.</span></span><br><span class="line">    <span class="type">RealInterceptorChain</span> <span class="variable">next</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealInterceptorChain</span>(</span><br><span class="line">        interceptors, streamAllocation, httpCodec, connection, index + , request);</span><br><span class="line">    <span class="type">Interceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors.get(index);</span><br><span class="line">    <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> interceptor.intercept(next);</span><br><span class="line"></span><br><span class="line">    ...... </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在proceed方法中的核心代码可以看到，proceed实际上也做了两件事：</p>
<p>创建下一个拦截链。传入index + 1使得下一个拦截器链只能从下一个拦截器开始访问<br>执行索引为index的intercept方法，并将下一个拦截器链传入该方法。</p>
<h1 id="Retrofit2"><a href="#Retrofit2" class="headerlink" title="Retrofit2"></a>Retrofit2</h1><p>一个 Restful 设计风格的 HTTP 网络请求框架的封装。基于 OkHttp<br>Retrofit 将我们的 HTTP API 转换成一个 接口形式。所以我们第一步定义一个 interface</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GitHubService</span> &#123;</span><br><span class="line">    <span class="meta">@GET(&quot;user/&#123;user&#125;/repos&quot;)</span></span><br><span class="line">    Call&lt;List&lt;Integer&gt;&gt; <span class="title function_">listRepos</span><span class="params">(<span class="meta">@Path(&quot;user&quot;)</span> String user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、然后构建一个 Retrofit，通过 create 方法生成 GitHubService 的一个实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Retrofit</span> <span class="variable">retrofit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Retrofit</span>.Builder()</span><br><span class="line">    .baseUrl(<span class="string">&quot;https://api.github.com/&quot;</span>)</span><br><span class="line">    .build();</span><br><span class="line"> </span><br><span class="line"><span class="type">GitHubService</span> <span class="variable">service</span> <span class="operator">=</span> retrofit.create(GitHubService.class);</span><br></pre></td></tr></table></figure>
<p>3、调用 listRepos 拿到 Call 实例，可以做同步或异步请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Call&lt;List&lt;Integer&gt;&gt; repos = service.listRepos(<span class="string">&quot;octocat&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>每个 Call 实例只能使用一次，但调用 clone() 将创建一个可以使用的新实例。</p>
<h2 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h2><p>首先看看 Retrofit 吧，这个类里面有7个实例变量。我们根据类型和变量名先猜猜是干什么用的，留个大体印象即可。<br>Retrofit 将我们的 HTTP API 转换成一个 接口形式。所以我们第一步定义一个 interface</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个线程安全的、支持高效并发的HashMap，Key 是 Method，Value 是 ServiceMethod。Method 我们能猜到应该就是上面接口中定义的 listRepos，而这个方法中有很多注解，@GET、@Path 啥的，那这个 ServiceMethod 很有可能是这个方法的封装。而变量名带个 Cache 说明，会把这个 Method 对应的 ServiceMethod 缓存起来。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, ServiceMethod&lt;?, ?&gt;&gt; serviceMethodCache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 想必你知道 Retrofit 就是基于 OkHttp 的封装，那这个 Call.Factory，明显就是 Call 的工厂类。至于 Call 是干嘛的，负责创建 HTTP 请求，HTTP 请求被抽象为了 okhttp3.Call 类，它表示一个已经准备好，可以随时执行的 HTTP 请求；</span></span><br><span class="line"><span class="keyword">final</span> okhttp3.Call.Factory callFactory;</span><br><span class="line"><span class="comment">// 这个很好理解了，就是上面 基本使用 中的 baseUrl，可是这是个 HttpUrl 类型的，我们传的可是 String 类型的呀，那估计是通过 Builder 做了处理的。</span></span><br><span class="line"><span class="keyword">final</span> HttpUrl baseUrl;</span><br><span class="line"><span class="comment">// Converter 根据字面意思可得 这应该是个转换器，用于把我们的 响应 转换成特定的格式</span></span><br><span class="line"><span class="keyword">final</span> List&lt;Converter.Factory&gt; converterFactories;</span><br><span class="line"><span class="comment">// CallAdapter 根据字面意思，难道是对 Call 的一个适配？</span></span><br><span class="line"><span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories;</span><br><span class="line"><span class="comment">// Executor 很熟悉了，这是个回调 Executor，想必就是用来切换线程的了</span></span><br><span class="line"><span class="keyword">final</span> <span class="meta">@Nullable</span> Executor callbackExecutor;</span><br><span class="line"><span class="comment">// 这个就猜不出了，只能暂时理解为一个标志位</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> validateEagerly; </span><br></pre></td></tr></table></figure>
<p>再来看看 Retrofit 的构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,</span><br><span class="line">    List&lt;Converter.Factory&gt; converterFactories, List&lt;CallAdapter.Factory&gt; callAdapterFactories,</span><br><span class="line">    <span class="meta">@Nullable</span> Executor callbackExecutor, <span class="type">boolean</span> validateEagerly) &#123;</span><br><span class="line">  <span class="built_in">this</span>.callFactory = callFactory;</span><br><span class="line">  <span class="built_in">this</span>.baseUrl = baseUrl;</span><br><span class="line">  <span class="built_in">this</span>.converterFactories = converterFactories; <span class="comment">// Copy+unmodifiable at call site.</span></span><br><span class="line">  <span class="built_in">this</span>.callAdapterFactories = callAdapterFactories; <span class="comment">// Copy+unmodifiable at call site.</span></span><br><span class="line">  <span class="built_in">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">  <span class="built_in">this</span>.validateEagerly = validateEagerly;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>并没做什么特殊的处理，就是简单的赋值，那想必所有初始化的操作都在 Builder 里了。</p>
<p>那么成功建立一个 Retrofit 对象的标准就是：配置好Retrofit 里的成员变量。</p>
<ul>
<li>callFactory : 网络请求 工厂</li>
<li>baseUrl ：网络请求的基本 Url 地址</li>
<li>converterFactories ：数据转换器 工厂集合</li>
<li>callAdapterFactories ：网络请求适配器 工厂集合</li>
<li>callbackExecutor ：回调方法执行器</li>
</ul>
<p>##Retrofit.Builder</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Platform platform;</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> okhttp3.Call.Factory callFactory;</span><br><span class="line">    <span class="keyword">private</span> HttpUrl baseUrl;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> Executor callbackExecutor;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> validateEagerly;</span><br><span class="line"> </span><br><span class="line">    Builder(Platform platform) &#123;</span><br><span class="line">      <span class="built_in">this</span>.platform = platform;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>(Platform.get());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>我们可以看到 Builder 与 Retrofit 的参数几乎一样，只是少了 serviceMethodCache，多了个 Platform。这个 Platform 很重要。我们通过 Builder 的构造函数可以知道，调用了 Platform.get()方法，然后赋值给自己的 platform 变量。 我们看看这个 Platform 类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Platform</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Platform</span> <span class="variable">PLATFORM</span> <span class="operator">=</span> findPlatform();</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">static</span> Platform <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> PLATFORM;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Platform <span class="title function_">findPlatform</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Class.forName(<span class="string">&quot;android.os.Build&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (Build.VERSION.SDK_INT != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Android</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Class.forName(<span class="string">&quot;java.util.Optional&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Java8</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Platform</span>();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// ... ...</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>get 方法会去调用 findPlatform 方法，这个里面很明显跟平台相关，Class.forName 要求 JVM 根据 className 查找并加载指定的类，如果未找到则抛出 ClassNotFoundException 。这里很明显我们分析 Android 平台，所以会 return 一个 Android（）对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Platform 内部</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Android</span> <span class="keyword">extends</span> <span class="title class_">Platform</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> Executor <span class="title function_">defaultCallbackExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MainThreadExecutor</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span> CallAdapter.Factory <span class="title function_">defaultCallAdapterFactory</span><span class="params">(<span class="meta">@Nullable</span> Executor callbackExecutor)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (callbackExecutor == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExecutorCallAdapterFactory</span>(callbackExecutor);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MainThreadExecutor</span> <span class="keyword">implements</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>(Looper.getMainLooper());</span><br><span class="line"> </span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        handler.post(r);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>我们在这里面可以看到两个重要的方法</p>
<ul>
<li>defaultCallbackExecutor ：这个方法返回的是个 Executor ，我们想到 Retrofit 正好有个 Executor 类型的变量，那么想必就是它了，它是 MainThreadExecutor 类型的，内部采用 handler 执行任务。</li>
<li>defaultCallAdapterFactory ：这个方法返回的是个 CallAdapter.Factory，Retrofit 成员变量中也正好有个 CallAdapter.Factory 类型的变量，所以说这个 Platform 很重要嘛，跟我们 Retrofit 类中的两个成员变量都有重大的关系。这里最终返回的是个 ExecutorCallAdapterFactory ，话说我们一开始就不知道这个 CallAdapter 是什么，更不用说这个 Factory 了，那我们先看看这个 ExecutorCallAdapterFactory 吧。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ExecutorCallAdapterFactory</span> <span class="keyword">extends</span> <span class="title class_">CallAdapter</span>.Factory &#123;</span><br><span class="line">  <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line"> </span><br><span class="line">  ExecutorCallAdapterFactory(Executor callbackExecutor) &#123;</span><br><span class="line">    <span class="built_in">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getRawType(returnType) != Call.class) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Type</span> <span class="variable">responseType</span> <span class="operator">=</span> Utils.getCallResponseType(returnType);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CallAdapter</span>&lt;Object, Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> Type <span class="title function_">responseType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> responseType;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> Call&lt;Object&gt; <span class="title function_">adapt</span><span class="params">(Call&lt;Object&gt; call)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExecutorCallbackCall</span>&lt;&gt;(callbackExecutor, call);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//... ... 省略</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
这里我们可以看到，把我们传进来的 Executor 保存起来了，这个 Executor 想必就是 MainThreadExecutor 了。至于 get 方法，我们暂时还不知道哪里用到了，所以后面的暂时不看了，到了这里还是不知道 CallAdapter.Factory 干嘛用的。</li>
</ul>
<p>看来 Builder 方法很复杂呀，写了这么多只是讲了个 Platform，不过幸好这里面也包括了 Executor 和 CallAdapter.Factory ，那么现在我们正式看看 Builder.build()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Retrofit <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// 这一句告诉我们，baseUrl 是必不可少的。</span></span><br><span class="line">      <span class="keyword">if</span> (baseUrl == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Base URL required.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 这里如果你没配置 callFactory , 会默认配置为 OkHttpClient</span></span><br><span class="line">      okhttp3.Call.<span class="type">Factory</span> <span class="variable">callFactory</span> <span class="operator">=</span> <span class="built_in">this</span>.callFactory;</span><br><span class="line">      <span class="keyword">if</span> (callFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">        callFactory = <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 同样的，没配置的话，会默认配置为 Platform 的 defaultCallbackExecutor，这里我们之前分析过，它所返回的就是 MainThreadExecutor</span></span><br><span class="line">      <span class="type">Executor</span> <span class="variable">callbackExecutor</span> <span class="operator">=</span> <span class="built_in">this</span>.callbackExecutor;</span><br><span class="line">      <span class="keyword">if</span> (callbackExecutor == <span class="literal">null</span>) &#123;</span><br><span class="line">        callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//这里会把你所配置的 CallAdapter.Factory 加到 List 里去，最后把 Platform 默认的 defaultCallAdapterFactory 即 ExecutorCallAdapterFactory 加到 List 的最后边，</span></span><br><span class="line">      <span class="comment">// Make a defensive copy of the adapters and add the default Call adapter.</span></span><br><span class="line">      List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.callAdapterFactories);</span><br><span class="line">      callAdapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//这里一样会把你配置的 Converter.Factory 加到 List 里去，但是会把一个 BuiltInConverters 加到第一个，而不是最后一个，请注意这点。</span></span><br><span class="line">      <span class="comment">// Make a defensive copy of the converters.</span></span><br><span class="line">      List&lt;Converter.Factory&gt; converterFactories =</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">1</span> + <span class="built_in">this</span>.converterFactories.size());</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// Add the built-in converter factory first. This prevents overriding its behavior but also</span></span><br><span class="line">      <span class="comment">// ensures correct behavior when using converters that consume all types.</span></span><br><span class="line">      converterFactories.add(<span class="keyword">new</span> <span class="title class_">BuiltInConverters</span>());</span><br><span class="line">      converterFactories.addAll(<span class="built_in">this</span>.converterFactories);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//最后返回一个 Retrofit 对象</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Retrofit</span>(callFactory, baseUrl, unmodifiableList(converterFactories),</span><br><span class="line">          unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>到这里，我们的 Retrofit 就构建完成了。如果按照我们 基本使用 中的例子，那么此刻，Retrofit 成员变量的值如下：</p>
<ul>
<li>serviceMethodCache ：暂时为空的 HashMap 集合</li>
<li>callFactory ： OkHttpClient 对象</li>
<li>baseUrl ： 根据配置的baseUrl “ <a target="_blank" rel="noopener" href="https://api.github.com/">https://api.github.com/</a> “ 字符串， 构建出了一个 HttpUrl 对象</li>
<li>converterFactories ：一个 ArrayList 对象，里面存放着一个BuiltInConverters 对象</li>
<li>callAdapterFactories ：一个 ArrayList 对象，里面存放着一个 ExecutorCallAdapterFactory 对象</li>
<li>callbackExecutor ：MainThreadExecutor 对象</li>
<li>validateEagerly ：默认值 false</li>
</ul>
<h3 id="创建网络请求接口实例"><a href="#创建网络请求接口实例" class="headerlink" title="创建网络请求接口实例"></a>创建网络请求接口实例</h3><p>接下来我们看看是怎样获得 GitHubService 实例的。<br>同样上源码，注意这里的 create 是非常重要的一个方法，这里使用了 外观模式 和 代理模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> &#123;</span><br><span class="line">  Utils.validateServiceInterface(service);</span><br><span class="line">  <span class="keyword">if</span> (validateEagerly) &#123;</span><br><span class="line">    eagerlyValidateMethods(service);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Platform</span> <span class="variable">platform</span> <span class="operator">=</span> Platform.get();</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span> <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">            <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">          <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class="line">          <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="built_in">this</span>, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">            <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">          &#125;</span><br><span class="line">          ServiceMethod&lt;Object, Object&gt; serviceMethod =</span><br><span class="line">              (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</span><br><span class="line">          OkHttpCall&lt;Object&gt; okHttpCall = <span class="keyword">new</span> <span class="title class_">OkHttpCall</span>&lt;&gt;(serviceMethod, args);</span><br><span class="line">          <span class="keyword">return</span> serviceMethod.adapt(okHttpCall);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>这里我们看到了 validateEagerly 变量，让我们看看它到底控制了什么。进 eagerlyValidateMethods 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eagerlyValidateMethods</span><span class="params">(Class&lt;?&gt; service)</span> &#123;</span><br><span class="line">  <span class="type">Platform</span> <span class="variable">platform</span> <span class="operator">=</span> Platform.get();</span><br><span class="line">  <span class="keyword">for</span> (Method method : service.getDeclaredMethods()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!platform.isDefaultMethod(method)) &#123;</span><br><span class="line">      loadServiceMethod(method);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ServiceMethod&lt;?, ?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">  ServiceMethod&lt;?, ?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</span><br><span class="line">    result = serviceMethodCache.get(method);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">      result = <span class="keyword">new</span> <span class="title class_">ServiceMethod</span>.Builder&lt;&gt;(<span class="built_in">this</span>, method).build();</span><br><span class="line">      serviceMethodCache.put(method, result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>这里又见到了 Platform ，在 Retrofit.Builder 我们知道它返回的是 Android() 对象。 接着是个 循环 ，循环取出接口中的 Method ，接着调用 loadServiceMethod 。 loadServiceMethod 里面会根据 Method 生成一个 ServiceMethod，然后存入 serviceMethodCache ， 那么我们大概知道，这是属于提前验证，会提前把接口中每个方法进行解析得到一个 ServiceMethod 对象，然后存入缓存中。 在 loadServiceMethod 中会取缓存中的值，如果有就直接返回 ServiceMethod。</p>
<p>由此可以知道 validateEagerly 变量是用于 判断是否需要提前验证解析的。</p>
<p>create 方法中 继续往下走，会看到 return 一个 代理对象 Proxy ，并转成了 T 类型，即 GitHubService 。<br>此时我们这句代码 GitHubService service &#x3D; retrofit.create(GitHubService.class); 中的 service 有值了，它指向一个 实现了 GitHubService 接口的 代理对象 Proxy 。</p>
<h3 id="拿到-Call-对象"><a href="#拿到-Call-对象" class="headerlink" title="拿到 Call 对象"></a>拿到 Call 对象</h3><p>即 Call&lt;List<Repo>&gt; repos &#x3D; service.listRepos(“octocat”);<br>这里我们的 service 是个代理对象，所以执行 listRepos 方法时， 会先走 InvocationHandler 中的 invoke 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> &#123;</span><br><span class="line">  Utils.validateServiceInterface(service);</span><br><span class="line">  <span class="keyword">if</span> (validateEagerly) &#123;</span><br><span class="line">    eagerlyValidateMethods(service);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Platform</span> <span class="variable">platform</span> <span class="operator">=</span> Platform.get();</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span> <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">            <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">          <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class="line">          <span class="comment">// 如果这个方法是声明在 Object 类中，那么不拦截，直接执行</span></span><br><span class="line">          <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="built_in">this</span>, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 这个总是返回的false，所以不用关心</span></span><br><span class="line">          <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">            <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">          &#125;</span><br><span class="line"> </span><br><span class="line">          <span class="comment">// 下面三行代码非常重要，重点分析，分别对应 3.1 3.2 3.3 三个小节</span></span><br><span class="line">          ServiceMethod&lt;Object, Object&gt; serviceMethod =</span><br><span class="line">              (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</span><br><span class="line">          OkHttpCall&lt;Object&gt; okHttpCall = <span class="keyword">new</span> <span class="title class_">OkHttpCall</span>&lt;&gt;(serviceMethod, args);</span><br><span class="line">          <span class="keyword">return</span> serviceMethod.adapt(okHttpCall);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>ServiceMethod&lt;Object, Object&gt; serviceMethod &#x3D; (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);<br>首先 ServiceMethod 我们之前猜测过，应该是对 Method 的一个封装， 而这个 loadServiceMethod ，如果你还记得的话，我们在 create 的时候就碰到过，eagerlyValidateMethods 这个方法内部调用过 loadServiceMethod ，是为了加载这个 ServiceMethod 。现在我们来深入分析这个 loadServiceMethod 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ServiceMethod&lt;?, ?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">  <span class="comment">// 首先从 缓存 serviceMethodCache 中取 ServiceMethod ，如果存在就返回，不存在继续往下走。</span></span><br><span class="line">  <span class="comment">// 也就是说 我们的 ServiceMethod 只会创建一次。</span></span><br><span class="line">  ServiceMethod&lt;?, ?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</span><br><span class="line">    <span class="comment">//这里又从缓存取了一遍，看到这里有没有一种熟悉的感觉，是不是跟 DCL 单例模式特别像，双重校验。</span></span><br><span class="line">    result = serviceMethodCache.get(method);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">      result = <span class="keyword">new</span> <span class="title class_">ServiceMethod</span>.Builder&lt;&gt;(<span class="built_in">this</span>, method).build();</span><br><span class="line">      serviceMethodCache.put(method, result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>到这里其实 loadServiceMethod 已经分析完了，很简单，就是个 DCL 单例模式，然后获得 ServiceMethod 。<br>那其实我们现在的分析任务就很明确了，弄清楚这个 ServiceMethod 究竟是什么 。</p>
<h3 id="ServiceMethod-分析"><a href="#ServiceMethod-分析" class="headerlink" title="ServiceMethod 分析"></a>ServiceMethod 分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ServiceMethod</span>&lt;R, T&gt; &#123;</span><br><span class="line"> <span class="comment">// ... 省略部分代码</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> okhttp3.Call.Factory callFactory;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> CallAdapter&lt;R, T&gt; callAdapter;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> HttpUrl baseUrl;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> Converter&lt;ResponseBody, R&gt; responseConverter;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 同样先猜猜什么意思吧</span></span><br><span class="line"> <span class="comment">// 应该是网络请求的 Http 方法，比如 GET、POST 啥的</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> String httpMethod;</span><br><span class="line"> <span class="comment">// 相对地址 ，应该就是 &quot;user/&#123;user&#125;/repos&quot; 这一段</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> String relativeUrl;</span><br><span class="line"> <span class="comment">// http 请求头</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> Headers headers;</span><br><span class="line"> <span class="comment">// 网络请求的 http 报文的 body 的类型</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> MediaType contentType;</span><br><span class="line"> <span class="comment">// 是否有 body</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> hasBody;</span><br><span class="line"> <span class="comment">// post 提交数据时，是否使用 表单提交 方式</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> isFormEncoded;</span><br><span class="line"> <span class="comment">// post 提交数据时，是否使用 Mutipart 方式，一般用来文件上传</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> isMultipart;</span><br><span class="line"> <span class="comment">// 方法参数处理器，应该是解析方法中的 参数 的吧，这个估计也得详细分析下。</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> ParameterHandler&lt;?&gt;[] parameterHandlers;</span><br><span class="line"></span><br><span class="line"> ServiceMethod(Builder&lt;R, T&gt; builder) &#123;</span><br><span class="line">   <span class="built_in">this</span>.callFactory = builder.retrofit.callFactory();</span><br><span class="line">   <span class="built_in">this</span>.callAdapter = builder.callAdapter;</span><br><span class="line">   <span class="built_in">this</span>.baseUrl = builder.retrofit.baseUrl();</span><br><span class="line">   <span class="built_in">this</span>.responseConverter = builder.responseConverter;</span><br><span class="line">   <span class="built_in">this</span>.httpMethod = builder.httpMethod;</span><br><span class="line">   <span class="built_in">this</span>.relativeUrl = builder.relativeUrl;</span><br><span class="line">   <span class="built_in">this</span>.headers = builder.headers;</span><br><span class="line">   <span class="built_in">this</span>.contentType = builder.contentType;</span><br><span class="line">   <span class="built_in">this</span>.hasBody = builder.hasBody;</span><br><span class="line">   <span class="built_in">this</span>.isFormEncoded = builder.isFormEncoded;</span><br><span class="line">   <span class="built_in">this</span>.isMultipart = builder.isMultipart;</span><br><span class="line">   <span class="built_in">this</span>.parameterHandlers = builder.parameterHandlers;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ... 省略部分代码</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先看看 ServiceMethod 的构造方法。 也是通过建造者模式构建的。其中很多变量其实都很熟悉了，比如 callFactory 、 baseUrl 。 对于 callAdapter、responseConverter 我们别弄混了，我们在 Retrofit 类中的变量是 callAdapterFactories 和 converterFactories ， 是它们的工厂，是生产它们的地方。</p>
<p>接下来看 Builder 吧，毕竟这是真正做事的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ServiceMethod <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 拿到具体的 CallAdapter 即 网络请求适配器，具体看 3.1.1.1</span></span><br><span class="line">    callAdapter = createCallAdapter();</span><br><span class="line">    <span class="comment">// 根据上面拿到的 callAdapter 获取 响应类型，在 3.1.1.1 小节分析完后可知道</span></span><br><span class="line">    <span class="comment">// 在我们的例子中 responseType = java.util.List&lt;java.lang.Integer&gt;</span></span><br><span class="line">    responseType = callAdapter.responseType();</span><br><span class="line">    <span class="keyword">if</span> (responseType == Response.class || responseType == okhttp3.Response.class) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(<span class="string">&quot;&#x27;&quot;</span></span><br><span class="line">          + Utils.getRawType(responseType).getName()</span><br><span class="line">          + <span class="string">&quot;&#x27; is not a valid response body type. Did you mean ResponseBody?&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取 响应转换器 ，具体看 3.1.1.2 小节</span></span><br><span class="line">    responseConverter = createResponseConverter();</span><br><span class="line">    <span class="comment">// 解析网络请求接口中方法的注解，这里我们就只有一个 @GET 注解，具体看 3.1.1.3 小节</span></span><br><span class="line">    <span class="comment">// 这里解析完可以拿到 Http 请求方法、请求体、相对 url、相对 url 中的参数</span></span><br><span class="line">    <span class="keyword">for</span> (Annotation annotation : methodAnnotations) &#123;</span><br><span class="line">      parseMethodAnnotation(annotation);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解析完方法上的注解后，做校验</span></span><br><span class="line">    <span class="keyword">if</span> (httpMethod == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(<span class="string">&quot;HTTP method annotation is required (e.g., @GET, @POST, etc.).&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!hasBody) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isMultipart) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(</span><br><span class="line">            <span class="string">&quot;Multipart can only be specified on HTTP methods with request body (e.g., @POST).&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isFormEncoded) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(<span class="string">&quot;FormUrlEncoded can only be specified on HTTP methods with &quot;</span></span><br><span class="line">            + <span class="string">&quot;request body (e.g., @POST).&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 解析当前方法的参数，这里就我们的例子而言</span></span><br><span class="line">    <span class="comment">// parameterAnnotationsArray 就是 @Path ，所以这里的 length 就是 1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">parameterCount</span> <span class="operator">=</span> parameterAnnotationsArray.length;</span><br><span class="line">    parameterHandlers = <span class="keyword">new</span> <span class="title class_">ParameterHandler</span>&lt;?&gt;[parameterCount];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>; p &lt; parameterCount; p++) &#123;</span><br><span class="line">      <span class="comment">// parameterTypes 是参数类型，就本例而言是 String</span></span><br><span class="line">      <span class="type">Type</span> <span class="variable">parameterType</span> <span class="operator">=</span> parameterTypes[p];</span><br><span class="line">      <span class="keyword">if</span> (Utils.hasUnresolvableType(parameterType)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> parameterError(p, <span class="string">&quot;Parameter type must not include a type variable or wildcard: %s&quot;</span>,</span><br><span class="line">            parameterType);</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 拿到第一个参数的 注解数组</span></span><br><span class="line">      Annotation[] parameterAnnotations = parameterAnnotationsArray[p];</span><br><span class="line">      <span class="keyword">if</span> (parameterAnnotations == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> parameterError(p, <span class="string">&quot;No Retrofit annotation found.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 解析参数</span></span><br><span class="line">      <span class="comment">// p : 0</span></span><br><span class="line">      <span class="comment">// parameterType : String</span></span><br><span class="line">      <span class="comment">// parameterAnnotations : 虽然是数组，但是就一个元素 @Path</span></span><br><span class="line">      <span class="comment">// 这个 parseParameter 就不分析了，大家自己看看源码就清楚了，无非就是构建 ParameterHandler 数组，而这个 ParameterHandler 其实就是负责解析 API 定义时每个方法的参数，并在构造 HTTP 请求时设置参数</span></span><br><span class="line">      parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解析完方法中参数的注解后，做校验</span></span><br><span class="line">    <span class="keyword">if</span> (relativeUrl == <span class="literal">null</span> &amp;&amp; !gotUrl) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(<span class="string">&quot;Missing either @%s URL or @Url parameter.&quot;</span>, httpMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isFormEncoded &amp;&amp; !isMultipart &amp;&amp; !hasBody &amp;&amp; gotBody) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(<span class="string">&quot;Non-body HTTP method cannot contain @Body.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isFormEncoded &amp;&amp; !gotField) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(<span class="string">&quot;Form-encoded method must contain at least one @Field.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isMultipart &amp;&amp; !gotPart) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(<span class="string">&quot;Multipart method must contain at least one @Part.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServiceMethod</span>&lt;&gt;(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>createCallAdapter ()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> CallAdapter&lt;T, R&gt; <span class="title function_">createCallAdapter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 拿到网络请求接口里方法的返回值类型，在我们的例子中会返回如下类型</span></span><br><span class="line">    <span class="comment">// retrofit2.Call&lt;java.util.List&lt;java.lang.Integer&gt;&gt;</span></span><br><span class="line">    <span class="type">Type</span> <span class="variable">returnType</span> <span class="operator">=</span> method.getGenericReturnType();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (Utils.hasUnresolvableType(returnType)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(</span><br><span class="line">          <span class="string">&quot;Method return type must not include a type variable or wildcard: %s&quot;</span>, returnType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果返回类型是 void ，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (returnType == <span class="keyword">void</span>.class) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(<span class="string">&quot;Service methods cannot return void.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拿到方法的 注解 ，在我们的例子中就是如下所示，大家可以自己实验下</span></span><br><span class="line">    <span class="comment">// @retrofit2.http.GET(value=users/&#123;user&#125;/repos)</span></span><br><span class="line">    Annotation[] annotations = method.getAnnotations();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 拿到注解后，返回个 CallAdapter ，跟进去看看究竟是做了什么</span></span><br><span class="line">      <span class="keyword">return</span> (CallAdapter&lt;T, R&gt;) retrofit.callAdapter(returnType, annotations);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">      <span class="keyword">throw</span> methodError(e, <span class="string">&quot;Unable to create call adapter for %s&quot;</span>, returnType);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> CallAdapter&lt;?, ?&gt; callAdapter(Type returnType, Annotation[] annotations) &#123;</span><br><span class="line">  <span class="comment">// 这里会去调用 nextCallAdapter</span></span><br><span class="line">  <span class="keyword">return</span> nextCallAdapter(<span class="literal">null</span>, returnType, annotations);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这里的参数大家注意</span></span><br><span class="line"><span class="comment">// skipPast 上面传的是 null</span></span><br><span class="line"><span class="comment">// returnType 就是  retrofit2.Call&lt;java.util.List&lt;java.lang.Integer&gt;&gt;</span></span><br><span class="line"><span class="comment">// annotations 在我们的例子中就是 @retrofit2.http.GET(value=users/&#123;user&#125;/repos)</span></span><br><span class="line"><span class="keyword">public</span> CallAdapter&lt;?, ?&gt; nextCallAdapter(<span class="meta">@Nullable</span> CallAdapter.Factory skipPast, Type returnType, Annotation[] annotations) &#123;</span><br><span class="line">  checkNotNull(returnType, <span class="string">&quot;returnType == null&quot;</span>);</span><br><span class="line">  checkNotNull(annotations, <span class="string">&quot;annotations == null&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// callAdapterFactories 是一个 ArrayList 对象，里面存放着一个 ExecutorCallAdapterFactory 对象 ，这个是在 Retrofit Builder 的时候创建的，也就是我们上面所说的生产 CallAdapter 的地方，大家可以回过头去看看。 这里的 skipPast 是null， 所以 indexOf 肯定返回的 -1， 所以这里 start = 0</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> callAdapterFactories.indexOf(skipPast) + <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 循环， 这里由于我们的 callAdapterFactories 只有一个 元素， 所以直接看 ExecutorCallAdapterFactory 的 get方法</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start, count = callAdapterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">    CallAdapter&lt;?, ?&gt; adapter = callAdapterFactories.get(i).get(returnType, annotations, <span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (adapter != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> adapter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 错误信息 builder</span></span><br><span class="line">  <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;Could not locate call adapter for &quot;</span>)</span><br><span class="line">      .append(returnType)</span><br><span class="line">      .append(<span class="string">&quot;.\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (skipPast != <span class="literal">null</span>) &#123;</span><br><span class="line">    builder.append(<span class="string">&quot;  Skipped:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; start; i++) &#123;</span><br><span class="line">      builder.append(<span class="string">&quot;\n   * &quot;</span>).append(callAdapterFactories.get(i).getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    builder.append(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  builder.append(<span class="string">&quot;  Tried:&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start, count = callAdapterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">    builder.append(<span class="string">&quot;\n   * &quot;</span>).append(callAdapterFactories.get(i).getClass().getName());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(builder.toString());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>到这里，我们别忘了我们是在干嘛，我们是在获取 CallAdapter&lt;T, R&gt; ，好了，继续看 ExecutorCallAdapterFactory 的 get 方法。 解释都在代码注释里哟，一定要看看才知道现在到底是在干啥。话说源码分析，还是得靠自己认认真真读一次源码才行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">  <span class="comment">// getRawType 会返回该类型的原始类类型 , 比如传进去的是 List&lt;? extends Runnable&gt; 会返回 List.class</span></span><br><span class="line">  <span class="comment">// 那么在我们的例子中，我们的 returnType 是 retrofit2.Call&lt;java.util.List&lt;java.lang.Integer&gt;&gt;</span></span><br><span class="line">  <span class="comment">// 那么 getRawType 后，返回的是 retrofit2.Call ，所以这里是相等的</span></span><br><span class="line">  <span class="keyword">if</span> (getRawType(returnType) != Call.class) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 根据 returnType 拿到 responseType ，这里就不跟进了，可以自己去看看</span></span><br><span class="line">  <span class="comment">// 在我们的例子中， responseType = java.util.List&lt;java.lang.Integer&gt;</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">Type</span> <span class="variable">responseType</span> <span class="operator">=</span> Utils.getCallResponseType(returnType);</span><br><span class="line">  <span class="comment">// 最后返回一个 CallAdapter</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CallAdapter</span>&lt;Object, Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> Type <span class="title function_">responseType</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> responseType;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> Call&lt;Object&gt; <span class="title function_">adapt</span><span class="params">(Call&lt;Object&gt; call)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExecutorCallbackCall</span>&lt;&gt;(callbackExecutor, call);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>到这里，其实我们大概知道这个 CallAdapter 有什么用了，就是提供两个东西</p>
<ul>
<li>网络请求响应要返回的类型 responseType</li>
<li>retrofit2.Call&lt; T &gt; ，注意这里不是 okhttp3 下的 Call ，这里暂不深究。</li>
</ul>
<p>因为我们不要忘了现在在做什么，我们现在是在获取 ServiceMethod 中的 callAdapter 变量值。所以看到这里返回了一个 CallAdapter 对象即可。<br>createResponseConverter ()<br>这里个方法是获取 响应转换器， 就是把网络请求得到的响应数据转换成相应的格式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Converter&lt;ResponseBody, T&gt; <span class="title function_">createResponseConverter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 拿到方法上所有的注解，在我们的例子中就只有 @GET 注解</span></span><br><span class="line">    Annotation[] annotations = method.getAnnotations();</span><br><span class="line">    <span class="comment">// 这里的 responseType 就是上面我们得到的 List&lt;Integer&gt;</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> retrofit.responseBodyConverter(responseType, annotations);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">      <span class="keyword">throw</span> methodError(e, <span class="string">&quot;Unable to create converter for %s&quot;</span>, responseType);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>这里想必大家也知道套路了，跟获取 CallAdapter 是一样的，代码就不贴了，代码里同样是循环遍历 Retrofit 里的 converterFactories 变量。而这个 converterFactories 在我们的例子中是没有设置转换器的，所以它也只有一个默认的元素，即 BuiltInConverters 。 那么我们直接查看 它的 responseBodyConverter 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">BuiltInConverters</span> <span class="keyword">extends</span> <span class="title class_">Converter</span>.Factory &#123;</span><br><span class="line"> <span class="comment">// 注意这里的参数，别忘了到底是什么</span></span><br><span class="line"> <span class="comment">// type : 就是我们的 responseType ，即 List&lt;Integer&gt;</span></span><br><span class="line"> <span class="comment">// annotations : 这里我们方法的注解只有一个，所以就是 @GET</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations,</span><br><span class="line">     Retrofit retrofit) &#123;</span><br><span class="line">   <span class="keyword">if</span> (type == ResponseBody.class) &#123;</span><br><span class="line">     <span class="keyword">return</span> Utils.isAnnotationPresent(annotations, Streaming.class)</span><br><span class="line">         ? StreamingResponseBodyConverter.INSTANCE</span><br><span class="line">         : BufferingResponseBodyConverter.INSTANCE;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (type == Void.class) &#123;</span><br><span class="line">     <span class="keyword">return</span> VoidResponseBodyConverter.INSTANCE;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过这里我们可以知道，其实它会返回 null 。 所以我们 ServiceMethod 中的 Builder 中的 responseConverter 变量就等于 null 。</p>
<p>parseMethodAnnotation ()<br>我们来看看 解析方法注解 ，注意我们例子中这个方法里传的参数是 @GET 注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseMethodAnnotation</span><span class="params">(Annotation annotation)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> DELETE) &#123;</span><br><span class="line">     parseHttpMethodAndPath(<span class="string">&quot;DELETE&quot;</span>, ((DELETE) annotation).value(), <span class="literal">false</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> GET) &#123;</span><br><span class="line">     <span class="comment">//我们这里是 GET 注解，所以进这个方法</span></span><br><span class="line">     parseHttpMethodAndPath(<span class="string">&quot;GET&quot;</span>, ((GET) annotation).value(), <span class="literal">false</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> HEAD) &#123;</span><br><span class="line">     parseHttpMethodAndPath(<span class="string">&quot;HEAD&quot;</span>, ((HEAD) annotation).value(), <span class="literal">false</span>);</span><br><span class="line">     <span class="keyword">if</span> (!Void.class.equals(responseType)) &#123;</span><br><span class="line">       <span class="keyword">throw</span> methodError(<span class="string">&quot;HEAD method must use Void as response type.&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 省略后续代码，后续还有很多其他类型的判断</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这里的三个参数的值</span></span><br><span class="line"><span class="comment">// httpMethod : GET</span></span><br><span class="line"><span class="comment">// value : users/&#123;user&#125;/repos</span></span><br><span class="line"><span class="comment">// hasBody : false</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseHttpMethodAndPath</span><span class="params">(String httpMethod, String value, <span class="type">boolean</span> hasBody)</span> &#123;</span><br><span class="line">   <span class="comment">// 此处判断 httpMethod 的值是否存在，说明只允许一个 HTTP 方法存在</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.httpMethod != <span class="literal">null</span>) &#123;</span><br><span class="line">     <span class="keyword">throw</span> methodError(<span class="string">&quot;Only one HTTP method is allowed. Found: %s and %s.&quot;</span>,</span><br><span class="line">         <span class="built_in">this</span>.httpMethod, httpMethod);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">this</span>.httpMethod = httpMethod;</span><br><span class="line">   <span class="built_in">this</span>.hasBody = hasBody;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span> (value.isEmpty()) &#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 下面是解析 value 中的 相对 url</span></span><br><span class="line">   <span class="comment">// Get the relative URL path and existing query string, if present.</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">question</span> <span class="operator">=</span> value.indexOf(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">   <span class="keyword">if</span> (question != -<span class="number">1</span> &amp;&amp; question &lt; value.length() - <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="comment">// Ensure the query string does not have any named parameters.</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">queryParams</span> <span class="operator">=</span> value.substring(question + <span class="number">1</span>);</span><br><span class="line">     <span class="type">Matcher</span> <span class="variable">queryParamMatcher</span> <span class="operator">=</span> PARAM_URL_REGEX.matcher(queryParams);</span><br><span class="line">     <span class="keyword">if</span> (queryParamMatcher.find()) &#123;</span><br><span class="line">       <span class="keyword">throw</span> methodError(<span class="string">&quot;URL query string \&quot;%s\&quot; must not have replace block. &quot;</span></span><br><span class="line">           + <span class="string">&quot;For dynamic query parameters use @Query.&quot;</span>, queryParams);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">this</span>.relativeUrl = value;</span><br><span class="line">   <span class="comment">// 相对地址中的参数名字，这里不具体分析了，可以把结果告诉你</span></span><br><span class="line">   <span class="comment">// 在我们的例子中 value = “users/&#123;user&#125;/repos”</span></span><br><span class="line">   <span class="comment">// 这里的 relativeUrlParamNames 是个 Set&lt;String&gt; 集合 ，里面只有一个元素 user 。</span></span><br><span class="line">   <span class="built_in">this</span>.relativeUrlParamNames = parsePathParameters(value);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>至此，我们的 Builder 把 Http 的方法以及它的 Url 给分析完了，现在只剩 参数解析了。参数解析在 ServiceMethod 的 build 方法里已经讲过了 ，记得看注释。<br>呼~ 终于讲完了 ServiceMethod 的构造。这么大篇幅，由此可以看出 ServiceMethod 这个类非常重要。现在来总结一下，我们究竟拥有了些什么。</p>
<ul>
<li>callFactory : ExecutorCallAdapterFactory 实例</li>
<li>callAdapter : ExecutorCallAdapterFactory中的get 方法返回的 CallAdapter 实例</li>
<li>baseUrl ： HttpUrl 实例</li>
<li>responseConverter : 由于我们没设置，所以为 null</li>
<li>httpMethod : 字符串 GET</li>
<li>relativeUrl ：字符串 users&#x2F;{user}&#x2F;repos</li>
<li>headers : 没有设置 Headers ，所以为 null</li>
<li>contentType : null</li>
<li>hasBody : false</li>
<li>isFormEncoded : false</li>
<li>isMultipart : false</li>
<li>parameterHandlers : 就我们例子而已，该数组有一个元素，Path 对象，它是 ParameterHandler 抽象类里的一个静态内部类。</li>
</ul>
<p>由此可以看出，ServiceMethod 对象包含了访问网络的所有基本信息。</p>
<p>好吧，接下来还是得继续前行，别忘了，我们构建 ServiceMethod 只是在 invoke 方法内，并且这还只是第一步。接下来看第二步。<br>OkHttpCall<Object> okHttpCall &#x3D; new OkHttpCall&lt;&gt;(serviceMethod, args);<br>这里是 new 一个 OkHttpCall 对象，这个 OkHttpCall 是 Retrofit 的 Call，它里面就是做请求的地方，会有 request、enqueue 等同步、异步请求方法，但是在这里面真正执行请求的是 okhttp3.Call ，即把请求委托给 okHttp 去执行。下面简要看看它的构造方法和一些成员变量吧，因为这里只是 new 操作，所以暂时不分析其余方法，用到的时候再看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">OkHttpCall</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Call</span>&lt;T&gt; &#123;</span><br><span class="line"> <span class="comment">// 含有所有网络请求参数信息的 ServiceMethod</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> ServiceMethod&lt;T, ?&gt; serviceMethod;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> canceled;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 实际进行网络请求的 Call</span></span><br><span class="line"> <span class="keyword">private</span> <span class="meta">@Nullable</span> okhttp3.Call rawCall;</span><br><span class="line"> <span class="meta">@GuardedBy(&quot;this&quot;)</span> <span class="comment">// Either a RuntimeException, non-fatal Error, or IOException.</span></span><br><span class="line"> <span class="keyword">private</span> <span class="meta">@Nullable</span> Throwable creationFailure;</span><br><span class="line"> <span class="meta">@GuardedBy(&quot;this&quot;)</span></span><br><span class="line"> <span class="keyword">private</span> <span class="type">boolean</span> executed;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 传入配置好的 ServiceMethod 和 请求参数</span></span><br><span class="line"> OkHttpCall(ServiceMethod&lt;T, ?&gt; serviceMethod, <span class="meta">@Nullable</span> Object[] args) &#123;</span><br><span class="line">   <span class="built_in">this</span>.serviceMethod = serviceMethod;</span><br><span class="line">   <span class="built_in">this</span>.args = args;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样就把 OkHttpCall 给构建好了，接下来看第三步。</p>
<p>return serviceMethod.adapt(okHttpCall);<br>直接上代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T <span class="title function_">adapt</span><span class="params">(Call&lt;R&gt; call)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> callAdapter.adapt(call);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这是 前面构建好的 ServiceMethod 中的 adapt 方法，会去调用 callAdapter 的 adapt 方法，我们知道 ServiceMethod 中的 callAdapter 是 ExecutorCallAdapterFactory中的get 方法返回的 CallAdapter 实例。而这个实例的 adapt 方法会返回一个 ExecutorCallbackCall 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- ExecutorCallAdapterFactory 内部类 --&gt;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ExecutorCallbackCall</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Call</span>&lt;T&gt; &#123;</span><br><span class="line">   <span class="comment">// 这里在之前创建ExecutorCallAdapterFactory时，就知道它的值了，就是 MainThreadExecutor ，用来切换线程的</span></span><br><span class="line">   <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line">   <span class="comment">// 这就是刚刚传进来的 OkHttpCall</span></span><br><span class="line">   <span class="keyword">final</span> Call&lt;T&gt; delegate;</span><br><span class="line"></span><br><span class="line">   ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class="line">     <span class="built_in">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">     <span class="built_in">this</span>.delegate = delegate;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>到这里为止，我们已经成功的返回了一个 Call&lt;List<Integer>&gt;<br>调用 Call 的 enqueue<br>趁热打铁，我们执行异步请求，看看怎样切换线程的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- ExecutorCallbackCall 内部 --&gt;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> &#123;</span><br><span class="line">     checkNotNull(callback, <span class="string">&quot;callback == null&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 真正的 Call 去执行请求</span></span><br><span class="line">     delegate.enqueue(<span class="keyword">new</span> <span class="title class_">Callback</span>&lt;T&gt;() &#123;</span><br><span class="line">       <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Response&lt;T&gt; response)</span> &#123;</span><br><span class="line">         <span class="comment">// 回调后 利用 MainThreadExecutor 中的 Handler 切换到主线程中去。</span></span><br><span class="line">         callbackExecutor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">           <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (delegate.isCanceled()) &#123;</span><br><span class="line">               <span class="comment">// Emulate OkHttp&#x27;s behavior of throwing/delivering an IOException on cancellation.</span></span><br><span class="line">               callback.onFailure(ExecutorCallbackCall.<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Canceled&quot;</span>));</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               callback.onResponse(ExecutorCallbackCall.<span class="built_in">this</span>, response);</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Throwable t)</span> &#123;</span><br><span class="line">         callbackExecutor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">           <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">             callback.onFailure(ExecutorCallbackCall.<span class="built_in">this</span>, t);</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到是 delegate 执行了 enqueue 操作，而 delegate 就是我们的 OkHttpCall ，在 OkHttpCall 里的 enqueue 方法是这样工作的。<br>通过 okhttp3.Call call &#x3D; serviceMethod.toCall(args); 构建一个真正执行请求的 Call ，即把请求交给 okhttp 去完成。而构建一个 Call 利用到了 ServiceMethod 中的 ParameterHandler 对象，这个对象是用来处理参数的。 它会把具体参数的值与 RequestBuilder 绑定起来。当然也用到了 ServiceMethod 自己，ServiceMethod 类似请求响应的大管家。</p>
<p>别忘了拿到响应后，在 okhttp3.Callback 中会去调用 response &#x3D; parseResponse(rawResponse); 将响应转换成自己想要的格式，即定义的 Converter 。</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/abd144912e2a">https://www.jianshu.com/p/abd144912e2a</a></p>
<h2 id="TCP-x2F-IP"><a href="#TCP-x2F-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h2><blockquote>
<p>《图解Http》《Http权威指南》《Java网络编程基础》</p>
</blockquote>
<p>HTTP，FTP，DNS，TCP，UDP，IP等等<br>OSI七层协议：应用层，表示层，会话层，传输层，网络层，数据链路层，物理层</p>
<h3 id="TCP三次握手（建立连接）和四次挥手（断开连接）"><a href="#TCP三次握手（建立连接）和四次挥手（断开连接）" class="headerlink" title="TCP三次握手（建立连接）和四次挥手（断开连接）"></a>TCP三次握手（建立连接）和四次挥手（断开连接）</h3><blockquote>
<p>你能听到吗？<br>我能听到，你能听到吗？<br>我能听到，bilibili</p>
</blockquote>
<blockquote>
<p>我想挂了<br>好，我还有一句话没说完<br>挂了<br>挂了</p>
</blockquote>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="请求（他们之间通信是以报文的形式）"><a href="#请求（他们之间通信是以报文的形式）" class="headerlink" title="请求（他们之间通信是以报文的形式）"></a>请求（他们之间通信是以报文的形式）</h3><ul>
<li>客户端请求（Request）：请求报文 &#x3D; 请求头 + 空行 + 请求数据</li>
<li>Accept: 客户端可以处理的数据格式</li>
<li>Cookie：服务端的之前给我们的Cookie</li>
<li>服务端响应（Response）：响应报文 &#x3D; 响应头 + 空行 + 响应数据</li>
<li>Status Code 响应状态码</li>
<li>Content-Type: 响应返回的类型 （文本，utf-8）图片等等</li>
<li>Set-Cookie：服务端给我们的Cookie，要保存起来，下次带过去</li>
</ul>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/qOMO0LIdA47j3RjhbCWUEQ">Http 缓存机制</a></p>
<ul>
<li>Cache-Control（缓存策略）：Public、private、no-cache、max-age 、no-store（不缓存）</li>
<li>Expires（缓存的过期策略）：指名了缓存数据有效的绝对时间，告诉客户端到了这个时间点（比照客户端时间点）后本地缓存就作废了，在这个时间点内客户端可以认为缓存数据有效，可直接从缓存中加载展示。</li>
<li>如果有缓存并且过期了那么发起请求，那么服务端会给我们数据？（不一定会给）服务器的数据没有变动就不会给，状态码会变为 304 ，自己拿之前过期的缓存</li>
</ul>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><ul>
<li>1xx:  Infomational (信息状态码) ，接收的请求正在处理</li>
<li>2xx:  Succeed(成功)，请求正常处理完毕,如 200</li>
<li>3xx:  Redirection(重定向)，需要进行附加操作，一般是没有响应数据返回的，如 304（Not,modified）307 </li>
<li>4xx: Client Error (客户端的错误)，服务器无法处理请求，如 404</li>
<li>5xx: Server Error (服务端的错误)，服务器处理请求出错，如 500</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>数据是没有加密传输，可能遭遇窃听</li>
<li>不验证通信方的身份，可能会遭遇伪装</li>
<li>无法验证报文的完整性，可能会遭遇篡改</li>
</ul>
<h3 id="post格式"><a href="#post格式" class="headerlink" title="post格式"></a>post格式</h3><h4 id="普通"><a href="#普通" class="headerlink" title="普通"></a>普通</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">startBoundary + <span class="string">&quot;\r\n&quot;</span></span><br><span class="line">Content-Dispsotion: form-data; name = <span class="string">&quot;pageSize&quot;</span></span><br><span class="line">Context-Type: text/palint</span><br><span class="line"><span class="number">1</span></span><br><span class="line">startBoundary + <span class="string">&quot;\r\n&quot;</span></span><br><span class="line">Content-Dispsotion: form-data; name = <span class="string">&quot;pageNo&quot;</span></span><br><span class="line">Context-Type: text/palint</span><br><span class="line"><span class="number">1</span></span><br><span class="line">endBoundary</span><br></pre></td></tr></table></figure>
<h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">startBoundary + <span class="string">&quot;\r\n&quot;</span></span><br><span class="line">Content-Dispsotion: form-data; name = <span class="string">&quot;file&quot;</span>; filename=<span class="string">&quot;test.png&quot;</span> </span><br><span class="line">Context-Type: (文件的type) </span><br><span class="line">文件的内容流</span><br><span class="line">startBoundary + <span class="string">&quot;\r\n&quot;</span></span><br><span class="line">Content-Dispsotion: form-data; name = <span class="string">&quot;file&quot;</span>; filename=<span class="string">&quot;test.png&quot;</span> </span><br><span class="line">Context-Type: (文件的type) </span><br><span class="line">文件的内容流</span><br></pre></td></tr></table></figure>

<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="和Http的区别"><a href="#和Http的区别" class="headerlink" title="和Http的区别"></a>和Http的区别</h3><ul>
<li>Https &#x3D; Http + 加密 + 验证 + 完整</li>
<li>端口：Http (80)  Https (443)</li>
</ul>
<h3 id="TLS-x2F-SSL-协议"><a href="#TLS-x2F-SSL-协议" class="headerlink" title="TLS&#x2F;SSL 协议"></a>TLS&#x2F;SSL 协议</h3><p>加密：对称加密（AES，DES） + 非对称加密 (RSA，DSA)<br>证书：要钱（便宜），建立连接的速度会拖慢，TCP  3 次握手，8 次握手</p>
<p><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/%E7%BD%91%E7%BB%9C/.%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.jpg" alt="Alt text"><br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/%E7%BD%91%E7%BB%9C/.%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.jpg" alt="Alt text"></p>
<h3 id="Http-1-x-和-Http-2-0-的区别"><a href="#Http-1-x-和-Http-2-0-的区别" class="headerlink" title="Http 1.x 和 Http 2.0 的区别"></a>Http 1.x 和 Http 2.0 的区别</h3><ul>
<li>Http 2.0 采用二进制格式而非文本格式</li>
<li>Http 2.0 支持完全的多路复用</li>
<li>Http 2.0 使用报头压缩，降低开销</li>
<li>Http 2.0 让服务器将响应主动推送给客户端，（带内容推送，不带内容推送的通知）<br><img src="https://uncle2000-blog.oss-cn-chengdu.aliyuncs.com/%E7%BD%91%E7%BB%9C/.Http1.0%E5%92%8CHttp2.0%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="Alt text"></li>
</ul>
<h2 id="Cookie-、Session、Token"><a href="#Cookie-、Session、Token" class="headerlink" title="Cookie 、Session、Token"></a>Cookie 、Session、Token</h2><blockquote>
<p>1 都是用来做持久化处理的，目的就是让客户端和服务端相互认识。Http请求默认是不持久的没有状态的，谁也不认识谁<br>2 Cookie: 是存放在客户端的信息，这个信息是来自于服务器返回的信息，<br>下次请求带过去，如果用户离开网站后，如果Cookie已过期一般是会被清楚的。如果Cookie没过期下次访问网站还是会带过去。（相对危险）<br>3 Session: 是存放在服务器上面的客户端临时信息，用户离开网站是会被清除的。（相对安全，耗资源）<br>4 Token（App）”令牌”：用户身份的验证，有点类似于 Cookie ，相对来说更安全，一般流程：<br>4.1 客户端像服务端申请 Token<br>4.2 服务端收到请求，会去验证用户信息,签发一个 Token 给客户端，自己保存 Token<br>4.3 客户端收到 Token 会保存起来，每次请求带上 Token<br>4.4 服务器收到其他请求，会去验证客户端的 Token , 如果成功返回数据，不成功啥都不给</p>
</blockquote>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>王水泥</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://king-of-cement.gitee.io/blog/post/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">http://king-of-cement.gitee.io/blog/post/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/blog/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/blog/post/%E6%A8%A1%E6%9D%BF/%E7%BA%A6%E6%9D%9F%E8%8C%83%E5%9B%B4/">MD read me</a>
            
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 王水泥 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>